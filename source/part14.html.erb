---
  title: Osa 14
  exercise_page: true
  quiz_page: true
  published: false
---

<% partial 'partials/hint', locals: { name: 'Neljännentoista osan tavoitteet' } do %>

  <p>
    Tuntee käsitteet säännöllinen lauseke, lueteltu tyyppi, ja iteraattori, ja osaa käyttää näitä osana ohjelmia. Osaa kirjoittaa tiedostoon. Muistaa käsitteen yksikkötesti ja osaa kertoa hyvien ja huonojen yksikkötestien ominaisuuksista. Tietää miten paljon käytetyt ArrayList ja HashMap toimivat. Tietää aikaan perustuvan tavan tietorakenteiden tehokkuuden vertailuun. Tietää ohjelmoinnin jatkokurssin jälkeen otettavia kursseja. 
  </p>

<% end %>




<% partial 'partials/material_sub_heading' do %>
  Toistuva piirtäminen ja animaatiot
<% end %>

<p>
  Canvas-luokan avulla voidaan myös piirtää kuvaa jatkuvasti. Tällaista tarvitaan esimerkiksi animaation yhteydessä. Jatkuvasti piirtäminen -- tai oikeammin tietyn aikavälin jälkeen uudelleen piirtäminen -- tapahtuu <a href="https://docs.oracle.com/javase/8/javafx/api/javafx/animation/AnimationTimer.html" target="_blank" rel="noopener">AnimationTimer</a>-luokan avulla. AnimationTimer-luokka määrittelee metodin <a href="https://docs.oracle.com/javase/8/javafx/api/javafx/animation/AnimationTimer.html#handle-long-" target="_blank" rel="noopener">handle</a>, joka luokkaa käyttävän ohjelmoijan tulee toteuttaa. Metodi saa parametrina nykyhetken nanosekunteina, jonka avulla voidaan vaikuttaa piirtovälien pituuteen. Samaa kuvaa ei esimerkiksi kannata piirtää käyttäjälle tuhatta kertaa sekunnissa, mutta toisaalta nopeasti liikkuvan kuvan päivittäminen käyttäjälle esimerkiksi kerran sekunnissa ei sekään ole toivottua.
</p>

<p>
  Alla olevassa esimerkissä on ohjelma, jossa piirretään satunnaiseen kohtaan piste kymmenen kertaa sekunnissa.
</p>

<% partial 'partials/code_highlight' do %>
  // pakkaus..

  import java.util.Random;
  import javafx.animation.AnimationTimer;
  import javafx.application.Application;
  import javafx.scene.Scene;
  import javafx.scene.canvas.Canvas;
  import javafx.scene.canvas.GraphicsContext;
  import javafx.scene.layout.BorderPane;
  import javafx.scene.paint.Color;
  import javafx.stage.Stage;

  public class AnimaationAlku extends Application {

      @Override
      public void start(Stage ikkuna) {

          Canvas piirtoalusta = new Canvas(320, 240);
          GraphicsContext piirturi = piirtoalusta.getGraphicsContext2D();
          piirturi.setFill(Color.BLACK);

          BorderPane asettelu = new BorderPane();
          asettelu.setCenter(piirtoalusta);

          Random arpoja = new Random();

          new AnimationTimer() {
              long edellinen = 0;

              @Override
              public void handle(long nykyhetki) {
                  if (nykyhetki - edellinen < 100000000) {
                      return;
                  }

                  int x = arpoja.nextInt(310);
                  int y = arpoja.nextInt(230);

                  piirturi.fillOval(x, y, 10, 10);

                  this.edellinen = nykyhetki;
              }
          }.start();

          Scene nakyma = new Scene(asettelu);

          ikkuna.setScene(nakyma);
          ikkuna.show();
      }

      public static void main(String[] args) {
          launch(AnimaationAlku.class);
      }
  }
<% end %>

<p>
  Ohjelma toimii käynnistyessään seuraavasti. Huomaathan, että pisteet ovat satunnaisia, joten oma kokeilusi tuskin tuottaa täsmälleen samanlaista tulosta.
</p>

<img src="/img/material/gui-animaatio.gif" alt="Edellinen ohjelma toiminnassa. Kuvaan ilmestyy kymmenen pistettä sekunnissa."/>

<p>&nbsp;</p>

<p>
  Silloin tällöin ohjelma halutaan toteuttaa siten, että uusi tila piirretään aina edellisen tilanteen päälle. Tällöin tapana on tyhjentää ruutu ennen uutta piirtämistä. Tämä onnistuu lisäämällä edelliseen ohjelmaan rivi <code>piirturi.clearRect(0, 0, 320, 240);</code> ennen handle-metodissa olevaa piirtokomentoa. Komento tyhjentää kohdasta (0, 0) lähtien 320 pikseliä leveän ja 240 pikseliä korkean suunnikkaan.
</p>




<% partial 'partials/exercise', locals: { name: 'Hiekkaranta (5 osaa)' } do %>

  <p>
    Tässä tehtävässä luodaan <a href="https://en.wikipedia.org/wiki/Falling-sand_game" target="_blank" rel="noopener">falling sand game</a>-tyyppinen sovellus, jota käytetään erilaisten aineiden simulointiin. Ohjelmassamme simuloidaan hiekan ja veden käyttäytymistä. Lopullisen sovelluksen toiminta on seuraavanlainen.
  </p>

  <img src="/img/material/gui-simulaatio.gif" alt="Esimerkki hiekkaranta-simulaation toiminnasta." />

  <p>
    &nbsp;
  </p>

  <p>
    Huom! Kun toteutat simulaatiota, varmista että ohjelma pitää tarpeeksi pitkiä taukoja piirtämisten ja simulaatioiden välillä. Tällöin tehoja jää myös testien ajamiseen. Testien suorittaminen palvelimella päätyy heikosti, jos kaikki palvelimen teho menee animaation suorittamiseen. Tällöin testien ajon viestinä on esim. kryptinen "Missing test output.". Jos saat tämän virheen palvelimelta, kokeile suoritusta esimerkiksi siten, että simulaatiota piirretään korkeintaan 10 kertaa sekunnissa ja päivitetään korkeintaan 20 kertaa sekunnissa.
  </p>

  <p>
    Huom2! Kun piirrät pohjaa, piirrä musta alue yhtenä isona suorakulmiona piirtämisen alussa. Näin jokaista yksittäistä tyhjää (eli mustaa)  pistettä ei tarvitse erikseen piirtää, ja voit keskittyä muiden pisteiden piirtämiseen.
  </p>

  <p>
    <em>
      Tehtävässä käytetään <code>enum</code>-tyyppistä luokkaa <code>Tyyppi</code>. Javassa ohjelmoija voi määritellä rajatulle määrälle käsitteitä <code>enum</code>-tyyppisen luokan, jossa näille käsitteille annetaan nimi. Luokka on seuraavanlainen.
    </em>
  </p>

  <% partial 'partials/code_highlight' do %>
    package hiekkaranta;

    public enum Tyyppi {
        TYHJA, METALLI, HIEKKA, VESI;
    }

  <% end %>

  <p>
    Enum-muuttujia käytetään esimerkiksi seuraavasti.
  </p>

  <% partial 'partials/code_highlight' do %>
    Tyyppi t = Tyyppi.TYHJA;
    if (t == Tyyppi.TYHJA) {
        System.out.println("Tyhjää täynnä.");
    }

    if (t == Tyyppi.HIEKKA) {
        System.out.println("Hiekalta näyttää.");
    }

    Tyyppi[] taulukko = new Tyyppi[10];
    taulukko[0] = Tyyppi.VESI;
    System.out.println(taulukko.length);
  <% end %>


  <h2>Palaset kohdalleen</h2>

  <p>
    Luo tehtäväpohjassa olevaan luokkaan graafinen käyttöliittymä. Graafisen käyttöliittymän komponenttien asettelu tulee tehdä BorderPane-luokan avulla. Lisää BorderPane-luokan keskelle Canvas-olio, jota käytetään piirtämiseen. Aseta Canvas-olion leveydeksi ja korkeudeksi 200 pikseliä. Lisää BorderPane-luokan oikealle laidalle VBox-olio, joka sisältää kolme <a href="https://docs.oracle.com/javase/8/javafx/api/javafx/scene/control/RadioButton.html" target="_blank" rel="noopener">RadioButton</a>-oliota. Ensimmäiseen RadioButton-olioon tulee liittyä teksti "Metalli", toiseen teksti "Hiekka", ja kolmanteen teksti "Vesi".
  </p>

  <h2>Simulaation alkupalat</h2>

  <p>
    Luo pakkaukseen hiekkaranta luokka Simulaatio. Luokalla Simulaatio tulee olla seuraavat konstruktorit ja metodit. Käytä luokassa hyödyksi valmista enum-luokkaa Tyyppi, ja toteuta simulaation sisäinen tiedon esitys kaksiulotteisena taulukkona <code>Tyyppi[][]</code>.
  </p>

  <ul>
    <li>
      Konstruktori <code>public Simulaatio(int leveys, int korkeus)</code> luo annetun levyisen ja korkuisen simulaation. Jokaisen kohdan arvon tulee olla aluksi <code>Tyyppi.TYHJA</code>.
    </li>
    <li>
      Metodi <code>public void lisaa(int x, int y, Tyyppi tyyppi</code> asettaa annettuun kohtaan annetun tyyppisen elementin. Tyyppi on joko <code>Tyyppi.TYHJA</code>, <code>Tyyppi.METALLI</code>, <code>Tyyppi.HIEKKA</code> tai <code>Tyyppi.VESI</code>. 
    </li>
    <li>
      Metodi <code>public Tyyppi sisalto(int x, int y)</code> palauttaa annetussa kohdassa olevan sisällön. Vastaus on joko Tyyppi.TYHJA, Tyyppi.METALLI, Tyyppi.HIEKKA tai Tyyppi.VESI. Jos kohtaan ei ole lisätty mitään arvoa, tyyppi on Tyyppi.TYHJA. Jos käyttäjä kysyy tietoa alueen ulkopuolelta, palauta Tyyppi.METALLI.
    </li>
    <li>
      Metodi <code>public void paivita()</code> päivittää simulaatiota yhden askeleen. Päivitystoiminnallisuuden toteutus aloitetaan tehtävän myöhemmissä osassa.
    </li>
  </ul>


  <h2>Metallin lisääminen ja piirtäminen</h2>

  <p>
    Lisää edellä toteuttamasi Simulaatio osaksi käyttöliittymää. Aseta simulaation leveydeksi 200 ja korkeudeksi 200 pikseliä (simulaation tulee toki toimia myös muun kokoisena). Lisää tämän jälkeen sovellukseen mahdollisuus metallin lisäämiseen. Metallia lisätään kun kun metalli on valittuna oikealla laidalla olevasta valikosta ja käyttäjä piirtää kuvaan (eli painaa hiiren napin pohjaan ja liikuttaa hiirtä sovelluksen päällä).
  </p>

  <p>
    Käytä simulaation käyttäjälle näyttämiseen AnimationTimer-luokkaa sekä Canvas-oliota. Piirrä canvas-olion sisältö uudestaan kymmenen kertaa sekunnissa. Käytä tyhjälle elementille mustaa väriä värillä (<code>Color.BLACK</code>) ja metallille valkoisella värillä (<code>Color.WHITE</code>).
  </p>

  <p>
    Kun metallin lisääminen onnistuu, ohjelma toimii seuraavalla tavalla. Alla olevassa esimerkissä hiiren pohjassapito lisää useampia metallipisteitä samaan aikaan -- yhden pisteen lisääminen on myös toki ok.
  </p>


  <img src="/img/material/gui-simulaatio-metalli.gif" alt="Esimerkki hiekkaranta-simulaation toiminnasta." />

  <p>
    &nbsp;
  </p>


  <h2>Hiekan lisääminen ja toiminnallisuus</h2>

  <p>
    Lisää tämän jälkeen toiminnallisuus hiekan lisäämiseen ja piirtämiseen. Hiekka tulee piirtää oranssilla värillä <code>Color.ORANGE</code>.
  </p>

  <p>
    Kun hiekan lisääminen käyttöliittymässä onnistuu, muokkaa tämän jälkeen Simulaatio-luokan metodia paivita. Metodin paivita tulee toimia siten, että se tarkistaa jokaiselle hiekkaa sisältävälle kohdalle kohdan alla olevat kolme vaihtoehtoa (lounas, etelä, kaakko). Jos joku vaihtoehdoista on tyhjä, hiekka siirretään alaspäin tyhjään kohtaan. Mikäli useampi kuin yksi em vaihtoehdoista on tyhjiä, tee valinta satunnaisesti tyhjien vaihtoehtojen välillä.
  </p>

  <p>
    Satunnaisuutta saat Random-luokan avulla.
  </p>

  <p>
    Huom! Toteuta simulaatio siten, että y-koordinaatti on "käänteinen". Simulaation sisällä y-koordinaatin kasvatus tarkoittaa alaspäin menoa, ja toisaalta y-koordinaatin pienennys ylöspäin menoa. Tämä auttaa piirtämisessä, sillä piirtäessä y-koordinaatti kasvaa alaspäin mennessä.
  </p>

  <img src="/img/material/gui-simulaatio-metalli-ja-hiekka.gif" alt="Esimerkki hiekkaranta-simulaation toiminnasta. Kuvassa hiekka toimii metallin kanssa." />
  
  <p>
    &nbsp;
  </p>

  

  <h2>Veden lisääminen</h2>

  <p>
    Lisää tämän jälkeen toiminnallisuus veden lisäämiseen ja piirtämiseen. Piirrä vesi käyttäen väriä <code>Color.LIGHTBLUE</code>.
  </p>

  <p>
    Muokkaa tämän jälkeen Simulaatio-luokan metodia paivita siten, että se siirtää kutsun yhteydessä vettä alaspäin <em>jos</em> joku veden alapuolella olevista kohdista (lounas, etelä, kaakko) on tyhjä. Jos yksikään kohdista ei ole tyhjiä, mutta jommalla kummalla laidalla on sijaa, siirretään vettä sivulle.
  </p>

  <p>
    Muokkaa vielä sovellusta siten, että hiekka syrjäyttää veden. Kun lisäät hiekkaa, veden tulee siis väistää hiekkaa. Nyt sovelluksen pitäisi toimia kokonaisuudessaan!
  </p>

  <p>
    
  </p>
  
  <img src="/img/material/gui-simulaatio.gif" alt="Esimerkki hiekkaranta-simulaation toiminnasta." />

  <p>
    &nbsp;
  </p>

  <p>
    Kun olet palauttanut tehtävän, jatka seuraaviin tehtäviin. Kun olet saanut osan kaikki tehtävät valmiiksi, voit palauta tähän tehtävään ja lähteä toteuttamaan uusia toiminnallisuuksia. Miten toteuttaisit esimerkiksi laavan?
  </p>


<% end %>






<% partial 'partials/material_heading' do %>
  Multimedian käyttö sovelluksissa
<% end %>

<p>
  Tutustutaan lyhyesti multimedian käyttöön JavaFX-sovelluksissa.
</p>



<% partial 'partials/material_sub_heading' do %>
  Piirtäminen
<% end %>

<p>
  JavaFX-käyttöliittymäkirjastossa piirtämiseen käytetään <a href="https://docs.oracle.com/javase/8/javafx/api/javafx/scene/canvas/Canvas.html" target="_blank" rel="noopener">Canvas</a>-oliota. Canvas-olio edustaa tyhjää taulua, johon voi piirtää. Piirtäminen tapahtuu Canvas-oliolta saatavalla <a href="https://docs.oracle.com/javase/8/javafx/api/javafx/scene/canvas/GraphicsContext.html" target="_blank" rel="noopener">GraphicsContext</a>-oliolla.
</p>

<p>
  Alla olevassa esimerkissä on luotu yksinkertainen piirto-ohjelma. Ohjelmassa luodaan 640 pikseliä leveä ja 480 pikseliä korkea piirtoalusta, joka asetetaan BorderPane-asettelun keskelle. Tämän lisäksi luodaan piirtovärin valintaan käytettävä <a href="https://docs.oracle.com/javase/8/javafx/api/javafx/scene/control/ColorPicker.html" target="_blank" rel="noopener">ColorPicker</a>-olio, jolta saa tietoonsa kullakin hetkellä valittuna olevan värin. Värin valitsin asetetaan BorderPane-asettelun oikealle laidalle. Piirtoalustaan lisätään hiiren liikkumista kuunteleva tapahtuman käsittelijä. Kun hiirtä liikutetaan nappi pohjassa (onMouseDragged), kutsutaan GraphicsContext-olion värin asetusmetodia sekä piirretään hiiren kohtaan pieni ympyrä.
</p>

<% partial 'partials/code_highlight' do %>
  // pakkaus

  import javafx.application.Application;
  import javafx.scene.Scene;
  import javafx.scene.canvas.Canvas;
  import javafx.scene.canvas.GraphicsContext;
  import javafx.scene.control.ColorPicker;
  import javafx.scene.layout.BorderPane;
  import javafx.stage.Stage;

  public class MiniPaint extends Application {

      @Override
      public void start(Stage ikkuna) {

          Canvas piirtoalusta = new Canvas(640, 480);
          GraphicsContext piirturi = piirtoalusta.getGraphicsContext2D();

          ColorPicker varinValitsin = new ColorPicker();

          BorderPane asettelu = new BorderPane();
          asettelu.setCenter(piirtoalusta);
          asettelu.setRight(varinValitsin);

          piirtoalusta.setOnMouseDragged((event) -&gt; {
              double kohtaX = event.getX();
              double kohtaY = event.getY();
              piirturi.setFill(varinValitsin.getValue());
              piirturi.fillOval(kohtaX, kohtaY, 4, 4);
          });

          Scene nakyma = new Scene(asettelu);

          ikkuna.setScene(nakyma);
          ikkuna.show();
      }

      public static void main(String[] args) {
          launch(MiniPaint.class);
      }
  }
<% end %>

<p>
  Sovellus näyttää seuraavanlaiselta. Alla sovellusta on käytetty jo hieman piirtämiseen.
</p>

<img src="/img/material/gui-paint.png" alt="Yksinkertainen piirto-ohjelma. Käyttäjä voi piirtää pitämällä hiirtä pohjassa. Oikeassa laidassa on värin valintaan käytettävä ColorPicker-olio."/>

<p>
  &nbsp;
</p>


<% partial 'partials/exercise', locals: { name: 'Hymiö' } do %>

  <p>
    Luo tehtäväpohjassa olevaan luokkaan graafinen käyttöliittymä. Lisää graafiseen käyttöliittymään asettelusta vastaava BorderPane-olio. Lisää BorderPanen keskellä Canvas-olio. Piirrä tämän jälkeen Canvas-olioon liittyvän GraphicsContext-olion avulla hymiö. Käytä taustan värinä valkoista (Color.WHITE) ja hymiön värinä mustaa (Color.BLACK). 
  </p>

  <p>
    Tehtävän testit tarkastavat vain, että piirrät ikkunaan. Palauta tehtävä vasta kun saat hymiön piirtämisen toimimaan. Huomaa ettei tässä ole tarkoitus piirtää hymiötä esimerkiksi hiirellä -- käytä suoraan GraphicsContext-olion tarjoamia metodeja.
  </p>

  <img src="/img/material/gui-hymio.png" alt="Hymiö" />

<% end %>


<% partial 'partials/material_sub_heading' do %>
  Toistuva piirtäminen ja animaatiot
<% end %>

<p>
  Canvas-luokan avulla voidaan myös piirtää kuvaa jatkuvasti. Tällaista tarvitaan esimerkiksi animaation yhteydessä. Jatkuvasti piirtäminen -- tai oikeammin tietyn aikavälin jälkeen uudelleen piirtäminen -- tapahtuu <a href="https://docs.oracle.com/javase/8/javafx/api/javafx/animation/AnimationTimer.html" target="_blank" rel="noopener">AnimationTimer</a>-luokan avulla. AnimationTimer-luokka määrittelee metodin <a href="https://docs.oracle.com/javase/8/javafx/api/javafx/animation/AnimationTimer.html#handle-long-" target="_blank" rel="noopener">handle</a>, joka luokkaa käyttävän ohjelmoijan tulee toteuttaa. Metodi saa parametrina nykyhetken nanosekunteina, jonka avulla voidaan vaikuttaa piirtovälien pituuteen. Samaa kuvaa ei esimerkiksi kannata piirtää käyttäjälle tuhatta kertaa sekunnissa, mutta toisaalta nopeasti liikkuvan kuvan päivittäminen käyttäjälle esimerkiksi kerran sekunnissa ei sekään ole toivottua.
</p>

<p>
  Alla olevassa esimerkissä on ohjelma, jossa piirretään satunnaiseen kohtaan piste kymmenen kertaa sekunnissa.
</p>

<% partial 'partials/code_highlight' do %>
  // pakkaus..

  import java.util.Random;
  import javafx.animation.AnimationTimer;
  import javafx.application.Application;
  import javafx.scene.Scene;
  import javafx.scene.canvas.Canvas;
  import javafx.scene.canvas.GraphicsContext;
  import javafx.scene.layout.BorderPane;
  import javafx.scene.paint.Color;
  import javafx.stage.Stage;

  public class AnimaationAlku extends Application {

      @Override
      public void start(Stage ikkuna) {

          Canvas piirtoalusta = new Canvas(320, 240);
          GraphicsContext piirturi = piirtoalusta.getGraphicsContext2D();
          piirturi.setFill(Color.BLACK);

          BorderPane asettelu = new BorderPane();
          asettelu.setCenter(piirtoalusta);

          Random arpoja = new Random();

          new AnimationTimer() {
              long edellinen = 0;

              @Override
              public void handle(long nykyhetki) {
                  if (nykyhetki - edellinen < 100000000) {
                      return;
                  }

                  int x = arpoja.nextInt(310);
                  int y = arpoja.nextInt(230);

                  piirturi.fillOval(x, y, 10, 10);

                  this.edellinen = nykyhetki;
              }
          }.start();

          Scene nakyma = new Scene(asettelu);

          ikkuna.setScene(nakyma);
          ikkuna.show();
      }

      public static void main(String[] args) {
          launch(AnimaationAlku.class);
      }
  }
<% end %>

<p>
  Ohjelma toimii käynnistyessään seuraavasti. Huomaathan, että pisteet ovat satunnaisia, joten oma kokeilusi tuskin tuottaa täsmälleen samanlaista tulosta.
</p>

<img src="/img/material/gui-animaatio.gif" alt="Edellinen ohjelma toiminnassa. Kuvaan ilmestyy kymmenen pistettä sekunnissa."/>

<p>&nbsp;</p>

<p>
  Silloin tällöin ohjelma halutaan toteuttaa siten, että uusi tila piirretään aina edellisen tilanteen päälle. Tällöin tapana on tyhjentää ruutu ennen uutta piirtämistä. Tämä onnistuu lisäämällä edelliseen ohjelmaan rivi <code>piirturi.clearRect(0, 0, 320, 240);</code> ennen handle-metodissa olevaa piirtokomentoa. Komento tyhjentää kohdasta (0, 0) lähtien 320 pikseliä leveän ja 240 pikseliä korkean suunnikkaan.
</p>




<% partial 'partials/exercise', locals: { name: 'Hiekkaranta (5 osaa)' } do %>

  <p>
    Tässä tehtävässä luodaan <a href="https://en.wikipedia.org/wiki/Falling-sand_game" target="_blank" rel="noopener">falling sand game</a>-tyyppinen sovellus, jota käytetään erilaisten aineiden simulointiin. Ohjelmassamme simuloidaan hiekan ja veden käyttäytymistä. Lopullisen sovelluksen toiminta on seuraavanlainen.
  </p>

  <img src="/img/material/gui-simulaatio.gif" alt="Esimerkki hiekkaranta-simulaation toiminnasta." />

  <p>
    &nbsp;
  </p>

  <p>
    Huom! Kun toteutat simulaatiota, varmista että ohjelma pitää tarpeeksi pitkiä taukoja piirtämisten ja simulaatioiden välillä. Tällöin tehoja jää myös testien ajamiseen. Testien suorittaminen palvelimella päätyy heikosti, jos kaikki palvelimen teho menee animaation suorittamiseen. Tällöin testien ajon viestinä on esim. kryptinen "Missing test output.". Jos saat tämän virheen palvelimelta, kokeile suoritusta esimerkiksi siten, että simulaatiota piirretään korkeintaan 10 kertaa sekunnissa ja päivitetään korkeintaan 20 kertaa sekunnissa.
  </p>

  <p>
    Huom2! Kun piirrät pohjaa, piirrä musta alue yhtenä isona suorakulmiona piirtämisen alussa. Näin jokaista yksittäistä tyhjää (eli mustaa)  pistettä ei tarvitse erikseen piirtää, ja voit keskittyä muiden pisteiden piirtämiseen.
  </p>

  <p>
    <em>
      Tehtävässä käytetään <code>enum</code>-tyyppistä luokkaa <code>Tyyppi</code>. Javassa ohjelmoija voi määritellä rajatulle määrälle käsitteitä <code>enum</code>-tyyppisen luokan, jossa näille käsitteille annetaan nimi. Luokka on seuraavanlainen.
    </em>
  </p>

  <% partial 'partials/code_highlight' do %>
    package hiekkaranta;

    public enum Tyyppi {
        TYHJA, METALLI, HIEKKA, VESI;
    }

  <% end %>

  <p>
    Enum-muuttujia käytetään esimerkiksi seuraavasti.
  </p>

  <% partial 'partials/code_highlight' do %>
    Tyyppi t = Tyyppi.TYHJA;
    if (t == Tyyppi.TYHJA) {
        System.out.println("Tyhjää täynnä.");
    }

    if (t == Tyyppi.HIEKKA) {
        System.out.println("Hiekalta näyttää.");
    }

    Tyyppi[] taulukko = new Tyyppi[10];
    taulukko[0] = Tyyppi.VESI;
    System.out.println(taulukko.length);
  <% end %>


  <h2>Palaset kohdalleen</h2>

  <p>
    Luo tehtäväpohjassa olevaan luokkaan graafinen käyttöliittymä. Graafisen käyttöliittymän komponenttien asettelu tulee tehdä BorderPane-luokan avulla. Lisää BorderPane-luokan keskelle Canvas-olio, jota käytetään piirtämiseen. Aseta Canvas-olion leveydeksi ja korkeudeksi 200 pikseliä. Lisää BorderPane-luokan oikealle laidalle VBox-olio, joka sisältää kolme <a href="https://docs.oracle.com/javase/8/javafx/api/javafx/scene/control/RadioButton.html" target="_blank" rel="noopener">RadioButton</a>-oliota. Ensimmäiseen RadioButton-olioon tulee liittyä teksti "Metalli", toiseen teksti "Hiekka", ja kolmanteen teksti "Vesi".
  </p>

  <h2>Simulaation alkupalat</h2>

  <p>
    Luo pakkaukseen hiekkaranta luokka Simulaatio. Luokalla Simulaatio tulee olla seuraavat konstruktorit ja metodit. Käytä luokassa hyödyksi valmista enum-luokkaa Tyyppi, ja toteuta simulaation sisäinen tiedon esitys kaksiulotteisena taulukkona <code>Tyyppi[][]</code>.
  </p>

  <ul>
    <li>
      Konstruktori <code>public Simulaatio(int leveys, int korkeus)</code> luo annetun levyisen ja korkuisen simulaation. Jokaisen kohdan arvon tulee olla aluksi <code>Tyyppi.TYHJA</code>.
    </li>
    <li>
      Metodi <code>public void lisaa(int x, int y, Tyyppi tyyppi</code> asettaa annettuun kohtaan annetun tyyppisen elementin. Tyyppi on joko <code>Tyyppi.TYHJA</code>, <code>Tyyppi.METALLI</code>, <code>Tyyppi.HIEKKA</code> tai <code>Tyyppi.VESI</code>. 
    </li>
    <li>
      Metodi <code>public Tyyppi sisalto(int x, int y)</code> palauttaa annetussa kohdassa olevan sisällön. Vastaus on joko Tyyppi.TYHJA, Tyyppi.METALLI, Tyyppi.HIEKKA tai Tyyppi.VESI. Jos kohtaan ei ole lisätty mitään arvoa, tyyppi on Tyyppi.TYHJA. Jos käyttäjä kysyy tietoa alueen ulkopuolelta, palauta Tyyppi.METALLI.
    </li>
    <li>
      Metodi <code>public void paivita()</code> päivittää simulaatiota yhden askeleen. Päivitystoiminnallisuuden toteutus aloitetaan tehtävän myöhemmissä osassa.
    </li>
  </ul>


  <h2>Metallin lisääminen ja piirtäminen</h2>

  <p>
    Lisää edellä toteuttamasi Simulaatio osaksi käyttöliittymää. Aseta simulaation leveydeksi 200 ja korkeudeksi 200 pikseliä (simulaation tulee toki toimia myös muun kokoisena). Lisää tämän jälkeen sovellukseen mahdollisuus metallin lisäämiseen. Metallia lisätään kun kun metalli on valittuna oikealla laidalla olevasta valikosta ja käyttäjä piirtää kuvaan (eli painaa hiiren napin pohjaan ja liikuttaa hiirtä sovelluksen päällä).
  </p>

  <p>
    Käytä simulaation käyttäjälle näyttämiseen AnimationTimer-luokkaa sekä Canvas-oliota. Piirrä canvas-olion sisältö uudestaan kymmenen kertaa sekunnissa. Käytä tyhjälle elementille mustaa väriä värillä (<code>Color.BLACK</code>) ja metallille valkoisella värillä (<code>Color.WHITE</code>).
  </p>

  <p>
    Kun metallin lisääminen onnistuu, ohjelma toimii seuraavalla tavalla. Alla olevassa esimerkissä hiiren pohjassapito lisää useampia metallipisteitä samaan aikaan -- yhden pisteen lisääminen on myös toki ok.
  </p>


  <img src="/img/material/gui-simulaatio-metalli.gif" alt="Esimerkki hiekkaranta-simulaation toiminnasta." />

  <p>
    &nbsp;
  </p>


  <h2>Hiekan lisääminen ja toiminnallisuus</h2>

  <p>
    Lisää tämän jälkeen toiminnallisuus hiekan lisäämiseen ja piirtämiseen. Hiekka tulee piirtää oranssilla värillä <code>Color.ORANGE</code>.
  </p>

  <p>
    Kun hiekan lisääminen käyttöliittymässä onnistuu, muokkaa tämän jälkeen Simulaatio-luokan metodia paivita. Metodin paivita tulee toimia siten, että se tarkistaa jokaiselle hiekkaa sisältävälle kohdalle kohdan alla olevat kolme vaihtoehtoa (lounas, etelä, kaakko). Jos joku vaihtoehdoista on tyhjä, hiekka siirretään alaspäin tyhjään kohtaan. Mikäli useampi kuin yksi em vaihtoehdoista on tyhjiä, tee valinta satunnaisesti tyhjien vaihtoehtojen välillä.
  </p>

  <p>
    Satunnaisuutta saat Random-luokan avulla.
  </p>

  <p>
    Huom! Toteuta simulaatio siten, että y-koordinaatti on "käänteinen". Simulaation sisällä y-koordinaatin kasvatus tarkoittaa alaspäin menoa, ja toisaalta y-koordinaatin pienennys ylöspäin menoa. Tämä auttaa piirtämisessä, sillä piirtäessä y-koordinaatti kasvaa alaspäin mennessä.
  </p>

  <img src="/img/material/gui-simulaatio-metalli-ja-hiekka.gif" alt="Esimerkki hiekkaranta-simulaation toiminnasta. Kuvassa hiekka toimii metallin kanssa." />
  
  <p>
    &nbsp;
  </p>

  

  <h2>Veden lisääminen</h2>

  <p>
    Lisää tämän jälkeen toiminnallisuus veden lisäämiseen ja piirtämiseen. Piirrä vesi käyttäen väriä <code>Color.LIGHTBLUE</code>.
  </p>

  <p>
    Muokkaa tämän jälkeen Simulaatio-luokan metodia paivita siten, että se siirtää kutsun yhteydessä vettä alaspäin <em>jos</em> joku veden alapuolella olevista kohdista (lounas, etelä, kaakko) on tyhjä. Jos yksikään kohdista ei ole tyhjiä, mutta jommalla kummalla laidalla on sijaa, siirretään vettä sivulle.
  </p>

  <p>
    Muokkaa vielä sovellusta siten, että hiekka syrjäyttää veden. Kun lisäät hiekkaa, veden tulee siis väistää hiekkaa. Nyt sovelluksen pitäisi toimia kokonaisuudessaan!
  </p>

  <p>
    
  </p>
  
  <img src="/img/material/gui-simulaatio.gif" alt="Esimerkki hiekkaranta-simulaation toiminnasta." />

  <p>
    &nbsp;
  </p>

  <p>
    Kun olet palauttanut tehtävän, jatka seuraaviin tehtäviin. Kun olet saanut osan kaikki tehtävät valmiiksi, voit palauta tähän tehtävään ja lähteä toteuttamaan uusia toiminnallisuuksia. Miten toteuttaisit esimerkiksi laavan?
  </p>


<% end %>





<% partial 'partials/material_sub_heading' do %>
  Kuvat
<% end %>

<p>
  Kuvan näyttämiseen osana sovellusta on useita tapoja. Eräs suoraviivainen lähestymistapa hyödyntää JavaFx:n <a href="https://docs.oracle.com/javafx/2/api/javafx/scene/image/Image.html" target="_blank">Image</a> ja <a href="https://docs.oracle.com/javase/8/javafx/api/javafx/scene/image/ImageView.html" target="_blank">ImageView</a> luokkia.
</p>

<p>
  Image-luokalle annetaan parametrina avattavan kuvatiedoston nimi -- nimeä tulee edeltää etuliite <code>file:</code>, joka kertoo kuvan olevan tiedosto. Alla olevassa esimerkissä ladataan tiedosto <code>humming.jpg</code>, joka annetaan luotavalle ImageView-oliolle parametrina. Tämän jälkeen ImageView-olio asetetaan Pane-asetteluun -- Pane-asettelu ei ota mm. kantaa sen sisältävien elementtien sijaintiin. Lopulta asettelu asetetaan osaksi Scene-oliota ja se asetetaan näkyville.
</p>

<% partial 'partials/code_highlight' do %>
  import javafx.application.Application;
  import static javafx.application.Application.launch;
  import javafx.scene.Scene;
  import javafx.scene.image.Image;
  import javafx.scene.image.ImageView;
  import javafx.scene.layout.Pane;
  import javafx.stage.Stage;

  public class KuvaApplication extends Application {

      @Override
      public void start(Stage stage) {

          Image kuvatiedosto = new Image("file:humming.jpg");
          ImageView kuva = new ImageView(kuvatiedosto);

          Pane ruutu = new Pane();
          ruutu.getChildren().add(kuva);

          stage.setScene(new Scene(ruutu));
          stage.show();

      }

      public static void main(String[] args) {
          launch(args);
      }
  }
<% end %>

<p>
  Ohjelman suorittaminen luo seuraavanlaisen ikkunan. Tässä oletetaan, että tiedosto <code>humming.jpg</code> on olemassa, ja että se löytyy projektin juuresta (samasta kansiosta kuin tiedosto <code>pom.xml</code>).
</p>

<img src="/img/material/image-ja-imageview.png" />

<p>&nbsp;</p>

<p>
  Esimerkissä käytetään <a href="https://www.flickr.com/photos/15323831@N05" target="_blank">Linda Tanner</a>in kuvaa osoitteesta <a href="http://www.freestockphotos.biz/stockphoto/17874" target="_blank">http://www.freestockphotos.biz/stockphoto/17874</a>. Kuva on lisensoitu <a href="https://creativecommons.org/licenses/by/2.0/" target="_blank">Creative Commons CC BY 2.0</a>-lisenssillä.
</p>

<p>
  ImageView-olio tarjoaa joukon menetelmiä kuvan (yksinkertaiseen käsittelyyn). Kuvaa voi muunmuassa kääntää, sen kokoa voi muuttaa, ja sitä voi siirtää ruudulla. Alla olevassa esimerkissä kuva on käännetty ympäri, sen koko on puolitettu, ja sitä on siirretty hieman oikealle.
</p>

<% partial 'partials/code_highlight' do %>
  @Override
  public void start(Stage stage) {

      Image kuvatiedosto = new Image("file:humming.jpg");
      ImageView kuva = new ImageView(kuvatiedosto);
  
      kuva.setRotate(180);
      kuva.setScaleX(0.5);
      kuva.setScaleY(0.5);
  
      kuva.setTranslateX(50);

      Pane ruutu = new Pane();
      ruutu.getChildren().add(kuva);

      stage.setScene(new Scene(ruutu));
      stage.show();
  }
<% end %>

<img src="/img/material/humming-kaannetty.png" />

<p>&nbsp;</p>


<p>
  ImageView-luokka tarjoaa pääsyn kuvaan, mutta sen kautta ei pääse yksittäisiin pikseleihin (eli yksittäisiin yhtä väriä sisältäviin pieniin "ruutuihin", joista kuva koostuu). Kuvan yksittäisiä pikseleitä voi lukea Image-oliosta saatavan <a href="https://docs.oracle.com/javafx/2/api/javafx/scene/image/PixelReader.html" target="_blank">PixelReader</a>-olion avulla. PixelReader-olion avulla voidaan käydä koko kuva läpi pikseli pikseliltä, samalla kuvaa erilliseen <a href="https://docs.oracle.com/javafx/2/api/javafx/scene/image/WritableImage.html" target="_blank">WritableImage</a>-olioon kirjoittaen.
</p>

<p>
  Alla olevassa esimerkissä kuva kopioidaan pikseli pikseliltä erilliselle WritableImage-oliolle, joka näytetään sovelluksessa.
</p>

<% partial 'partials/code_highlight' do %>
  @Override
  public void start(Stage stage) {

      Image kuvatiedosto = new Image("file:humming.jpg");

      PixelReader lukija = kuvatiedosto.getPixelReader();

      int leveys = (int) kuvatiedosto.getWidth();
      int korkeus = (int) kuvatiedosto.getHeight();

      WritableImage kohdeKuva = new WritableImage(leveys, korkeus);
      PixelWriter kirjoittaja = kohdeKuva.getPixelWriter();

      for (int y = 0; y &lt; korkeus; y++) {
          for (int x = 0; x &lt; leveys; x++) {

              Color vari = lukija.getColor(x, y);
              double punainen = vari.getRed();
              double vihrea = vari.getGreen();
              double sininen = vari.getBlue();
              double lapinakyvyys = vari.getOpacity();

              Color uusiVari = new Color(punainen, vihrea, sininen, lapinakyvyys);

              kirjoittaja.setColor(x, y, uusiVari);
          }
      }

      ImageView kuva = new ImageView(kohdeKuva);

      Pane pane = new Pane();
      pane.getChildren().add(kuva);

      stage.setScene(new Scene(pane));
      stage.show();
  }
<% end %>

<p>
  Kuvan ulkomuoto ei ole muuttunut lainkaan.
</p>

<img src="/img/material/image-ja-imageview.png" />

<p>&nbsp;</p>

<% partial 'partials/exercise', locals: { name: 'Kollaasi (3 osaa)' } do %>

  <p>
    Andy Warhol tuli tutuksi kuvakollaaseista, joissa yksi tai useampi kuva toistui useampaan otteeseen esimerkiksi eri väreissä.
  </p>

  <p>
    Matkitaan tässä tehtävässä hänen tyyliään ja luodaan Andy Warholmainen versio klassisesta Mona Lisasta. Valmis ohjelma näyttää Mona Lisan seuraavan näköisenä.
  </p>

  <img src="/img/kollaasi-monalisa-neg.png" />

  <p>
    &nbsp;
  </p>

  <p>
    Aloitetaan.
  </p>
  

  <h2>Vasen yläkulma</h2>

  <p>    
    Tehtäväpohjassa on ohjelma, joka lataa ja näyttää Mona Lisan. Tässä tehtävän osassa tavoitteenasi on luoda tilanne, missä Mona Lisa näkyy pienempänä kuvana vasemmassa yläkulmassa. Pienemmän kuvan koon tulee olla neljäsosa alkuperäisestä kuvasta.
  </p>

  <img src="/img/kollaasi-monalisa-kulma.png" />

  <p>
    &nbsp;
  </p>

  <p>
    Käytännössä siis koordinaattiin 0, 0 tulee kopioida koordinaatin 0, 0 arvo. Koordinaattiin 0, 1 koordinaatin 0, 2 arvo. Koordinaattiin 0, 2 koordinaatin 0, 4 arvo. Koordinaattiin 0, 3 koordinaatin 0, 6 arvo jne. Vastaavasti myös y-akselilla, eli esimerkiksi koordinaattiin 1, 1 koordinaatin 2, 2 arvo, ja koordinaattiin 1, 2 koordinaatin 2, 4 arvo. 
  </p>

  
  <h2>Ruudukko</h2>

  <p>
    Muokkaa seuraavaksi ohjelmaa siten, että edellisessä osassa vasempaan yläkulmaan luotu kuva toistuu kuvassa neljään kertaan. Ensimmäisen kuvan vasemman yläkulman tulee olla koordinaatissa 0, 0. Toisen kuvan vasemman yläkulman tulee olla koordinaatissa (kuvan leveys / 2), 0. Kolmannen kuvan vasemman yläkulman tulee olla koordinaatissa 0, (kuvan korkeus / 2). Neljännen kuvan vasemman yläkulman tulee olla koordinaatissa (kuvan leveys / 2), (kuvan korkeus / 2).
  </p>
  
  <img src="/img/kollaasi-monalisa-ruudut.png" />

  <p>
    &nbsp;
  </p>

  
  <h2>Negatiivi</h2>

  <p>
    Kun olet saanut muodostettua ruudukon, muokkaa kuvaa vielä siten, että kuvassa näytetään negatiivi alkuperäisen kuvan sijaan. Negatiivin luominen onnistuu ottamalla jokaisen pikselin värin erotus luvusta yksi, esim. <code>punainen = 1.0 - punainen</code>.
  </p>

  <img src="/img/kollaasi-monalisa-neg.png" />

  <p>
    &nbsp;
  </p>

  <p>
    <em>
      Tehtäväpohjan mukana tuleva Mona Lisa -kuva on noudettu Wikimedian osoitteesta <a href="https://commons.wikimedia.org/wiki/Category:Mona_Lisa" target="_blank">https://commons.wikimedia.org/wiki/Category:Mona_Lisa</a>. Käytetty kuva on vapaasti käytettävissä.
    </em>
  </p>
  
<% end %>


<% partial 'partials/material_sub_heading' do %>
  Äänet
<% end %>

<p>
  Äänitiedostojen käsittelyyn löytyy myös useampia menetelmiä, joista tässä käsitellään yksi tapa. Tapa liittyy äänitiedostojen käsittelyyn äänileikkeinä (audioclip), jotka ovat esimerkiksi ääniefektejä ym.
</p>

<p>
  Esimerkissä käytetään Daniel Simionin <a href="https://creativecommons.org/licenses/by/3.0/" target="_blank">Creative Commons Attribution 3.0</a> -lisenssillä julkaisemaa äänitiedostoa. Äänitiedoston voi kuunnella alla. Äänitiedosto on noudettu osoitteessa <a href="http://soundbible.com/" target="_blank">http://soundbible.com/</a> olevasta palvelusta.
</p>

<audio controls>
  <source src="../img/front-desk-bells-daniel_simon.wav" type="audio/wav"/>
</audio>

<p>
  Oletetaan, että tiedoston nimi on <code>bell.wav</code>, ja että se sijaitsee projektin juuressa. Yksinkertaisimmillaan äänen soittaminen tapahtuu seuraavasti.
</p>

<% partial 'partials/code_highlight' do %>
AudioClip leike = new AudioClip("file:bell.wav");
leike.play();
<% end %>

<p>
  AudioClip-olion toiminta on riippuvainen JavaFx:n kirjastoista, joten äänitiedosto tulee käynnistää osana JavaFx-ohjelmaa. Allaoleva esimerkki etsii projektin juuresta tiedostoa <code>bell.wav</code> ja luo siitä äänileikkeen. Tämän jälkeen äänileike soitetaan, ja sovellukseen liittyvä (tyhjä) ikkuna avataan. 
</p>  

<% partial 'partials/code_highlight' do %>
  import javafx.application.Application;
  import static javafx.application.Application.launch;
  import javafx.scene.media.AudioClip;
  import javafx.stage.Stage;

  public class AudioClipApplication extends Application {

      @Override
      public void start(Stage stage) {

          AudioClip leike = new AudioClip("file:bell.wav");
          leike.play();

          stage.show();
      }

      public static void main(String[] args) {
          launch(args);
      }

  }
<% end %>

<% partial 'partials/exercise', locals: { name: 'Hurraa' } do %>

  <p>
    Tehtäväpohjan juurikansiossa on tiedosto <code>Applause-Yannick_Lemieux.wav</code>, joka sisältää hurrausäänen. Tehtävänäsi on luoda sovellus, missä on "Hurraa"-nappi. Kun käyttäjä painaa nappia, sovelluksen tulee soittaa edellä mainittu äänitiedosto.
  </p>

  <img src="/img/material/hurraa-nappi.png"/>

  <p>&nbsp;</p>

  <p>
    <em>
      Äänitiedosto on Yannick Lemieuxin nauhoittama. Tiedosto on lisensoitu Creative Commonsin Attribuutiolisenssillä (<a href="https://creativecommons.org/licenses/by/3.0/" target="_blank">https://creativecommons.org/licenses/by/3.0/</a>).
    </em>
  </p>
<% end %>



<% partial 'partials/hint', locals: { name: 'Mediasoittimen luominen' } do %>

  <p>
    Osoitteessa <a href="https://examples.javacodegeeks.com/desktop-java/javafx/javafx-media-api/" target="_blank">https://examples.javacodegeeks.com/desktop-java/javafx/javafx-media-api/</a> on opas mediasoittimen luomiseen. Jos äänten soittaminen ja käsittely ohjelmallisesti kiinnostaa, oppaaseen kannattaa tutustua.
  </p>
  
<% end %>



<% partial 'partials/hint', locals: { name: 'Omien JavaFX-sovellusten laatiminen' } do %>

  <p>
    Voit tehdä omia JavaFx-projekteja NetBeansissa valitsemalla File -&gt; New Project. Valitse tämän jälkeen projektilistauksesta JavaFx ja sieltä JavaFx Application. Tämän jälkeen edessäsi on projektien luomiseen käytetty näkymä, missä voit nimetä projektin.
  </p>

<% end %>

<p>
https://github.com/javafx-maven-plugin/javafx-maven-plugin
</p>

- olio-ohjelmoinnin perusteet
- funktionaalinen ohjelmointi

https://medium.freecodecamp.org/object-oriented-programming-concepts-21bb035f7260


<% partial 'partials/material_heading' do %>
  Muutamia yleishyödyllisiä tekniikoita
<% end %>

<p>
  Tutustutaan seuraavaksi muutamaan ohjelmoinnissa varsin näppärään tekniikaan sekä luokkaan.
</p>


<% partial 'partials/material_sub_heading' do %>
  Säännölliset lausekkeet
<% end %>

<p>
  Säännöllinen lauseke määrittelee joukon merkkijonoja tiiviissä muodossa. Säännöllisiä lausekkeita käytetään muunmuassa merkkijonojen oikeellisuuden tarkistamiseen. Merkkijonojen oikeellisuuden tarkastaminen tapahtuu luomalla säännöllinen lauseke, joka määrittelee merkkijonot, jotka ovat oikein.
</p>

<p>
  Tarkastellaan ongelmaa, jossa täytyy tarkistaa, onko käyttäjän antama opiskelijanumero oikeanmuotoinen. Opiskelijanumero alkaa merkkijonolla "01", jota seuraa 7 numeroa väliltä 0&ndash;9.
</p>

<p>
  Opiskelijanumeron oikeellisuuden voisi tarkistaa esimerkiksi käymällä opiskelijanumeroa esittävän merkkijonon läpi merkki merkiltä <code>charAt</code>-metodin avulla. Toinen tapa olisi tarkistaa että ensimmäinen merkki on "0", ja käyttää <code>Integer.parseInt</code> metodikutsua merkkijonon muuntamiseen numeroksi. Tämän jälkeen voisi tarkistaa että <code>Integer.parseInt</code>-metodin palauttama luku on pienempi kuin 20000000.
</p>

<p>
  Oikeellisuuden tarkistus säännöllisten lausekkeiden avulla tapahtuu ensin sopivan säännöllisen lausekkeen määrittelyn. Tämän jälkeen käytetään <code>String</code>-luokan metodia <code>matches</code>, joka tarkistaa vastaako merkkijono parametrina annettua säännöllistä lauseketta. Opiskelijanumeron tapauksessa sopiva säännöllinen lauseke on <code>"01[0-9]{7}"</code>, ja käyttäjän syöttämän opiskelijanumeron tarkistaminen käy seuraavasti:
</p>

<% partial 'partials/code_highlight' do %>
  System.out.print("Anna opiskelijanumero: ");
  String numero = lukija.nextLine();

  if (numero.matches("01[0-9]{7}")) {
      System.out.println("Muoto on oikea.");
  } else {
      System.out.println("Muoto ei ole oikea.");
  }
<% end %>

<p>
  Käydään seuraavaksi läpi eniten käytettyjä säännöllisten lausekkeiden merkintöjä.
</p>


<% partial 'partials/material_sub_sub_heading' do %>
  Vaihtoehtoisuus (pystyviiva)
<% end %>

<p>
  Pystyviiva tarkoittaa, että säännöllisen lausekkeen osat ovat vaihtoehtoisia. Esimerkiksi lauseke <code>00|111|0000</code> määrittelee merkkijonot <code>00</code>, <code>111</code> ja <code>0000</code>. Metodi <code>matches</code> palauttaa arvon <code>true</code> jos merkkijono vastaa jotain määritellyistä vaihtoehdoista.
</p>

<% partial 'partials/code_highlight' do %>
  String merkkijono = "00";

  if (merkkijono.matches("00|111|0000")) {
      System.out.println("Merkkijonosta löytyi joku kolmesta vaihtoehdosta");
  } else {
      System.out.println("Merkkijonosta ei löytynyt yhtäkään vaihtoehdoista");
  }
<% end %>


<% partial 'partials/sample_output' do %>
  Merkkijonosta löytyi joku kolmesta vaihtoehdosta
<% end %>

<p>
  Säännöllinen lauseke <code>00|111|0000</code> vaatii että merkkijono on täsmälleen määritellyn muotoinen: se ei määrittele <em>"contains"</em>-toiminnallisuutta.
</p>

<% partial 'partials/code_highlight' do %>
  String merkkijono = "1111";

  if (merkkijono.matches("00|111|0000")) {
      System.out.println("Merkkijonosta löytyi joku kolmesta vaihtoehdosta");
  } else {
      System.out.println("Merkkijonosta ei löytynyt yhtäkään vaihtoehdoista");
  }
<% end %>

<% partial 'partials/sample_output' do %>
  Merkkijonosta ei löytynyt yhtäkään vaihtoehdoista
<% end %>


<% partial 'partials/material_sub_sub_heading' do %>
  Merkkijonon osaan rajattu vaikutus (sulut)
<% end %>

<p>
  Sulkujen avulla voi määrittää, mihin säännöllisen lausekkeen osaan sulkujen sisällä olevat merkinnät vaikuttavat. Jos haluamme sallia merkkijonot <code>00000</code> ja <code>00001</code>, voimme määritellä ne pystyviivan avulla muodossa <code>00000|00001</code>. Sulkujen avulla voimme rajoittaa vaihtoehtoisuuden vain osaan merkkijonoa. Lauseke <code>0000(0|1)</code> määrittelee merkkijonot <code>00000</code> ja <code>00001</code>.
</p>

<p>
  Vastaavasti säännöllinen lauseke <code>auto(|n|a)</code> määrittelee sanan auto yksikön nominatiivin (auto), genetiivin (auton), partitiivin (autoa) ja akkusatiivin (auto tai auton).
</p>

<% partial 'partials/code_highlight' do %>
  System.out.print("Kirjoita joku sanan auto yksikön taivutusmuoto: ");
  String sana = lukija.nextLine();

  if (sana.matches("auto(|n|a|ssa|sta|on|lla|lta|lle|na|ksi|tta)")) {
      System.out.println("Oikein meni! RRrakastan tätä kieltä!");
  } else {
      System.out.println("Taivutusmuoto ei ole oikea.");
  }
<% end %>


<% partial 'partials/material_sub_sub_heading' do %>
  Toistomerkinnät
<% end %>

<p>
  Usein halutaan, että merkkijonossa toistuu jokin tietty alimerkkijono. Säännöllisissä lausekkeissa on käytössä seuraavat toistomerkinnät:
</p>

<ul>
  <li>Merkintä <strong><code>*</code></strong> toisto 0... kertaa, esim<br/>
    <% partial 'partials/code_highlight' do %>
      String merkkijono = "trolololololo";

      if (merkkijono.matches("trolo(lo)*")) {
          System.out.println("Muoto on oikea.");
      } else {
          System.out.println("Muoto ei ole oikea.");
      }
    <% end %>

    <% partial 'partials/sample_output' do %>
      Muoto on oikea.
    <% end %>
  </li>

  <li>Merkintä <strong><code>+</code></strong> toisto 1... kertaa, esim<br/>
    <% partial 'partials/code_highlight' do %>
      String merkkijono = "trolololololo";

      if (merkkijono.matches("tro(lo)+")) {
          System.out.println("Muoto on oikea.");
      } else {
          System.out.println("Muoto ei ole oikea.");
      }
    <% end %>

    <% partial 'partials/sample_output' do %>
      Muoto on oikea.
    <% end %>

    <% partial 'partials/code_highlight' do %>
      String merkkijono = "nänänänänänänänä Bätmään!";

      if (merkkijono.matches("(nä)+ Bätmään!")) {
          System.out.println("Muoto on oikea.");
      } else {
          System.out.println("Muoto ei ole oikea.");
      }
    <% end %>

    <% partial 'partials/sample_output' do %>
      Muoto on oikea.
    <% end %>
  </li>

  <li>Merkintä <strong><code>?</code></strong> toisto 0 tai 1 kertaa, esim<br/>

    <% partial 'partials/code_highlight' do %>
      String merkkijono = "You have to accidentally the whole meme";

      if (merkkijono.matches("You have to accidentally (delete )?the whole meme")) {
          System.out.println("Muoto on oikea.");
      } else {
          System.out.println("Muoto ei ole oikea.");
      }
    <% end %>

    <% partial 'partials/sample_output' do %>
      Muoto on oikea.
    <% end %>
  </li>

  <li>Merkintä <strong><code>{a}</code></strong> toisto <code>a</code> kertaa, esim<br/>
    <% partial 'partials/code_highlight' do %>
      String merkkijono = "1010";

      if (merkkijono.matches("(10){2}")) {
          System.out.println("Muoto on oikea.");
      } else {
          System.out.println("Muoto ei ole oikea.");
      }
    <% end %>

    <% partial 'partials/sample_output' do %>
      Muoto on oikea.
    <% end %>
  </li>

  <li>Merkintä <strong><code>{a,b}</code></strong> toisto <code>a</code> ... <code>b</code> kertaa, esim<br/>
    <% partial 'partials/code_highlight' do %>
      String merkkijono = "1";

      if (merkkijono.matches("1{2,4}")) {
          System.out.println("Muoto on oikea.");
      } else {
          System.out.println("Muoto ei ole oikea.");
      }
    <% end %>

    <% partial 'partials/sample_output' do %>
      Muoto ei ole oikea.
    <% end %>
  </li>

  <li>Merkintä <strong><code>{a,}</code></strong> toisto <code>a</code> ... kertaa, esim<br/>
    <% partial 'partials/code_highlight' do %>
      String merkkijono = "11111";

      if (merkkijono.matches("1{2,}")) {
          System.out.println("Muoto on oikea.");
      } else {
          System.out.println("Muoto ei ole oikea.");
      }
    <% end %>

    <% partial 'partials/sample_output' do %>
      Muoto on oikea.
    <% end %>
  </li>
</ul>

<p>
  Samassa säännöllisessä lausekkeessa voi käyttää myös useampia toistomerkintöjä. Esimerkiksi säännöllinen lauseke <code>5{3}(1|0)*5{3}</code> määrittelee merkkijonot, jotka alkavat ja loppuvat kolmella vitosella. Välissä saa tulla rajaton määrä ykkösiä ja nollia.
</p>


<% partial 'partials/material_sub_sub_heading' do %>
  Merkkiryhmät (hakasulut)
<% end %>

<p>
  Merkkiryhmän avulla voi määritellä lyhyesti joukon merkkejä. Merkit kirjoitetaan hakasulkujen sisään, ja merkkivälin voi määrittää viivan avulla. Esimerkiksi merkintä <code>[145]</code> tarkoittaa samaa kuin <code>(1|4|5)</code> ja merkintä <code>[2-36-9]</code> tarkoittaa samaa kuin <code>(2|3|6|7|8|9)</code>. Vastaavasti merkintä <code>[a-c]*</code> määrittelee säännöllisen lausekkeen, joka vaatii että merkkijono sisältää vain merkkejä <code>a</code>, <code>b</code> ja <code>c</code>.
</p>


<%= partial 'partials/quiz', locals: { id: '5a02e242fb43ca000414c18f' } %>


<% partial 'partials/exercise', locals: { name: 'Säännölliset lausekkeet (3 osaa)' } do %>

  <p>
    Harjoitellaan hieman säännöllisten lausekkeiden käyttöä. Tehtävissä haetut metodit tehdään luokkaan <code>Tarkistin</code>.
  </p>


  <h2>Viikonpäivä</h2>

  <p>
    Tee säännöllisen lausekkeen avulla metodi <code>public boolean onViikonpaiva(String merkkijono)</code>, joka palauttaa <code>true</code> jos sen parametrina saama merkkijono on viikonpäivän lyhenne (ma, ti, ke, to, pe, la tai su).
  </p>

  <p>
    Esimerkkitulostuksia metodia käyttävästä ohjelmasta:
  </p>

  <% partial 'partials/sample_output' do %>
    Anna merkkijono: <font color="red">ti</font>
    Muoto on oikea.
  <% end %>

  <% partial 'partials/sample_output' do %>
    Anna merkkijono: <font color="red">abc</font>
    Muoto ei ole oikea.
  <% end %>


  <h2>Vokaalitarkistus</h2>

  <p>
    Tee metodi <code>public boolean kaikkiVokaaleja(String merkkijono)</code> joka tarkistaa säännöllisen lausekkeen avulla ovatko parametrina olevan merkkijonon kaikki merkit vokaaleja.
  </p>

  <p>
    Esimerkkitulostuksia metodia käyttävästä ohjelmasta:
  </p>

  <% partial 'partials/sample_output' do %>
    Anna merkkijono: <font color="red">aie</font>
    Muoto on oikea.
  <% end %>

  <% partial 'partials/sample_output' do %>
    Anna merkkijono: <font color="red">ane</font>
    Muoto ei ole oikea.
  <% end %>


  <h2>Kellonaika</h2>

  <p>
    Säännölliset lausekkeet sopivat tietynlaisiin tilanteisiin. Joissain tapaukseesa lausekkeista tulee liian monimutkaisia, ja merkkijonon "sopivuus" kannattaa tarkastaa muulla tyylillä tai voi olla tarkoituksenmukaista käyttää säännöllisiä lausekkeita vain osaan tarkastuksesta.
  </p>

  <p>
    Tee  metodi <code>public boolean kellonaika(String merkkijono)</code>  ohjelma, joka tarkistaa säännöllisen lausekkeen avulla onko parametrina oleva merkkijono muotoa <code>tt:mm:ss</code> oleva kellonaika (tunnit, minuutit ja sekunnit kaksinumeroisina).
  </p>

  <p>
    Esimerkkitulostuksia metodia käyttävästä ohjelmasta:
  </p>

  <% partial 'partials/sample_output' do %>
    Anna merkkijono: <font color="red">17:23:05</font>
    Muoto on oikea.
  <% end %>

  <% partial 'partials/sample_output' do %>
    Anna merkkijono: <font color="red">abc</font>
    Muoto ei ole oikea.
  <% end %>

  <% partial 'partials/sample_output' do %>
    Anna merkkijono: <font color="red">33:33:33</font>
    Muoto ei ole oikea.
  <% end %>

<% end %>

<p>
  Nykyään lähes kaikista ohjelmointikielistä löytyy tuki säännöllisille lausekkeille. Säännöllisten lausekkeiden teoriaa tarkastellaan muunmuassa kurssilla <em>Laskennan mallit</em>. Lisää säännöllisistä lausekkeista löydät esim. googlaamalla hakusanalla <em>regular expressions java</em> -- kannattaa myös lukea Codinghorror-blogin lyhyt artikkeli <a href="https://blog.codinghorror.com/regex-use-vs-regex-abuse/" target="_blank" rel="noopener">Regex use vs. Regex abuse</a>.
</p>


<% partial 'partials/material_sub_heading' do %>
  Lueteltu tyyppi eli Enum
<% end %>

<p>
  Jos tiedämme muuttujien mahdolliset arvot ennalta, voimme käyttää niiden esittämiseen <code>enum</code>-tyyppistä luokkaa eli <em>lueteltua tyyppiä</em>. Luetellut tyypit ovat oma luokkatyyppinsä rajapinnan ja normaalin luokan lisäksi. Lueteltu tyyppi määritellään avainsanalla <code>enum</code>. Esimerkiksi seuraava <code>Maa</code>-enumluokka määrittelee neljä vakioarvoa: <code>RUUTU</code>, <code>PATA</code>, <code>RISTI</code> ja <code>HERTTA</code>.
</p>

<% partial 'partials/code_highlight' do %>
  public enum Maa {
      RUUTU, PATA, RISTI, HERTTA
  }
<% end %>

<p>
  Yksinkertaisimmassa muodossaan <code>enum</code> luettelee pilkulla erotettuina määrittelemänsä vakioarvot. Lueteltujen tyyppien arvot eli vakiot on yleensä tapana kirjoittaa kokonaan isoin kirjaimin.
</p>

<p>
  Enum luodaan (yleensä) omaan tiedostoon, samaan tapaan kuin luokka tai rajapinta. NetBeansissa Enumin saa luotua valitsemalla projektin kohdalla <em>new/other/java/java enum</em>.
</p>

<p>
  Seuraavassa luokka <code>Kortti</code> jossa maa esitetään enumin avulla:
</p>

<% partial 'partials/code_highlight' do %>
  public class Kortti {

      private int arvo;
      private Maa maa;

      public Kortti(int arvo, Maa maa) {
          this.arvo = arvo;
          this.maa = maa;
      }

      @Override
      public String toString() {
          return maa + " " + arvo;
      }

      public Maa getMaa() {
          return maa;
      }

      public int getArvo() {
          return arvo;
      }
  }
<% end %>

<p>
  Korttia käytetään seuraavasti:
</p>

<% partial 'partials/code_highlight' do %>
  Kortti eka = new Kortti(10, Maa.HERTTA);

  System.out.println(eka);

  if (eka.getMaa() == Maa.PATA) {
      System.out.println("on pata");
  } else {
      System.out.println("ei ole pata");
  }
<% end %>

<p>Tulostuu:</p>

<% partial 'partials/sample_output' do %>
  HERTTA 10
  ei ole pata
<% end %>

<p>
  Huomaamme, että enumin tunnukset tulostuvat mukavasti! Koska kortin maat ovat nyt tyyppiä <code>Maa</code> ei ylemmän esimerkin "järjenvastaiset" kummallisuudet, esim. "maan korottaminen toiseen potenssiin" onnistu. Oraclella on <code>enum</code>-tyyppiin liittyvä sivusto osoitteessa <a href="http://docs.oracle.com/javase/tutorial/java/javaOO/enum.html" target="_blank" rel="noopener">http://docs.oracle.com/javase/tutorial/java/javaOO/enum.html</a>.
</p>


<% partial 'partials/hint', locals: { name: 'Enumien vertailu' } do %>

  <p>
    Ylläolevassa esimerkissä kahta enumia verrattiin yhtäsuuruusmerkkien avulla. Miksi tämä on ok?
  </p>

  <p>
    Jokainen lueteltu arvo saa oman uniikin numerotunnuksen, ja niiden vertailu keskenään yhtäsuuruusmerkillä on ok. Kuten muutkin Javan luokat, myös luetellut arvot perivät Object-luokan ja sen equals-metodin. Luetelluilla luokilla myös equals-metodi vertailee tätä numerotunnusta.
  </p>

  <p>
    Luetellun arvon numeraalisen tunnuksen saa selville metodille <code>ordinal()</code>. Metodi palauttaa käytännössä järjestysnumeron -- jos lueteltu arvo on esitelty ensimmäisenä, on sen järjestysnumero 0. Jos toisena, järjestysnumero on 1, jne.
  </p>

  
  <% partial 'partials/code_highlight' do %>
    public enum Maa {
        RUUTU, PATA, RISTI, HERTTA
    }
  <% end %>

  <% partial 'partials/code_highlight' do %>
    System.out.println(Maa.RUUTU.ordinal());
    System.out.println(Maa.HERTTA.ordinal());
  <% end %>

  <% partial 'partials/sample_output' do %>
    0
    3
  <% end %>
  
<% end %>


<% partial 'partials/material_sub_sub_heading' do %>
  Lueteltujen tyyppien oliomuuttujat
<% end %>

<p>
  Luetellut tyypit voivat sisältää oliomuuttujia. Oliomuuttujien arvot tulee asettaa luetellun tyypin määrittelevän luokan sisäisessä eli näkyvyysmääreen <code>private</code> omaavassa konstruktorissa. Enum-tyyppisillä luokilla ei saa olla <code>public</code>-konstruktoria.
</p>

<p>
  Seuraavassa lueteltu tyyppi <code>Vari</code>, joka sisältää vakioarvot PUNAINEN, VIHREA ja SININEN. Vakioille on määritelty <a href="https://www.w3schools.com/colors/colors_picker.asp" target="_blank" rel="noopener">värikoodin</a> kertova oliomuuttuja:
</p>

<% partial 'partials/code_highlight' do %>
  public enum Vari {
      // konstruktorin parametrit määritellään vakioarvoja lueteltaessa
      PUNAINEN("#FF0000"),
      VIHREA("#00FF00"),
      SININEN("#0000FF");

      private String koodi;        // oliomuuttuja

      private Vari(String koodi) { // konstruktori
          this.koodi = koodi;
      }

      public String getKoodi() {
          return this.koodi;
      }
  }
<% end %>

<p>
  Lueteltua tyyppiä <code>Vari</code> voidaan käyttää esimerkiksi seuraavasti:
</p>

<% partial 'partials/code_highlight' do %>
  System.out.println(Vari.VIHREA.getKoodi());
<% end %>

<% partial 'partials/sample_output' do %>
  #00FF00
<% end %>


<% partial 'partials/material_sub_heading' do %>
  Iteraattori
<% end %>

<p>
  Tarkastellaan seuraavaa luokkaa <code>Kasi</code>, joka mallintaa tietyssä korttipelissä pelaajan kädessä olevien korttien joukkoa:
</p>

<% partial 'partials/code_highlight' do %>
  public class Kasi {
      private List&lt;Kortti&gt; kortit;

      public Kasi() {
          this.kortit = new ArrayList&lt;&gt;();
      }

      public void lisaa(Kortti kortti) {
          this.kortit.add(kortti);
      }

      public void tulosta() {
          this.kortit.stream().forEach(kortti -&gt; {
              System.out.println(kortti);
          });
      }
  }
<% end %>

<p>
  Luokan metodi <code>tulosta</code> tulostaa jokaisen kädessä olevan kortin.
</p>

<p>
  ArrayList ja muut <em>Collection</em>-rajapinnan toteuttavat "oliosäiliöt" toteuttavat rajapinnan <em>Iterable</em>, ja ne voidaan käydä läpi myös käyttäen <em>iteraattoria</em>, eli olioa, joka on varta vasten tarkoitettu tietyn oliokokoelman läpikäyntiin. Seuraavassa on iteraattoria käyttävä versio korttien tulostamisesta:
</p>

<% partial 'partials/code_highlight' do %>
  public void tulosta() {
      Iterator&lt;Kortti&gt; iteraattori = kortit.iterator();

      while (iteraattori.hasNext()) {
          System.out.println(iteraattori.next());
      }
  }
<% end %>

<p>
  Iteraattori pyydetään kortteja sisältävältä listalta <code>kortit</code>. Iteraattori on ikäänkuin "sormi", joka osoittaa aina tiettyä listan sisällä olevaa olioa, ensin ensimmäistä ja sitten seuraavaa jne... kunnes "sormen" avulla on käyty jokainen olio läpi.
</p>

<p>
  Iteraattori tarjoaa muutaman metodin. Metodilla <code>hasNext()</code> kysytään onko läpikäytäviä olioita vielä jäljellä. Jos on, voidaan iteraattorilta pyytää seuraavana vuorossa oleva olio metodilla <code>next()</code>. Metodi siis palauttaa seuraavana läpikäyntivuorossa olevan olion ja laittaa iteraattorin eli "sormen" osoittamaan seuraavana vuorossa olevaa läpikäytävää olioa.
</p>

<p>
  Iteraattorin next-metodin palauttama olioviite voidaan ottaa toki talteen myös muuttujaan, eli metodi <code>tulosta</code> voitaisiin muotoilla myös seuraavasti.
</p>

<% partial 'partials/code_highlight' do %>
  public void tulosta(){
      Iterator&lt;Kortti&gt; iteraattori = kortit.iterator();

      while (iteraattori.hasNext()) {
          Kortti seuraavanaVuorossa = iteraattori.next();
          System.out.println(seuraavanaVuorossa);
      }
  }
<% end %>


<p>
  Tarkastellaan seuraavaksi yhtä iteraattorin käyttökohdetta. Motivoidaan käyttökohde ensin ongelmallisella lähestymistavalla. Yritämme tehdä virran avulla metodia, joka poistaa käsiteltävästä virrasta ne kortit, joiden arvo on annettua arvoa pienempi.
</p>

<% partial 'partials/code_highlight' do %>
  public class Kasi {
      // ...

      public void poistaHuonommat(int arvo) {
          this.kortit.stream().forEach(kortti -&gt; {
              if (kortti.getArvo() &lt; arvo) {
                  kortit.remove(kortti);
              }
          });
      }
  }
<% end %>

<p>
  Metodin suoritus aiheuttaa ongelman.
</p>

<% partial 'partials/sample_output' do %>
  Exception in thread "main" java.util.ConcurrentModificationException
  at ...
  Java Result: 1
<% end %>

<p>
  Virheen syynä on se, että listan läpikäynti forEach-metodilla olettaa, ettei listaa muokata läpikäynnin yhteydessä. Listan muokkaaminen (eli tässä tapauksessa alkion poistaminen) aiheuttaa virheen -- voimme ajatella, että komento forEach menee tästä "sekaisin".
</p>

<p>
  Jos listalta halutaan poistaa osa olioista läpikäynnin aikana osa, tulee tämä tehdä iteraattoria käyttäen. Iteraattori-olion metodia <code>remove</code> kutsuttaessa listalta poistetaan siististi se alkio jonka iteraattori palautti edellisellä metodin <code>next</code> kutsulla. Toimiva versio metodista seuraavassa:
</p>

<% partial 'partials/code_highlight' do %>
  public class Kasi {
      // ...

      public void poistaHuonommat(int arvo) {
          Iterator&lt;Kortti&gt; iteraattori = kortit.iterator();

          while (iteraattori.hasNext()) {
              if (iteraattori.next().getArvo() &lt; arvo) {
                  // poistetaan listalta olio jonka edellinen next-metodin kutsu palautti
                  iteraattori.remove();
              }
          }
      }
  }
<% end %>


<% partial 'partials/exercise', locals: { name: 'Enum ja Iteraattori (4 osaa)' } do %>

  <p>
    Tehdään ohjelma pienen yrityksen henkilöstön hallintaan.
  </p>

  <h2>Koulutus</h2>

  <p>
    Tee pakkaukseen <code>henkilosto</code> lueteltu tyyppi eli enum <code>Koulutus</code> jolla on tunnukset <code>FT</code> (tohtori), <code>FM</code> (maisteri), <code>LuK</code> (kandidaatti), <code>FilYO</code> (ylioppilas).
  </p>

  <h2>Henkilo</h2>

  <p>
    Tee pakkaukseen <code>henkilosto</code> luokka Luokka <code>Henkilo</code>. Henkilölle annetaan konstruktorin parametrina annettava nimi ja koulutus. Henkilöllä on myös koulutuksen kertova metodi <code>public Koulutus getKoulutus()</code> sekä alla olevan esimerkin mukaista jälkeä tekevä <code>toString</code>-metodi.
  </p>

  <% partial 'partials/code_highlight' do %>
    Henkilo vilma = new Henkilo("Vilma", Koulutus.FT);
    System.out.println(vilma);
  <% end %>

  <% partial 'partials/sample_output' do %>
    Vilma, FT
  <% end %>


  <h2>Tyontekijat</h2>

  <p>
    Tee pakkaukseen <code>henkilosto</code> luokka Luokka <code>Tyontekijat</code>. Työntekijät-olio sisältää listan Henkilo-olioita. Luokalla on parametriton konstruktori ja seuraavat metodit:
  </p>

  <ul>
    <li><code>public void lisaa(Henkilo lisattava)</code> lisää parametrina olevan henkilön työntekijäksi</li>
    <li><code>public void lisaa(List&lt;Henkilo&gt; lisattavat)</code> lisää parametrina olevan listan henkilöitä työntekijöiksi</li>
    <li><code>public void tulosta()</code> tulostaa kaikki työntekijät</li>
    <li><code>public void tulosta(Koulutus koulutus)</code> tulostaa työntekijät joiden koulutus on sama kuin parametrissa määritelty koulutus</li>
  </ul>

  <p>
    <strong>HUOM:</strong> Luokan <code>Tyontekijat</code> <code>tulosta</code>-metodit on toteutettava iteraattoria käyttäen!
  </p>

  
  <h2>Irtisanominen</h2>

  <p>
    Tee luokalle  <code>Tyontekijat</code> metodi <code>public void irtisano(Koulutus koulutus)</code> joka poistaa Työntekijöiden joukosta kaikki henkilöt joiden koulutus on sama kuin metodin parametrina annettu.
  </p>

  <p>
    <strong>HUOM:</strong> toteuta metodi iteraattoria käyttäen!
  </p>

  <p>
    Seuraavassa esimerkki luokan käytöstä:
  </p>

  <% partial 'partials/code_highlight' do %>
    Tyontekijat yliopisto = new Tyontekijat();
    yliopisto.lisaa(new Henkilo("Petrus", Koulutus.FT));
    yliopisto.lisaa(new Henkilo("Arto", Koulutus.FilYO));
    yliopisto.lisaa(new Henkilo("Elina", Koulutus.FT));

    yliopisto.tulosta();

    yliopisto.irtisano(Koulutus.FilYO);

    System.out.println("==");

    yliopisto.tulosta();
  <% end %>

  <p>
    Tulostuu:
  </p>

  <% partial 'partials/sample_output' do %>
    Petrus, FT
    Arto, FilYO
    Elina, FT
    ==
    Petrus, FT
    Elina, FT
  <% end %>


<% end %>

<% partial 'partials/exercise', locals: { name: 'Kortit ojennukseen (6 osaa)' } do %>

  <p>
    Tehtäväpohjan mukana on luokka, jonka oliot kuvaavat pelikortteja. Kortilla on arvo ja maa. Kortin arvo on esitetään numerona <em>2, 3, ..., 14</em> ja maa <em>Risti, Ruutu, Hertta</em> tai <em>Pata</em>. Ässä on siis arvo 14. Arvo esitetään kokonaislukuna ja maa enum-tyyppisenä oliona. Kortilla on myös metodi toString, jota käyttäen kortin arvo ja maa tulostuvat "ihmisystävällisesti".
  </p>

  <p>
    Korttien luominen tapahtuu seuraavasti. 
  </p>

  <% partial 'partials/code_highlight' do %>
    Kortti eka = new Kortti(2, Maa.RUUTU);
    Kortti toka = new Kortti(14, Maa.PATA);
    Kortti kolmas = new Kortti(12, Maa.HERTTA);

    System.out.println(eka);
    System.out.println(toka);
    System.out.println(kolmas);
  <% end %>

  <p>
    Tulostuu:
  </p>

  <% partial 'partials/sample_output' do %>
    RUUTU 2
    PATA A
    HERTTA Q
  <% end %>

  <p>
    Tee kaikki toteutukset pakkaukseen <code>kortit</code>. 
  </p>
  
  <h2>Kortti-luokasta Comparable</h2>

  <p>
    Tee Kortti-luokasta Comparable. Toteuta <code>compareTo</code>-metodi niin, että korttien järjestys on arvon mukaan nouseva. Jos verrattavien Korttien arvot ovat samat, verrataan niitä maan perusteella nousevassa järjestyksessä: <em>risti ensin, ruutu toiseksi, hertta kolmanneksi, pata viimeiseksi.</em>
  </p>

  <p>
    Maiden järjestämisessä apua löytynee <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Enum.html#ordinal--"  target="_blank" norel>Enum-luokan ordinal-metodista</a>.
  </p>

  <p>
    Järjestyksessä pienin kortti siis olisi risti kakkonen ja suurin pataässä.
  </p>

  
  <h2>Käsi</h2>

  <p>
    Tee seuraavaksi luokka <code>Kasi</code> joka edustaa pelaajan kädessään pitämää korttien joukkoa. Tee kädelle seuraavat metodit:
  </p>

  <ul>
    <li><code>public void lisaa(Kortti kortti)</code> lisää käteen kortin</li>
    <li><code>public void tulosta()</code> tulostaa kädessä olevat kortit alla olevan esimerkin tyylillä</li>
  </ul>

  <% partial 'partials/code_highlight' do %>
    Kasi kasi = new Kasi();

    kasi.lisaa(new Kortti(2, Maa.RUUTU));
    kasi.lisaa(new Kortti(14, Maa.PATA));
    kasi.lisaa(new Kortti(12, Maa.HERTTA));
    kasi.lisaa(new Kortti(2, Maa.PATA));

    kasi.tulosta();
  <% end %>

  <p>
    Tulostuu:
  </p>

  <% partial 'partials/sample_output' do %>
    RUUTU 2
    PATA A
    HERTTA Q
    PATA 2
  <% end %>

  <p>
    Käytä ArrayListiä korttien tallentamiseen.
  </p>


  <h2>Käden järjestäminen</h2>

  <p>
    Tee kädelle metodi <code>public void jarjesta()</code> jota kutsumalla käden sisällä olevat kortit menevät suuruusjärjestykseen. Järjestämisen jälkeen kortit tulostuvat järjestyksessä:
  </p>

  <% partial 'partials/code_highlight' do %>
    Kasi kasi = new Kasi();

    kasi.lisaa(new Kortti(2, Maa.RUUTU));
    kasi.lisaa(new Kortti(14, Maa.PATA));
    kasi.lisaa(new Kortti(12, Maa.HERTTA));
    kasi.lisaa(new Kortti(2, Maa.PATA));

    kasi.jarjesta();

    kasi.tulosta();
  <% end %>

  <p>
    Tulostuu:
  </p>

  <% partial 'partials/sample_output' do %>
    RUUTU 2
    PATA 2
    HERTTA Q
    PATA A
  <% end %>

  
  <h2>Käsien vertailu</h2>

  <p>
    Eräässä korttipelissä kahdesta korttikädestä arvokkaampi on se, jonka sisältämien korttien arvon summa on suurempi. Tee luokasta <code>Kasi</code> vertailtava tämän kriteerin mukaan, eli laita luokka toteuttamaan rajapinta <code>Comparable&lt;Kasi&gt;</code>.
  </p>

  <p>
    Esimerkkiohjelma, jossa vertaillaan käsiä:
  </p>

  <% partial 'partials/code_highlight' do %>
    Kasi kasi1 = new Kasi();

    kasi1.lisaa(new Kortti(2, Maa.RUUTU));
    kasi1.lisaa(new Kortti(14, Maa.PATA));
    kasi1.lisaa(new Kortti(12, Maa.HERTTA));
    kasi1.lisaa(new Kortti(2, Maa.PATA));

    Kasi kasi2 = new Kasi();

    kasi2.lisaa(new Kortti(11, Maa.RUUTU));
    kasi2.lisaa(new Kortti(11, Maa.PATA));
    kasi2.lisaa(new Kortti(11, Maa.HERTTA));

    int vertailu = kasi1.compareTo(kasi2);

    if (vertailu &lt; 0) {
        System.out.println("arvokkaampi käsi sisältää kortit");
        kasi2.tulosta();
    } else if (vertailu &gt; 0){
        System.out.println("arvokkaampi käsi sisältää kortit");
        kasi1.tulosta();
    } else {
        System.out.println("kädet yhtä arvokkaat");
    }
  <% end %>

  <p>Tulostuu</p>

  <% partial 'partials/sample_output' do %>
    arvokkaampi käsi sisältää kortit
    RUUTU J
    PATA J
    HERTTA J
  <% end %>

  
  <h2>Korttien järjestäminen eri kriteerein</h2>

  <p>
    Entä jos haluaisimme välillä järjestää kortit hieman eri tavalla, esim. kaikki saman maan kortit peräkkäin? Luokalla voi olla vain yksi compareTo-metodi, joten joudumme muunlaisia järjestyksiä saadaksemme turvautumaan muihin keinoihin.
  </p>

  <p>
    Vaihtoehtoiset järjestämistavat toteutetaan erillisten vertailun suorittavien luokkien avulla. Korttien vaihtoehtoisten järjestyksen määräävän luokkien tulee toteuttaa <code>Comparator&lt;Kortti&gt;</code>-rajapinta. Järjestyksen määräävän luokan olio vertailee kahta parametrina saamaansa korttia. Metodeja on ainoastaan yksi compare(Kortti k1, Kortti k2), jonka tulee palauttaa negatiivinen arvo, jos kortti k1 on järjestyksessä ennen korttia k2, positiivinen arvo jos k2 on järjestyksessä ennen k1:stä ja 0 muuten.
  </p>

  <p>
    Periaatteena on luoda jokaista järjestämistapaa varten oma vertailuluokka, esim. saman maan kortit vierekkäin vievän järjestyksen määrittelevä luokka:
  </p>

  <% partial 'partials/code_highlight' do %>
    import java.util.Comparator;

    public class SamatMaatVierekkain implements Comparator&lt;Kortti&gt; {
        public int compare(Kortti k1, Kortti k2) {
            return k1.getMaa().ordinal() - k2.getMaa().ordinal();
        }
    }
  <% end %>

  <p>
    Maittainen järjestys on sama kuin kortin metodin <code>compareTo</code> maille määrittelemä järjestys eli <em>ristit ensin, ruudut toiseksi, hertat kolmanneksi, padat viimeiseksi.</em>
  </p>

  <p>
    Järjestäminen tapahtuu edelleen luokan Collections metodin sort avulla. Metodi saa nyt toiseksi parametrikseen järjestyksen määräävän luokan olion:
  </p>
  
  <% partial 'partials/code_highlight' do %>
    ArrayList&lt;Kortti&gt; kortit = new ArrayList&lt;&gt;();

    kortit.add(new Kortti(3, Maa.PATA));
    kortit.add(new Kortti(2, Maa.RUUTU));
    kortit.add(new Kortti(14, Maa.PATA));
    kortit.add(new Kortti(12, Maa.HERTTA));
    kortit.add(new Kortti(2, Maa.PATA));

    SamatMaatVierekkain samatMaatVierekkainJarjestaja = new SamatMaatVierekkain();
    Collections.sort(kortit, samatMaatVierekkainJarjestaja);

    kortit.stream().forEach(k -&gt; System.out.println(k));
  <% end %>

  <p>
    Tulostuu:
  </p>

  <% partial 'partials/sample_output' do %>
    RUUTU 2
    HERTTA Q
    PATA 3
    PATA A
    PATA 2
  <% end %>

  <p>
    Järjestyksen määrittelevä olio voidaan myös luoda suoraan sort-kutsun yhteydessä:
  </p>
  
  <% partial 'partials/code_highlight' do %>
    Collections.sort(kortit, new SamatMaatVierekkain());
  <% end %>

  <p>
    Mikäli luokkaa ei halua toteuttaa, järjestyksen voi antaa <code>Collections</code>-luokan <code>sort</code>-metodille myös lambda-lausekkeena.
  </p>

  <% partial 'partials/code_highlight' do %>
    Collections.sort(kortit, (k1, k2) -&gt; k1.getMaa().ordinal() - k2.getMaa().ordinal());
  <% end %>


  <p>
    Tarkempia ohjeita vertailuluokkien tekemiseen <a href="http://leepoint.net/data/collections/comparators.html">täällä</a>
  </p>

  <p>
    Tee nyt luokka Comparator-rajapinnan toteuttava luokka <code>SamatMaatVierekkainArvojarjestykseen</code> jonka avulla saat kortit muuten samanlaiseen järjestykseen kuin edellisessä esimerkissä paitsi, että saman maan kortit järjestyvät arvon mukaisesti.
  </p>


  <h2>Käden järjestäminen maittain</h2>

  <p>
    Lisää luokalle <code>Kasi</code> metodi <code>public void jarjestaMaittain()</code> jota kutsumalla käden sisällä olevat kortit menevät edellisen tehtävän vertailijan määrittelemään järjestykseen. Järjestämisen jälkeen kortit tulostuvat järjestyksessä:
  </p>

  <% partial 'partials/code_highlight' do %>
    Kasi kasi = new Kasi();

    kasi.lisaa(new Kortti(12, Maa.HERTTA));
    kasi.lisaa(new Kortti(4, Maa.PATA));
    kasi.lisaa(new Kortti(2, Maa.RUUTU));
    kasi.lisaa(new Kortti(14, Maa.PATA));
    kasi.lisaa(new Kortti(7, Maa.HERTTA));
    kasi.lisaa(new Kortti(2, Maa.PATA));

    kasi.jarjestaMaittain();

    kasi.tulosta();
  <% end %>
  
  <p>
    Tulostuu:
  </p>

  <% partial 'partials/sample_output' do %>
    RUUTU 2
    HERTTA 7
    HERTTA Q
    PATA 2
    PATA 4
    PATA A
  <% end %>


<% end %>



<% partial 'partials/material_sub_heading' do %>
  Tiedostoon kirjoittaminen
<% end %>

<p>
  Olemme aiemmin oppineet menetelmiä tekstitiedostojen ja muiden lähteiden lukemiseen. Tarkastellaan seuraavaksi tiedostoon kirjoittamista.
</p>

<p>
  Luokka <code><a href="https://docs.oracle.com/javase/8/docs/api/java/io/PrintWriter.html">PrintWriter</a></code> tarjoaa toiminnallisuuden tiedostoon kirjoittamiseen. Luokan <code>PrintWriter</code> konstruktorille annetaan parametrina kohdetiedoston sijaintia kuvaava merkkijono.
</p>

<% partial 'partials/code_highlight' do %>
  PrintWriter kirjoittaja = new PrintWriter("tiedosto.txt");
  kirjoittaja.println("Hei tiedosto!"); // kirjoittaa tiedostoon merkkijonon "Hei tiedosto!" sekä rivinvaihdon
  kirjoittaja.println("Lisää tekstiä");
  kirjoittaja.print("Ja vielä lisää"); // kirjoittaa tiedostoon merkkijonon "ja vielä lisää" ilman rivinvaihtoa
  kirjoittaja.close(); // sulkee tiedoston ja varmistaa että kirjoitettu teksti menee tiedostoon
<% end %>

<p>
  Esimerkissä kirjoitetaan tiedostoon "tiedosto.txt" merkkijono "Hei tiedosto!", jota seuraa rivinvaihto, ja vielä hieman lisää tekstiä. Huomaa että tiedostoon kirjoitettaessa metodi <code>print</code> ei lisää rivinvaihtoja, vaan ne tulee lisätä itse. Metodi <code>println</code> lisää myös rivinvaihdot.
</p>

<p>
  <code>PrintWriter</code>-luokan konstruktori heittää mahdollisesti poikkeuksen, joka tulee joko käsitellä tai siirtää kutsuvan metodin vastuulle. Metodi, jolle annetaan parametrina kirjoitettavan tiedoston nimi ja kirjoitettava sisältö voisi näyttää seuraavalta.
</p>

<% partial 'partials/code_highlight' do %>
public class Tallentaja {

    public void kirjoitaTiedostoon(String tiedostonNimi, String teksti) throws Exception {
        PrintWriter kirjoittaja = new PrintWriter(tiedostonNimi);
        kirjoittaja.println(teksti);
        kirjoittaja.close();
    }
}
<% end %>

<p>
  Yllä olevassa <code>kirjoitaTiedostoon</code>-metodissa luodaan ensin <code>PrintWriter</code>-olio, joka kirjoittaa parametrina annetussa sijainnissa sijaitsevaan tiedostoon <code>tiedostonNimi</code>. Tämän jälkeen kirjoitetaan tiedostoon <code>println</code>-metodilla. Konstruktorin mahdollisesti heittämä poikkeus tulee käsitellä joko <code>try-catch</code>-lohkolla tai siirtämällä poikkeuksen käsittelyvastuuta eteenpäin. Metodissa <code>kirjoitaTiedostoon</code> käsittelyvastuu on siirretty eteenpäin.
</p>

<p>
  Luodaan <code>main</code>-metodi jossa kutsutaan <code>Tallentaja</code>-olion <code>kirjoitaTiedostoon</code>-metodia. Poikkeusta ei ole pakko käsitellä <code>main</code>-metodissakaan, vaan se voi ilmoittaa heittävänsä mahdollisesti poikkeuksen määrittelyllä <code>throws Exception</code>.
</p>

<% partial 'partials/code_highlight' do %>
public static void main(String[] args) throws Exception {
    Tallentaja tallentaja = new Tallentaja();
    tallentaja.kirjoitaTiedostoon("paivakirja.txt", "Rakas päiväkirja, tänään oli kiva päivä.");
}
<% end %>

<p>
  Yllä olevaa metodia kutsuttaessa luodaan tiedosto "paivakirja.txt" johon kirjoitetaan teksti "Rakas päiväkirja, tänään oli kiva päivä.". Jos tiedosto on jo olemassa, pyyhkiytyy vanhan tiedoston sisältö uutta kirjoittaessa.
</p>

<p>
  Mikäli tiedostoja haluaa käsitellä siten, että kirjoitus tapahtuu olemassaolevan tiedoston perään, kannattaa kirjoituksessa käyttää <a href="https://docs.oracle.com/javase/8/docs/api/java/io/FileWriter.html" target="_blank" norel>FileWriter</a>-luokkaa.
</p>



<% partial 'partials/exercise', locals: { name: 'Muistava sanakirja (4 osaa)' } do %>

  <p>
    Tässä tehtävässä laajennetaan sanakirjaa siten, että sanat voidaan lukea tiedostosta ja kirjoittaa tiedostoon. Sanakirjan tulee myös osata kääntää molempiin suuntiin, suomesta vieraaseen kieleen sekä toiseen suuntaan (tehtävässä oletetaan hieman epärealistisesti, että suomen kielessä ja vieraassa kielessä ei ole yhtään samalla tavalla kirjoitettavaa sanaa). Tehtävänäsi on luoda sanakirja luokkaan <code>MuistavaSanakirja</code>. Toteuta luokka pakkaukseen <code>sanakirja</code>.
  </p>

  <h2>Muistiton perustoiminnallisuus</h2>

  <p>
    Tee sanakirjalle parametriton konstruktori sekä metodit:
  </p>

  <ul>
    <li><code>public void lisaa(String sana, String kaannos)</code></li>lisää sanan sanakirjaan. Jokaisella sanalla on vain yksi käännös ja jos sama sana lisätään uudelleen, ei tapahdu mitään.<br/>

    <li><code>public String kaanna(String sana)</code></li> palauttaa käännöksen annetulle sanalle. Jos sanaa ei tunneta, palautetaan null.<br/>
  </ul>

  <p>
    Sanakirjan tulee tässä vaiheessa toimia seuraavasti:
  </p>

  <% partial 'partials/code_highlight' do %>
    MuistavaSanakirja sanakirja = new MuistavaSanakirja();
    sanakirja.lisaa("apina", "monkey");
    sanakirja.lisaa("banaani", "banana");
    sanakirja.lisaa("apina", "apfe");

    System.out.println(sanakirja.kaanna("apina"));
    System.out.println(sanakirja.kaanna("monkey"));
    System.out.println(sanakirja.kaanna("ohjelmointi"));
    System.out.println(sanakirja.kaanna("banana"));
  <% end %>

  <p>Tulostuu</p>

  <% partial 'partials/sample_output' do %>
    monkey
    apina
    null
    banaani
  <% end %>

  <p>
    Kuten tulostuksesta ilmenee, käännöksen lisäämisen jälkeen sanakirja osaa tehdä käännöksen molempiin suuntiin.
  </p>

  <p>
    <b>Huom:</b> metodit <code>lisaa</code> ja <code>kaanna</code> eivät lue tiedostoa tai kirjoita tiedostoon! Myöskään konstruktori ei koske tiedostoon.
  </p>


  <h2>Sanojen poistaminen</h2>

  <p>
    Lisää sanakirjalle metodi <code>public void poista(String sana)</code></li> joka poistaa annetun sanan ja sen käännöksen sanakirjasta.
  </p>

  <p>
    Kannattanee kerrata aiemmilta viikoilta materiaalia, mikä liittyy olioiden poistamiseen ArrayListista.
  </p>

  <p>
    <b>HUOM2:</b> metodi <code>poista</code> ei kirjoita tiedostoon.
  </p>

  <p>
    Sanakirjan tulee tässä vaiheessa toimia seuraavasti:
  </p>

  <% partial 'partials/code_highlight' do %>
    MuistavaSanakirja sanakirja = new MuistavaSanakirja();
    sanakirja.lisaa("apina", "monkey");
    sanakirja.lisaa("banaani", "banana");
    sanakirja.lisaa("ohjelmointi", "programming");
    sanakirja.poista("apina");
    sanakirja.poista("banana");

    System.out.println(sanakirja.kaanna("apina"));
    System.out.println(sanakirja.kaanna("monkey"));
    System.out.println(sanakirja.kaanna("banana"));
    System.out.println(sanakirja.kaanna("banaani"));
    System.out.println(sanakirja.kaanna("ohjelmointi"));
  <% end %>

  <p>
    Tulostuu
  </p>

  <% partial 'partials/sample_output' do %>
    null
    null
    null
    null
    programming
  <% end %>

  <p>
    Poisto siis toimii myös molemmin puolin, alkuperäisen sanan tai sen käännöksen poistamalla, poistuu sanakirjasta tieto molempien suuntien käännöksestä
  </p>


  <h2>Lataaminen tiedostosta</h2>

  <p>
    Tee sanakirjalle konstruktori <code>public MuistavaSanakirja(String tiedosto)</code>  ja metodi <code>public boolean lataa()</code>, joka lataa sanakirjan konstruktorin parametrina annetun nimisestä tiedostosta. Jos tiedoston avaaminen tai lukeminen ei onnistu, palauttaa metodi false ja muuten true.
  </p>

  <p>
    <b>Huom: </b> parameterillinen konstruktori ainoastaan kertoo sanakirjalle käytetävän tiedoston nimen. Konstruktori ei lue tiedostoa, tiedoston lukeminen tapahtuu <em>ainoastaan</em> metodissa <code>lataa</code>.
  </p>

  <p>
    Sanakirjatiedostossa yksi rivi sisältää sanan ja sen käännöksen merkillä ":" erotettuna. Tehtäväpohjan mukana tuleva testaamiseen tarkoitettu sanakirjatiedosto <code>src/sanat.txt</code> on sisällöltään seuraava:
  </p>

  <% partial 'partials/sample_output' do %>
    apina:monkey
    alla oleva:below
    olut:beer
  <% end %>

  <p>
    Lue sanakirjatiedosto rivi riviltä lukijan metodilla <code>nextLine</code>. Voit pilkkoa rivin String metodilla <code>split</code> seuraavasti:
  </p>

  <% partial 'partials/code_highlight' do %>
    Scanner tiedostonLukija = new ...
    while (tiedostonLukija.hasNextLine()) {
        String rivi = tiedostonLukija.nextLine();
        String[] osat = rivi.split(":");   // pilkotaan rivi :-merkkien kohdalta

        System.out.println(osat[0]);     // ennen :-merkkiä ollut osa rivistä
        System.out.println(osat[1]);     // :-merkin jälkeen ollut osa rivistä
    }
  <% end %>

  <p>
    Sanakirjaa käytetään seuraavasti:
  </p>

  <% partial 'partials/code_highlight' do %>
    MuistavaSanakirja sanakirja = new MuistavaSanakirja("src/sanat.txt");
    boolean onnistui = sanakirja.lataa();

    if (onnistui) {
        System.out.println("sanakirjan lataaminen onnistui");
    }

    System.out.println(sanakirja.kaanna("apina"));
    System.out.println(sanakirja.kaanna("ohjelmointi"));
    System.out.println(sanakirja.kaanna("alla oleva"));
  <% end %>

  <p>Tulostuu</p>

  <% partial 'partials/sample_output' do %>
    sanakirjan lataaminen onnistui
    monkey
    null
    below
  <% end %>


  <h2>Tallennus tiedostoon</h2>

  <p>
    Tee sanakirjalle metodi <code>public boolean tallenna()</code>, jota kutsuttaessa sanakirjan sisältö kirjoitetaan konstruktorin parametrina annetun nimiseen tiedostoon. Jos tallennus ei onnistu, palauttaa metodi false ja muuten true. Sanakirjatiedostot tulee tallentaa ylläesitellyssä muodossa, eli ohjelman on osattava lukea itse kirjoittamiaan tiedostoja.
  </p>

  <p>
    <b>Huom1:</b> mikään muu metodi kuin <code>tallenna</code> ei kirjoita tiedostoon. Jos teit edelliset kohdat oikein, sinun ei tulisi tarvita muuttaa mitään olemassaolevaa koodia.
  </p>

  <p>
    <strong>Huom2:</strong> vaikka sanakirja osaa käännökset molempiin suuntiin, ei sanakirjatiedostoon tule kirjoittaa kuin toinen suunta. Eli jos sanakirja tietää esim. käännöksen <em>tietokone = computer</em>, tulee tallennuksessa olla rivi:
  </p>

  <% partial 'partials/sample_output' do %>
    tietokone:computer
  <% end %>

  <p>tai rivi</p>

  <% partial 'partials/sample_output' do %>
    computer:tietokone
  <% end %>

  <p>mutta ei molempia!</p>

  <p>
    Talletus kannattanee hoitaa siten, että koko käännöslista kirjoitetaan uudelleen vanhan tiedoston päälle, eli materiaalissa esiteltyä <code>append</code>-metodia ei kannata käyttää.
  </p>

  <p>
    Sanakirjan lopullista versiota on tarkoitus käyttää  seuraavasti:
  </p>

  <% partial 'partials/code_highlight' do %>
    MuistavaSanakirja sanakirja = new MuistavaSanakirja("src/sanat.txt");
    sanakirja.lataa();

    // käytä sanakirjaa

    sanakirja.tallenna();
  <% end %>

  <p>
    Eli käytön aluksi ladataan sanakirja tiedostosta ja lopussa tallennetaan se takaisin tiedostoon jotta sanakirjaan tehdyt muutokset pysyvät voimassa seuraavallekin käynnistyskerralle.
  </p>

<% end %>


<% partial 'partials/material_sub_heading' do %>
  Vielä muutamia juttuja testaamisesta
<% end %>

<p>
  Materiaalin aiemmissa osissa käsiteltiin yksikkötestausta: <em>Yksikkötestauksella tarkoitetaan lähdekoodiin kuuluvien yksittäisten osien kuten luokkien ja niiden tarjoamien metodien testaamista. Luokkien ja metodien rakenteen suunnittelussa käytettävän ohjesäännön -- jokaisella metodilla ja luokalla tulee olla yksi selkeä vastuu -- noudattamisen tai siitä poikkeamisen huomaa testejä kirjoittaessa. Mitä useampi vastuu metodilla on, sitä monimutkaisempi testi on. Jos laaja sovellus on kirjoitettu yksittäiseen metodiin, on testien kirjoittaminen sitä varten erittäin haastavaa ellei jopa mahdotonta. Vastaavasti, jos sovellus on pilkottu selkeisiin luokkiin ja metodeihin, on testienkin kirjoittaminen suoraviivaista.</em>
</p>

<p>
  Yksikkötestien hyvyyttä voi miettiä <em>testikattavuuden</em> kannalta. Testikattavuudella tarkoitetaan sitä, kuinka hyvin testit käsittelevät ohjelman eri mahdollisuudet. 
</p>

<p>
  Alla olevassa esimerkissä testikattavuus ei ole kovin hyvä. Metodissa on kaksi vaihtoehtoista suorituspolkua, mutta testit tarkastelevat niistä vain toista.
</p>

<% partial 'partials/code_highlight' do %>
  public class Esimerkki {
      public static String testattava(int luku) {
          if (luku &gt; 10) {
              return "alle kymmenen";
          } else {
              return "kymmenen tai yli";
          }
      }
  }
<% end %>


<% partial 'partials/code_highlight' do %>
  public class EsimerkkiTest {

      @Test
      public void testaaAlleKymmenen() {
          assertEquals("alle kymmenen", Esimerkki.testattava(1));
      }
  }
<% end %>

<p>
  Yllä olevassa esimerkissä testin syöte ei myöskään ole ideaali. Mikäli ohjelmassa on ehto, kannattaa testissa tarkastella ehdon toimivuutta satunnaisen testisyötteen sijaan. Testeissä on hyvä tarkastella ns "corner caseja", eli niitä kohtia, joissa toiminnallisuuden pitäisi muuttua. Yllä olevaa metodi kannattaisi siis tarkastella ainakin syötteillä 9 ja 10.
</p>


<% partial 'partials/code_highlight' do %>
  public class EsimerkkiTest {

      @Test
      public void testaaAlleKymmenen() {
          assertEquals("alle kymmenen", Esimerkki.testattava(9));
      }

      @Test
      public void testaaAlleKymmenen() {
          assertEquals("kymmenen tai yli", Esimerkki.testattava(10));
      }
  }
<% end %>

<p>
  Yllä testit ovat kattavat ja käsittelevät oletetut corner caset.
</p>



<% partial 'partials/exercise', locals: { name: 'Testausta' } do %>

  <p>
    Erään alakoulun luokka 4B keräsi viikon ajan pulloja leirikoulun rahoittamista varten. Kirjoita ohjelma, jolla voidaan luoda tilastoja kerätyistä pulloista, sekä ohjelmalle testit. Ohjelma tulee toteuttaa tehtäväpohjan luokan <code>Ohjelma</code> metodiin <code>public static String suorita(Scanner lukija)</code>. Testit tulee toteuttaa tehtäväpohjan luokkaan <code>OhjelmaTest</code>.
  </p>

  <p>
    Ohjelmalle syötetään ensin kunkin oppilaan keräämien pullojen lukumäärät, jotka on erotettu rivinvaihdoilla. Pullojen lukumäärien syöttämisen lopettaminen ilmoitetaan luvulla -1. Kun pullojen lukumäärät on syötetty, ohjelman tulee selvittää pulloja keränneiden oppilaiden lukumäärä, kerättyjen pullojen lukumäärä, sekä keskimääräinen kerättyjen pullojen lukumäärä. Metodin <code>suorita</code> tulee <em>palauttaa</em> merkkijono, joka sisältää ohjelman tulostuksen.
  </p>

  <p>
    Syötteessä saattaa olla negatiivisia lukuja, jotka ovat virhesyötteitä -- näitä ei tule ottaa huomioon.
  </p>

  <p>
    Alla esimerkkejä ohjelman toiminnasta.
  </p>

  <% partial 'partials/code_highlight' do %>
    System.out.println(Ohjelma.suorita(new Scanner("3\n2\n1\n-1\n")));
  <% end %>
  
  <% partial 'partials/sample_output' do %>
    Pulloja: 6
    Oppilaita: 3
    Keskiarvo: 2.0
  <% end %>

  <% partial 'partials/code_highlight' do %>
    System.out.println(Ohjelma.suorita(new Scanner("1\n0\n-55\n-1\n")));
  <% end %>
  
  <% partial 'partials/sample_output' do %>
    Pulloja: 1
    Oppilaita: 2
    Keskiarvo: 0.5
  <% end %>

  <p>
    Mikäli kerättyjä pulloja ei ole lainkaan, ilmoita ettei keskiarvoa voi laskea.
  </p>

  <% partial 'partials/code_highlight' do %>
    System.out.println(Ohjelma.suorita(new Scanner("-55\n-1\n")));
  <% end %>
  
  <% partial 'partials/sample_output' do %>
    Pulloja: 0
    Oppilaita: 0
    Keskiarvoa ei voida laskea
  <% end %>

  <p>
    Huom! Ohjelman toiminnallisuuden lisäksi tehtävässä tulee kirjoittaa ohjelmalle testit. Automaattisia testejä tehtävässä ei ole valmiina, eli palauta ohjelma kun sekä ohjelma että siihen toteuttamasi testit toimivat kattavasti. Otathan huomioon myös ns corner caset.
  </p>
  
<% end %>



<% partial 'partials/material_heading' do %>
  Crowdsorcerer: Arvioi tehtäviä
<% end %>

<p>
  Otetaan hetkeksi askel taaksepäin ja tarkastellaan taas itse tehtyjä tehtäviä. Ohjelmointikurssin yhdennessätoista osassa loimme vapaamuotoisen tehtävän Crowdsorcererin avulla. Nyt on hetki vertaisarviointiin -- arvioimme Crowdsorcereriin lähetettyjä tehtäviä! Anna vertaispalautetta kahdesta jonkun toisen kurssilaisen lähettämästä tehtävästä ja arvioi lopuksi itse tekemääsi tehtävää. Itse tekemäsi tehtävä näkyy vain jos olet tehnyt sen -- jos et tehnyt tehtävää, pääset arvioimaan yhden ylimääräisen tehtävän.
</p>

<% partial 'partials/hint', locals: { name: 'Vertaisarviointi' } do %>

  <p>
    Alla on kolme Crowdsorcereriin tehtyä tehtävää: kaksi jonkun kurssitoverisi lähettämää ja yksi itsearviointia varten. Niiden yhteydessä on muistin virkistykseksi ohjeistus, jonka pohjalta kyseiset tehtävänannot on tehty.
  </p>

  <p>
    Tarkastele jokaisen tehtävän eri osia: tehtävänantoa, tehtäväpohjaa ja malliratkaisua sekä testaukseen käytettäviä syötteitä ja tulosteita. Arvioi niiden selkeyttä, vaikeutta ja sitä, kuinka hyvin ne vastaavat ohjeistukseensa.
  </p>

  <p>
    Voit vaihtaa näkymää tehtäväpohjan ja mallivastauksen välillä painamalla lähdekoodin yläpalkin painikkeita. Palautteenannon avuksi on annettu väittämiä. Voit valita kuinka samaa mieltä niiden kanssa olet painamalla hymiöitä. Annathan myös sanallista palautetta sille varattuun kenttään! Lisää vielä tehtävää mielestäsi kuvaavia tageja ja paina Lähetä.
  </p>

  <p>
    Anna arvio kummallekin vertaispalautetehtävälle ja lopuksi vielä omallesi.
  </p>

  <p>
    Muista olla reilu ja ystävällinen. Hyvä palaute on rehellistä, mutta kannustavaa!
  </p>

  <p>
    Voit halutessasi ladata arvioitavan tehtävän tehtäväpohjan ja malliratkaisun koneellesi, ja testata niiden käyttöä. Molemmat tulevat ZIP-paketeissa, jolloin sinun täytyy purkaa ne, ennen kuin voit avata ne NetBeansissä.
  </p>

<% end %>


<% partial 'partials/general_callout', locals: { name: 'Suunnittele oma tehtävä' } do %>

  <p>
    Keksi ohjelmointitehtävä. Tehtävän aihealuetta ei ole rajattu, eli tehtävä on hyvin vapaa. Saat käyttää tehtävässä listoja, hajautustauluja, taulukoita sekä Scanneria. 
  </p>

  <p>
    <b>Huom!</b> Tässä sinun täytyy todennäköisesti syöttää jokaiselle testitapaukselle useampi syöte. Useamman syötteen saat annettua, kun laitat rivinvaihdon <code>\n</code> jokaisen syötteen väliin.
  </p>

  <p>
    Esimerkiksi jos haluat antaa testisyötteeksi "kissa", "koira", "lopeta", syötä input-kenttään teksti <code>kissa\nkoira\nlopeta</code>.
  </p>

  <p>
    Muista merkitä malliratkaisurivit ohjelmaan -- näin ratkaisu ei tule suoraan käyttäjälle näkyvään tehtävänantoon.
  </p>

<% end %>


<div class='crowdsorcerer-widget' data-assignment='9' peer-review data-exercises='3'></div>




<% partial 'partials/material_heading' do %>
  ArrayList ja Hajautustaulu
<% end %>

<p>
  ArrayList ja Hajautustaulu ovat ohjemoinnissa hyvin yleisesti käytettyjä tietorakenteita. Tarkastellaan tässä niiden todellista toteutusta -- alla rakennetaan askeleittain ensin ArrayListiä imitoiva tietorakenne <code>Lista</code>, jota hyödynnetään sitten tietorakenteen <code>Hajautustaulu</code> tekemisessä.
</p>

<% partial 'partials/material_sub_heading' do %>
  Geneerinen tyyppi
<% end %>


<p>
  Olemme listoihin tutustumisesta lähtien kertoneet erilaisille tietorakenteille niiden sisältämän arvon tyypin. Esimerkiksi String-tyyppisiä olioita sisältävä lista on esitelty muodossa <code>ArrayList&lt;String&gt;</code>. Tässä on kuitenkin ihmetyttänyt se, että miten ihmeessä listat ja muutkin tietorakenteet voivat sisältää erityyppisiä oliota.
</p>

<p>
  Geneerisyys (<em>generics</em>) liittyy olioita säilövien luokkien tapaan säilöä vapaavalintaisen tyyppisiä olioita. Vapaavalintaisuus perustuu luokkien määrittelyssä käytettyyn geneeriseen tyyppiparametriin, jonka avulla voidaan määritellä <em>olion luontivaiheessa</em> valittavia tyyppejä. Luokan geneerisyys määritellään antamalla luokan nimen jälkeen haluttu määrä luokan tyyppiparametreja pienempi kuin ja suurempi kuin -merkkien väliin. Toteutetaan oma geneerinen luokka <code>Lokero</code>, johon voi asettaa yhden minkälaisen tahansa olion.
</p>

<% partial 'partials/code_highlight' do %>
  public class Lokero&lt;T&gt; {
      private T alkio;

      public void asetaArvo(T alkio) {
          this.alkio = alkio;
      }

      public T haeArvo() {
          return alkio;
      }
  }
<% end %>

<p>
  Määrittely <code>public class Lokero&lt;T&gt;</code> kertoo että luokalle <code>Lokero</code> tulee antaa konstruktorissa tyyppiparametri. Konstruktorikutsun jälkeen kaikki olion sisäiset muuttujat tulevat olemaan kutsun yhteydessä annettua tyyppiä. Luodaan merkkijonon tallentava lokero.
</p>

<% partial 'partials/code_highlight' do %>
  Lokero&lt;String&gt; merkkijono = new Lokero&lt;&gt;();
  merkkijono.asetaArvo(":)");

  System.out.println(merkkijono.haeArvo());
<% end %>

<% partial 'partials/sample_output' do %>
  :)
<% end %>

<p>
  Yllä olevalla ohjelmalla merkkijono-nimisen <code>Lokero</code>-olion <em>ajonaikainen</em> toteutus on seuraavanlainen.
</p>

<% partial 'partials/code_highlight' do %>
  public class Lokero&lt;String&gt; {
      private String alkio;

      public void asetaArvo(String alkio) {
          this.alkio = alkio;
      }

      public String haeArvo() {
          return alkio;
      }
  }
<% end %>

<p>
  Tyyppiparametria vaihtamalla voidaan luoda myös muuntyyppisiä olioita tallentavia <code>Lokero</code>-olioita. Esimerkiksi kokonaisluvun saa tallennettua seuraavasti.
</p>

<% partial 'partials/code_highlight' do %>
  Lokero&lt;Integer&gt; luku = new Lokero&lt;&gt;();
  luku.asetaArvo(5);

  System.out.println(luku.haeArvo());<% end %>


<% partial 'partials/sample_output' do %>
  5
<% end %>

<p>
  Yllä olevalla esimerkillä <code>luku</code>-nimisen Lokeron toteutus olisi ajonaikaisesti taas seuraavanlainen.
</p>

<% partial 'partials/code_highlight' do %>
  public class Lokero&lt;Integer&gt; {
      private Integer alkio;

      public void asetaArvo(Integer alkio) {
          this.alkio = alkio;
      }

      public Integer haeArvo() {
          return alkio;
      }
  }
<% end %>

<p>
  Samalla tavalla ohjelmoija voisi toteuttaa esimerkiksi luokan <code>Pari</code>, mihin voi laittaa kaksi halutun tyyppistä oliota.
</p>

<% partial 'partials/code_highlight' do %>
  public class Pari&lt;T, K&gt; {
      private T eka;
      private K toka;

      public void asetaArvot(T eka, K toka) {
          this.eka = eka;
          this.toka = toka;
      }

      public T haeEka() {
          return this.eka;
      }

      public K haeToka() {
          return this.toka;
      }
  }
<% end %>


<p>
  Huomattava osa Javan tietorakenteista mahdollistaa eri tyyppisten muuttujien käytön. Esimerkiksi ArrayList saa yhden tyyppiparametrin, HashMap kaksi.
</p>

<% partial 'partials/code_highlight' do %>
  List&lt;String&gt; merkkijonot = new ArrayList&lt;&gt;();
  Map&lt;String, String&gt; avainArvoParit = new HashMap&lt;&gt;();
<% end %>

<p>
  Jatkossa kun näet esimerkiksi tyypin <code>ArrayList&lt;String&gt;</code> tiedät että sen sisäisessä rakenteessa on käytetty geneeristä tyyppiparametria. Sama periaate löytyy esimerkiksi rajapinnassa Comparable.
</p>


<% partial 'partials/material_sub_heading' do %>
  Listarakenne
<% end %>

<p>
  Tarkastellaan erästä tapaa Javan tarjoaman ArrayList-tietorakenteen toteuttamiseen. Javan ArrayList hyödyntää sisäisesti taulukkoa, mikä on määritelty generisen tyyppiseksi -- tämän takia listalle saa lisätä käytännössä minkä tyyppisiä arvoja tahansa. Lista tarjoaa useita metodeja, joista tämän esimerkin kannalta oleellisia ovat <code>add</code> eli lisääminen, <code>contains</code> eli olemassaolon tarkastaminen, <code>remove</code> eli poistaminen sekä <code>get</code>, eli tietystä indeksistä hakeminen.
</p>

<% partial 'partials/code_highlight' do %>
  ArrayList&lt;String&gt; merkkijonot = new ArrayList&lt;&gt;();
  System.out.println(merkkijonot.contains("Hei!"));
  merkkijonot.add("Hei!");
  System.out.println(merkkijonot.contains("Hei!"));
  merkkijonot.remove("Hei!");
  System.out.println(merkkijonot.contains("Hei!"));
<% end %>

<% partial 'partials/sample_output' do %>
  false
  true
  false
<% end %>

<% partial 'partials/material_sub_sub_heading' do %>
  Listan luominen
<% end %>

<p>
  Luodaan luokka <code>Lista</code>. Listarakenne sisältää geneerisen taulukon -- eli taulukon, jonka alkioiden tyyppi määräytyy ajonaikaisesti tyyppiparametreista. Asetetaan taulukon alkukooksi <code>10</code>.
</p>

<% partial 'partials/code_highlight' do %>
  public class Lista&lt;T&gt; {
      private T[] arvot;

      public Lista() {
          this.arvot = (T[]) new Object[10];
      }
  }
<% end %>

<p>
  Lista kapseloi taulukon. Alkutilanteessa jokainen taulukon indeksi sisältää <code>null</code>-viitteen.
</p>

<% partial 'partials/material_sub_sub_heading' do %>
  Arvojen lisääminen listalle
<% end %>

<p>
  Lisätään luokalle metodi <code>public void lisaa(T arvo)</code>, mikä mahdollistaa arvojen lisäämisen listalle. Luodaan luokalle tätä varten erillinen kokonaislukumuuttuja, joka pitää kirjaa taulukon ensimmäisestä tyhjästä paikasta.
</p>

<% partial 'partials/code_highlight' do %>
  public class Lista&lt;T&gt; {

      private T[] arvot;
      private int arvoja;

      public Lista() {
          this.arvot = (T[]) new Object[10];
          this.arvoja = 0;
      }

      public void lisaa(T arvo) {
          this.arvot[this.arvoja] = arvo;
          this.arvoja++;
      }
  }
<% end %>

<p>
  Nyt arvojen lisääminen listalle onnistuu -- tai, ainakin listan luominen ja metodin kutsuminen onnistuu -- emme vielä voi testata ovatko arvot todellisuudessa listalla.
</p>

<% partial 'partials/code_highlight' do %>
  Lista&lt;String&gt; lista = new Lista&lt;&gt;();
  lista.lisaa("hei");
  lista.lisaa("maailma");
<% end %>

<% partial 'partials/material_sub_sub_heading' do %>
  Arvojen lisääminen listalle, osa 2
<% end %>

<p>
  Edellä kuvatussa <code>lisaa</code>-metodissa on pieni ongelma. Ongelma ilmenee kun seuraava ohjelmakoodi suoritetaan.
</p>

<% partial 'partials/code_highlight' do %>
  Lista&lt;String&gt; lista = new Lista&lt;&gt;();
  for (int i = 0; i &lt; 11; i++) {
      lista.lisaa("hei");
  }
<% end %>

<% partial 'partials/sample_output' do %>
  Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: 10
  at tietorakenteita.Lista.lisaa(Lista.java:14)
  at tietorakenteita.Ohjelma.main(Ohjelma.java:8)
<% end %>

<p>
  Listan koko ei kasva. Eräs ArrayList-luokan oleellisimmista toiminnallisuuksista on se, että sen koko kasvaa aina tarvittaessa -- ohjelmoijan ei siis tarvitse varoa listan täyttymistä.
</p>

<p>
  Lisätään ohjelmaan listan koon kasvattamiseen liittyvä toiminnallisuus. Listan kokoa kasvatetaan aina jos täyteen listaan yritetään lisätä arvo. Kasvattaminen toteutetaan käytännössä siten, että luomme uuden taulukon, mihin vanhan taulukon arvot kopioidaan. Tämän jälkeen vanha taulukko jätetään heitteille, ja uudesta taulukosta tulee olion käyttämä taulukko.
</p>

<p>
  Javan kuudennessa versiossa uuden taulukon koko lasketaan kaavalla <code>vanhakoko * 3 / 2 + 1</code>. Hyödynnetään samaa kaavaa omassa toteutuksessamme. Luodaan kasvattamista varten erillinen metodi <code>kasvata</code>, joka on vain luokan omien metodien käytössä (eli sillä on <code>private</code>-näkyvyys).
</p>

<% partial 'partials/code_highlight' do %>
  private void kasvata() {
      T[] uusi = (T[]) new Object[this.arvot.length * 3 / 2 + 1];
      for (int i = 0; i &lt; this.arvot.length; i++) {
          uusi[i] = this.arvot[i];
      }
  
      this.arvot = uusi;
  }
<% end %>

<p>
  Toteutus luo uuden taulukon, jonka koko on noin 1.5-kertainen vanhaan taulukkoon verrattuna. Tämän jälkeen kaikki vanhan taulukon alkiot kopioidaan uuteen taulukkoon ja lopulta olion <code>arvot</code>-muuttujan -- eli taulukon -- arvoksi asetetaan uusi taulukko.
</p>

<p>
  Muokataan vielä metodia <code>lisaa</code> siten, että taulukon kokoa kasvatetaan tarvittaessa.
</p>

<% partial 'partials/code_highlight' do %>
  public void lisaa(T arvo) {
      if(this.arvoja == this.arvot.length) {
          kasvata();
      }
  
      this.arvot[this.arvoja] = arvo;
      this.arvoja++;
  }
<% end %>

<p>
  Nyt arvoja voi lisätä listalle lähes rajattomasti.
</p>


<% partial 'partials/hint', locals: { name: 'Edellä kuvatun kasvatusmenetelmän tehokkuudesta' } do %>

  <p>
    Edellä kuvattu menetelmä kopioi kasvatuksen yhteydessä jokaisen vanhan taulukon arvon uuteen taulukkoon. Jos taulukossa on esimerkiksi kaksi miljoonaa alkiota, kopiointi käy kaksi miljoonaa alkiota läpi.
  </p>

  <p>
    Menetelmän tehokkuuteen -- ja parannusehdotuksiin -- paneudutaan muunmuassa kursseilla Tietorakenteet sekä Algoritmien suunnittelu ja analyysi.
  </p>

<% end %>


<% partial 'partials/material_sub_sub_heading' do %>
  Arvon olemassaolon tarkastaminen
<% end %>

<p>
  Luodaan listalle seuraavaksi metodi <code>public boolean sisaltaa(T arvo)</code>, minkä avulla voidaan tarkistaa onko alkio listalla. Hyödynnetään tässä tietoa siitä, että jokainen Javan olio -- riippumatta sen tyypistä -- perii Object-luokan (tai on Object-tyyppinen). Tämän takia jokaisella oliolla on metodi <code>public boolean equals(Object object)</code>, jota voidaan käyttää yhtäsuuruuden tarkasteluun.
</p>

<p>
  Luokan <code>Lista</code> muuttuja <code>arvoja</code> sisältää tiedon arvojen tämän hetkisestä lukumäärästä. Voimme siis toteuttaa <code>sisaltaa</code>-metodin siten, että tarkastelemme vain ne listan indeksit, joissa on arvoja.
</p>

<% partial 'partials/code_highlight' do %>
  public boolean sisaltaa(T arvo) {
      for (int i = 0; i &lt; this.arvoja; i++) {
          if (this.arvot[i].equals(arvo)) {
              return true;
          }
      }
  
      return false;
  }
<% end %>

<p>
  Edellä esitetty menetelmä olettaa, että käyttäjä ei lisää listalle <code>null</code>-viitettä. Jos haluamme, että käyttäjä saa lisätä listalle <code>null</code>-viitteen (ja <code>null</code>-viitteen olemassaoloa saa myös hakea), tulee ohjelmaa muokata hieman. Tällöin <code>sisaltaa</code>-metodin eräs mahdollinen toteutus olisi seuraava.
</p>

<% partial 'partials/code_highlight' do %>
  public boolean sisaltaa(T arvo) {
      for (int i = 0; i &lt; this.arvoja; i++) {
          if (arvo == this.arvot[i] || this.arvot[i].equals(arvo)) {
              return true;
          }
      }
  
      return false;
  }
<% end %>

<p>
  <em>Yllä oleva esimerkki ei kuitenkaan toimi. Pohdi miksei ja mieti minkälaisella ratkaisulla saisit <code>null</code>-viitteiden käsittelyn toimimaan.
  </em>
</p>

<p>
  Ohjelmassa on nyt mahdollisuus listalla olevien alkioiden olemassaolon tarkasteluun.
</p>

<% partial 'partials/code_highlight' do %>
  Lista&lt;String&gt; lista = new Lista&lt;&gt;();
  System.out.println(lista.sisaltaa("hei"));
  lista.lisaa("hei");
  System.out.println(lista.sisaltaa("hei"));
<% end %>


<% partial 'partials/sample_output' do %>
  false
  true
<% end %>


<% partial 'partials/material_sub_sub_heading' do %>
  Arvon poistaminen
<% end %>

<p>
  Toteuttamallemme listalle voi nyt lisätä arvoja, jonka lisäksi arvon olemassaolon voi tarkastaa. Toteutetaan vielä arvon poistaminen. Toteutetaan metodi <code>public void poista(T arvo)</code>, joka poistaa listalta <em>yhden</em> <code>arvo</code>-arvoisen alkion.
</p>

<p>
  Yksinkertainen toteutus olisi seuraava.
</p>


<% partial 'partials/code_highlight' do %>
  public void poista(T arvo) {
      for (int i = 0; i &lt; this.arvoja; i++) {
          if (arvo == this.arvot[i] || this.arvot[i].equals(arvo)) {
              this.arvot[i] = null;
              this.arvoja--;
              return true;
          }
      }
  
      return false;
  }
<% end %>

<p>
  Yllä oleva lähestymistapa on kuitenkin ongelmallinen, sillä se jättää listalle "tyhjiä" kohtia -- olettaen, että uudet arvot lisätään aina listan loppuun.
</p>

<p>
  Ongelman voi ratkaista useammalla tavalla, joista yksi on siirtää jokaista poistettua arvoa seuraavaa arvoa vasemmalle. Lisätään tämä toiminnallisuus ohjelmaan.
</p>

<% partial 'partials/code_highlight' do %>
  public void poista(T arvo) {
      boolean loytyi = false;
      for (int i = 0; i &lt; this.arvoja; i++) {
          if (loytyi) {
              this.arvot[i - 1] = this.arvot[i];
          } else if (arvo == this.arvot[i] || this.arvot[i].equals(arvo)) {
              this.arvoja--;
              loytyi = true;
          }
      }
  }
<% end %>

<p>
  Emme ole kovin tyytyväisiä edelliseen ratkaisuun, sillä siinä tehdään monta asiaa samaan aikaan. Metodissa sekä etsitään alkiota että siirretään alkioita. Pilkotaan toiminnallisuus kahteen erilliseen metodiin: <code>private int arvonIndeksi(T arvo)</code>, joka etsii parametrina annetun arvon indeksin, sekä <code>private void siirraVasemmalle(int indeksista)</code>, joka siirtää annetusta indeksistä lähtien alkioita yhden vasemmalle.
</p>

<p>
  Toteutetaan ensin metodi <code>private int arvonIndeksi(T arvo)</code>, joka etsii annetun arvon indeksin. Metodi palauttaa negatiivisen luvun mikäli arvoa ei löydy.
</p>

<% partial 'partials/code_highlight' do %>
  private int arvonIndeksi(T arvo) {
      for (int i = 0; i &lt; this.arvoja; i++) {
          if (arvo == this.arvot[i] || this.arvot[i].equals(arvo)) {
              return i;
          }
      }

      return -1;
  }
<% end %>

<p>
  Toteutetaan tämän jälkeen metodi <code>private void siirraVasemmalle(int indeksistaLahtien)</code>, joka siirtää arvoja annetusta indeksistä lähtien vasemmalle.
</p>

<% partial 'partials/code_highlight' do %>
  private void siirraVasemmalle(int indeksistaLahtien) {
      for (int i = indeksistaLahtien; i &lt; this.arvoja - 1; i++) {
          this.arvot[i] = this.arvot[i + 1];
      }
  }
<% end %>

<p>
  Nyt metodi <code>poista</code> voidaan toteuttaa edellisten avulla hieman selkokielisemmäksi.
</p>

<% partial 'partials/code_highlight' do %>
  public void poista(T arvo) {
      int arvonIndeksi = arvonIndeksi(arvo);
      if (arvonIndeksi &lt; 0) {
          return; // ei löydy
      }

      siirraVasemmalle(arvonIndeksi);
      this.arvoja--;
  }
<% end %>

<% partial 'partials/hint', locals: { name: 'Edellä kuvatun poistomenetelmän tehokkuudesta' } do %>

  <p>
    Edellä kuvattu menetelmä kopioi poiston yhteydessä jokaisen poistettua alkiota seuraavan alkion vasemmalle. Pohdi toteutuksen tehokkuutta tilanteessa, missä listaa käytetään jonona.
  </p>

  <p>
    Tämänkin menetelmän tehokkuuteen -- ja parannusehdotuksiin -- paneudutaan muunmuassa kursseilla Tietorakenteet sekä Algoritmien suunnittelu ja analyysi.
  </p>

<% end %>

<p>
  Luokassa lista on vieläkin vähän toistoa. Metodi <code>sisaltaa</code> on hyvin samankaltainen metodin <code>arvonIndeksi</code> kanssa. Muokataan vielä metodia <code>sisaltaa</code> siten, että se toteutetaan metodin <code>arvonIndeksi</code> avulla.
</p>

<% partial 'partials/code_highlight' do %>
  public boolean sisaltaa(T arvo) {
      return arvonIndeksi(arvo) &gt;= 0;
  }
<% end %>

<p>
  Nyt käytössämme on lista, joka tarjoaa metodit <code>lisaa</code>, <code>sisaltaa</code>, ja <code>poista</code>. Lista myös kasvaa tarvittaessa. Listan toteutusta voisi toki vielä kehittää esimerkiksi lisäämällä toiminnallisuuden, mikä pienentää listan kokoa jos arvojen määrä pienenee hyvin pieneksi.
</p>

<% partial 'partials/code_highlight' do %>
  Lista&lt;String&gt; lista = new Lista&lt;&gt;();
  System.out.println(lista.sisaltaa("hei"));
  lista.lisaa("hei");
  System.out.println(lista.sisaltaa("hei"));
  lista.poista("hei");
  System.out.println(lista.sisaltaa("hei"));
<% end %>

<% partial 'partials/sample_output' do %>
  false
  true
  false
<% end %>


<% partial 'partials/material_sub_sub_heading' do %>
  Kohdasta hakeminen
<% end %>

<p>
  Lisätään listalle vielä metodi <code>public T arvo(int indeksi)</code>, joka palauttaa listan tietyssä indeksissä sijaitsevan arvon. Mikäli ohjelmoija hakee arvoa listan ulkopuolelta, heitetään virhe <code>IndexOutOfBoundsException</code>. 
</p>

<% partial 'partials/code_highlight' do %>
  public T arvo(int indeksi) {
      if (indeksi &lt; 0 || indeksi &gt;= this.arvoja) {
          throw new ArrayIndexOutOfBoundsException("Indeksi " + indeksi + " alueen [0, " + this.arvoja + "[ ulkopuolella.");
      }

      return this.arvot[indeksi];
  }
<% end %>

<p>
  Metodi ei ole sellaisenaan kovin hyödyllinen, sillä ohjelmoijalla ei ole tietoa arvojen indekseistä. Muutetaan vielä metodi <code>arvonIndeksi(T arvo)</code> kaikkien käytettäväksi, eli vaihdetaan sen näkyvyysmääre <code>private</code> muotoon <code>public</code>.
</p>

<% partial 'partials/code_highlight' do %>
  public int arvonIndeksi(T arvo) {
      for (int i = 0; i &lt; this.arvoja; i++) {
          if (arvo == this.arvot[i] || this.arvot[i].equals(arvo)) {
              return i;
          }
      }

      return -1;
  }
<% end %>


<% partial 'partials/code_highlight' do %>
  Lista&lt;String&gt; lista = new Lista&lt;&gt;();
  System.out.println(lista.sisaltaa("hei"));
  lista.lisaa("hei");
  System.out.println(lista.sisaltaa("hei"));
  int indeksi = lista.arvonIndeksi("hei");
  System.out.println(indeksi);
  System.out.println(lista.arvo(indeksi));
  lista.poista("hei");
  System.out.println(lista.sisaltaa("hei"));
<% end %>

<% partial 'partials/sample_output' do %>
  false
  true
  0
  hei
  false
<% end %>

<% partial 'partials/material_sub_sub_heading' do %>
  Listan koko
<% end %>

<p>
  Lisätään listalle vielä metodi listan koon tarkastamiseen. Listan koon saa selville muuttujasta <code>arvoja</code>. 
</p> 

<% partial 'partials/code_highlight' do %>
  public int koko() {
      return this.arvoja;
  }
<% end %>

<p>
  Nyt listan alkioiden läpikäynti onnistuu mm. for-lauseella.
</p>

<% partial 'partials/code_highlight' do %>
  Lista&lt;String&gt; lista = new Lista&lt;&gt;();
  lista.lisaa("hei");
  lista.lisaa("maailma");

  for(int i = 0; i &lt; lista.koko(); i++) {
      System.out.println(lista.arvo(i)); 
  }
<% end %>

<% partial 'partials/sample_output' do %>
  hei
  maailma
<% end %>


<% partial 'partials/material_sub_heading' do %>
  Hajautustaulu
<% end %>

<p>
  Hajautustaulu on toteutettu taulukkona, missä jokainen alkio sisältää listan. Listalle tallennetaan (avain,arvo)-pareja. Käyttäjä voi hakea hajautustaulusta arvoja avaimen perusteella, ja toisaalta käyttäjä voi lisätä hajautustauluun avain-arvo -pareja. Kukin avain voi esiintyä hajautustaulussa korkeintaan kerran.
</p>

<p>
  Hajautustaulun toiminta perustuu avaimen hajautusarvoon. Kun hajautustauluun lisätään (avain,arvo)-pari, lasketaan avaimeen liittyvä hajautusarvo. Hajautusarvo määrää hajautustaulun sisäisen taulukon indeksin, missä olevaan listaan (avain,arvo)-pari lisätään.
</p>

<p>
  Hahmotellaan hajautustaulun toimintaa.
</p>


<% partial 'partials/material_sub_sub_heading' do %>
  Avain-arvo -pari
<% end %>

<p>
  Luodaan ensin avain-arvo -paria kuvaava luokka <code>Pari</code>. Haluamme tehdä hajautustaulusta mahdollisimman yleiskäyttöisen, joten avaimen ja arvon tyyppi määrätään ajonaikaisesti. Pari sisältää avaimen ja arvon sekä niihin liittyvät get- ja set-metodit.
</p>

<% partial 'partials/code_highlight' do %>
  public class Pari&lt;K, V&gt; {

      private K avain;
      private V arvo;

      public Pari(K avain, V arvo) {
          this.avain = avain;
          this.arvo = arvo;
      }

      public K getAvain() {
          return avain;
      }

      public void setAvain(K avain) {
          this.avain = avain;
      }

      public V getArvo() {
          return arvo;
      }

      public void setArvo(V arvo) {
          this.arvo = arvo;
      }
  }
<% end %>

<p>
  Avain-arvo -parien luominen on suoraviivaista.
</p>

<% partial 'partials/code_highlight' do %>
  Pari&lt;String, Integer&gt; pari = new Pari&lt;&gt;("yksi", 1);
  System.out.println(pari.getAvain() + " -&gt; " + pari.getArvo());
<% end %>


<% partial 'partials/sample_output' do %>
  yksi -&gt; 1
<% end %>


<% partial 'partials/material_sub_sub_heading' do %>
  Hajautustaulun luominen
<% end %>

<p>
  Hajautustaulu sisältää taulukon listoja. Jokainen listan arvo on edellä kuvattu pari, joka sisältää avain-arvo -parin. Hajautustaululla on lisäksi tieto arvojen lukumäärästä.
</p>

<% partial 'partials/code_highlight' do %>
  public class Hajautustaulu&lt;K, V&gt; {

      private Lista&lt;Pari&lt;K, V&gt;&gt;[] arvot;
      private int arvoja;

      public Hajautustaulu() {
          this.arvot = new Lista[32];
          this.arvoja = 0;
      }
  }
<% end %>


<% partial 'partials/material_sub_sub_heading' do %>
  Arvon hakeminen
<% end %>

<p>
  Toteutetaan ensin metodi <code>public V hae(K avain)</code>, jota käytetään arvon hakemiseen avaimen perusteella. Metodissa lasketaan ensin avaimen hajautusarvo ja päätellään sen perusteella hajautustaulun sisäisen taulukon indeksi, mistä arvoja haetaan. Mikäli kyseisessä indeksissä ei ole listaa, ei indeksiin ole lisätty vielä yhtäkään avain-arvo -paria, eikä avaimelle ole tallennettu arvoa. Tällöin palautetaan null. Muussa tapauksessa taulukon indeksissä oleva lista käydään läpi, ja avaimen yhtäsuuruutta vertaillaan jokaiseen listan avain-arvo -parin avaimeen. Mikäli joku listalla olevista avaimista vastaa avainta, jonka perusteella arvoa haetaan, palautetaan kyseinen arvo. Muulloin avainta (ja siihen liittyvää arvoa) ei löydy, ja palautetaan arvo null.
</p>

<% partial 'partials/code_highlight' do %>
  public V hae(K avain) {
      int hajautusArvo = Math.abs(avain.hashCode() % this.arvot.length);
      if (this.arvot[hajautusArvo] == null) {
          return null;
      }
  
      Lista&lt;Pari&lt;K, V&gt;&gt; arvotIndeksissa = this.arvot[hajautusArvo];

      for (int i = 0; i &lt; arvotIndeksissa.koko(); i++) {
          if (arvotIndeksissa.arvo(i).getAvain().equals(avain)) {
              return arvotIndeksissa.arvo(i).getArvo();
          }
      }
  
      return null;
  }
<% end %>


<% partial 'partials/hint', locals: { name: 'Miksei hajautustaulua toteuteta listana?' } do %>

  <p>
    Hajautustaulun toimintaperiaate perustuu siihen, että avain-arvo -parit jaetaan hajautusarvon perusteella pieniin joukkoihin. Tällöin avaimen perusteella haettaessa käydään läpi vain hyvin pieni joukko avain-arvo -pareja -- olettaen toki, että hajautusarvo on järkevä.
  </p>

  <p>
    Jos hajautusarvo on aina sama -- esimerkiksi 1 -- vastaa hajautustaulun sisäinen toteutus listaa -- kaikki arvot ovat samalla listalla. Jos taas hajautusarvo on hyvin satunnainen, arvot hajautetaan mahdollisimman tasaisesti taulukon eri listoille.
  </p>

  <p>
    Hajautustaulu toimii lisäksi siten, että hajautustaulun käyttämää taulukkoa kasvatetaan mikäli arvojen määrä on tarpeeksi iso (tyypillisesti noin 75% taulukon koosta). Tyypillisesti miljoonia avain-arvo -pareja sisältävän hajautustaulun taulukon yhdessä indeksissä on vain muutama avain-arvo -pari. Tämä tarkoittaa käytännössä sitä, että avain-arvo -parin olemassaolon selvittämiseen tarvitaan vain hajautusarvon laskeminen sekä muutaman olion tarkastelu -- tämä on paljon nopeampaa kuin listan läpikäynti.
  </p>
  
<% end %>


<% partial 'partials/material_sub_sub_heading' do %>
  Hajautustauluun lisääminen, osa 1
<% end %>

<p>
  Toteutetaan hajautustauluun lisäämisen käytettävän metodin <code>public void lisaa(K avain, V arvo)</code> ensimmäinen versio. Ensimmäisessä versiossa hajautustaulun sisältämän taulukon kokoa ei kasvateta lisäyksen yhteydessä.
</p>

<p>
  Metodi laskee ensin avaimelle hajautusarvon ja päättelee hajautusarvon perusteella hajautustaulun sisäisen taulukon indeksin. Jos taulukon kyseisessä indeksissä ei ole arvoa, taulukon indeksiin lisätään lista. Tämän jälkeen taulukon indeksissä oleva lista käydään läpi ja sieltä etsitään avain-arvo -paria, jonka avain vastaa lisättävän avain-arvo -parin avainta. Mikäli vastaava avain löytyy, päivitetään olemassaolevan avain-arvo -parin arvo vastaamaan uutta avainta. Muulloin listaan lisätään uusi avain-arvo -pari -- tällöin myös hajautustaulussa olevien arvojen lukumäärää kasvatetaan yhdellä.
</p>

<% partial 'partials/code_highlight' do %>
  public void lisaa(K avain, V arvo) {
      int hajautusArvo = Math.abs(avain.hashCode() % arvot.length);
      if (arvot[hajautusArvo] == null) {
          arvot[hajautusArvo] = new Lista<>();
      }

      Lista&lt;Pari&lt;K, V&gt;&gt; arvotIndeksissa = arvot[hajautusArvo];

      int indeksi = -1;
      for (int i = 0; i &lt; arvotIndeksissa.koko(); i++) {
          if (arvotIndeksissa.arvo(i).getAvain().equals(avain)) {
              indeksi = i;
              break;
          }
      }

      if (indeksi &lt; 0) {
          arvotIndeksissa.lisaa(new Pari&lt;&gt;(avain, arvo));
          this.arvoja++;
      } else {
          arvotIndeksissa.arvo(indeksi).setArvo(arvo);
      }
  }
<% end %>

<p>
  Metodi on melko monimutkainen. Pilkotaan se pienempiin osiin -- ensimmäisen osan vastuulla on avaimeen liittyvän listan hakeminen ja toisen osan vastuulla on avaimen indeksin etsiminen listalta.
</p>

<% partial 'partials/code_highlight' do %>
  private Lista&lt;Pari&lt;K, V&gt;&gt; haeAvaimeenLittyvaLista(K avain) {
      int hajautusArvo = Math.abs(avain.hashCode() % arvot.length);
      if (arvot[hajautusArvo] == null) {
          arvot[hajautusArvo] = new Lista&lt;&gt;();
      }

      return arvot[hajautusArvo];
  }
  
  private int haeAvaimenIndeksi(Lista&lt;Pari&lt;K, V&gt;&gt; lista, K avain) {
      for (int i = 0; i &lt; lista.koko(); i++) {
          if (lista.arvo(i).getAvain().equals(avain)) {
              return i;
          }
      }

      return -1;
  }
<% end %>

<p>
  Nyt metodi <code>public void lisaa(K avain, V arvo)</code> voidaan toteuttaa hieman selkeämmin.
</p>

<% partial 'partials/code_highlight' do %>
  public void lisaa(K avain, V arvo) {
      Lista&lt;Pari&lt;K, V&gt;&gt; arvotIndeksissa = haeAvaimeenLittyvaLista(avain);
      int indeksi = haeAvaimenIndeksi(arvotIndeksissa, avain);
  
      if (indeksi &lt; 0) {
          arvotIndeksissa.lisaa(new Pari&lt;&gt;(avain, arvo));
          this.arvoja++;
      } else {
          arvotIndeksissa.arvo(indeksi).setArvo(arvo);
      }
  }
<% end %>


<% partial 'partials/material_sub_sub_heading' do %>
  Hajautustauluun lisääminen, osa 2
<% end %>

<p>
  Edellä kuvattu hajautustauluun lisääminen toimii osittain. Toiminnallisuuden suurin puute on se, että taulukon kokoa ei kasvateta kun arvojen määrä kasvaa liian suureksi. Lisätään ohjelmaan kasvatustoiminnallisuus, mikä tuplaa hajautustaulun sisäisen taulukon koon. Kasvatustoiminnallisuuden tulee myös sijoittaa jokainen hajautustaulussa olevan taulukon arvo uuteen taulukkoon.
</p>

<p>
  Hahmotellaan kasvatustoiminnallisuuden alku. Kasvatustoiminnallisuudessa luodaan uusi taulukko, jonka koko on edelliseen verrattuna kaksinkertainen. Tämän jälkeen alkuperäinen taulukko käydään indeksi indeksiltä läpi ja olemassaolevat avain-arvo -parit kopioidaan uuteen taulukkoon. Lopulta alkuperäinen taulukko korvataan uudella taulukolla.
</p>

<p>
  Alla on hahmoteltu metodin toimintaa. Kopiointia ei ole vielä toteutettu.
</p>

<% partial 'partials/code_highlight' do %>
  private void kasvata() {
      // luodaan uusi taulukko
      Lista&lt;Pari&lt;K, V&gt;&gt;[] uusi = new Lista[this.arvot.length * 2];

      for (int i = 0; i &lt; this.arvot.length; i++) {
          // kopioidaan vanhan taulukon arvot uuteen

      }

      // korvataan vanha taulukko uudella
      this.arvot = uusi;
  }
<% end %>

<p>
  Hahmotellaan seuraavaksi metodia, joka kopioi alkuperäisen taulukon yhden indeksin sisältämän listan arvot uuteen taulukkoon. Kopioinnin yhteydessä jokaisen kopioitavan avain-arvo -parin sijainti taulukossa lasketaan uudelleen -- tämä tehdään, sillä taustalla olevan taulukon koko kasvaa ja avain-arvot -parit halutaan sijoittaa taulukkoon mahdollisimman tasaisesti.
</p>

<% partial 'partials/code_highlight' do %>
  private void kopioi(Lista&lt;Pari&lt;K, V&gt;&gt;[] uusi, int indeksista) {
      for (int i = 0; i &lt; this.arvot[indeksista].koko(); i++) {
          Pari&lt;K, V&gt; arvo = this.arvot[indeksista].arvo(i);
  
          int hajautusarvo = Math.abs(arvo.getAvain().hashCode() % uusi.length);
          if(uusi[hajautusarvo] == null) {
              uusi[hajautusarvo] = new Lista&lt;&gt;();
          }
  
          uusi[hajautusarvo].lisaa(arvo);
      }
  }
<% end %>

<p>
  Nyt kopioi-metodia voidaan kutsua kasvata-metodista.
</p>


<% partial 'partials/code_highlight' do %>
  private void kasvata() {
      // luodaan uusi taulukko
      Lista&lt;Pari&lt;K, V&gt;&gt;[] uusi = new Lista[this.arvot.length * 2];

      for (int i = 0; i &lt; this.arvot.length; i++) {
          // kopioidaan vanhan taulukon arvot uuteen
          kasvata(uusi, indeksista);
      }

      // korvataan vanha taulukko uudella
      this.arvot = uusi;
  }
<% end %>

<p>
  <em>
    Metodissa on pieni virhe. Selvitä mistä virheessä on kyse ja korjaa se.
  </em>
</p>

<p>
  Lisätään lopuksi kasvatustoiminnallisuus osaksi lisäystoiminnallisuutta. Hajautustaulun kokoa kasvatetaan aina jos hajautustaulussa olevien avain-arvo -parien määrä on yli 75% taulukon koosta.
</p>

<% partial 'partials/code_highlight' do %>
  public void lisaa(K avain, V arvo) {
      Lista&lt;Pari&lt;K, V&gt;&gt; arvotIndeksissa = haeAvaimeenLittyvaLista(avain);
      int indeksi = haeAvaimenIndeksi(arvotIndeksissa, avain);

      if (indeksi &lt; 0) {
          arvotIndeksissa.lisaa(new Pari&lt;&gt;(avain, arvo));
          this.arvoja++;
      } else {
          arvotIndeksissa.arvo(indeksi).setArvo(arvo);
      }

      if (1.0 * this.arvoja / this.arvot.length &gt; 0.75) {
          kasvata();
      }
  }
<% end %>



<% partial 'partials/material_sub_sub_heading' do %>
  Poistaminen
<% end %>

<p>
  Lisätään hajautustauluun vielä toiminnallisuus avain-arvo -parin poistamiseen avaimen perusteella. Poistotoiminnallisuus palauttaa null-arvon mikäli arvoa ei löydy, muuten metodi palauttaa poistettavaan avaimeen liittyvän arvon.
</p>

<p>
  Voimme hyödyntää valmiiksi toteuttamiamme metodeja poistotoiminnallisuudessa. Selitä itsellesi (ääneen) alla olevan metodin konkreettinen toiminta.
</p>


<% partial 'partials/code_highlight' do %>
  public V poista(K avain) {
      Lista&Lt;Pari&lt;K, V&gt;&gt; arvotIndeksissa = haeAvaimeenLittyvaLista(avain);
      if (arvotIndeksissa == null || arvotIndeksissa.koko() == 0) {
          return null;
      }

      int indeksi = haeAvaimenIndeksi(arvotIndeksissa, avain);
      if (indeksi &lt; 0) {
          return null;
      }

      Pari&lt;K, V&gt; pari = arvotIndeksissa.arvo(indeksi);
      arvotIndeksissa.poista(pari);
      return pari.getArvo();
  }
<% end %>


<% partial 'partials/material_sub_heading' do %>
  Hakemisen tehokkuudesta
<% end %>

<p>
  Tarkastellaan vielä hakemisen tehokkuutta listasta ja hajautustaulusta. Tehokkuusmittauksia voi tehdä metodin <code>System.nanotime()</code> palauttaman nanosekunteja kuvaavan arvon avulla. Ohjelma luo ensin miljoona alkiota hajautustauluun ja listaan, jonka jälkeen hajautustaulusta ja listasta etsitään tuhatta satunnaista arvoa. Noin 50% arvoista löytyy listalta ja hajautustaulusta.
</p>

<% partial 'partials/code_highlight' do %>
  Lista&lt;String&gt; lista = new Lista&lt;&gt;();
  Hajautustaulu&lt;String, String&gt; taulu = new Hajautustaulu&lt;&gt;();

  for (int i = 0; i &lt; 1000000; i++) {
      lista.lisaa("" + i);
      taulu.lisaa("" + i, "" + i);
  }

  Lista&lt;String&gt; haettavat = new Lista&lt;&gt;();
  Random arpoja = new Random();
  for (int i = 0; i &lt; 1000; i++) {
      haettavat.lisaa("" + arpoja.nextInt(2000000));
  }

  long listanHakuAloitus = System.nanoTime();
  for (int i = 0; i &lt; haettavat.koko(); i++) {
      lista.sisaltaa(haettavat.arvo(i));            
  }
  long listanHakuLopetus = System.nanoTime();
  
  long hajautustaulunHakuAloitus = System.nanoTime();
  for (int i = 0; i &lt; haettavat.koko(); i++) {
      taulu.hae(haettavat.arvo(i));            
  }
  long hajautustaulunHakuLopetus = System.nanoTime();

  
  long listanHaku = listanHakuLopetus - listanHakuAloitus;
  System.out.println("Lista: haku kesti noin " + listanHaku / 1000000 + " millisekuntia (" +
      listanHaku + " nanosekuntia.)");
  
  long hajautustaulunHaku = hajautustaulunHakuLopetus - hajautustaulunHakuAloitus;
  System.out.println("Hajautustaulu: haku kesti noin " + hajautustaulunHaku / 1000000 +
      " millisekuntia (" + hajautustaulunHaku + " nanosekuntia.)");
<% end %>


<% partial 'partials/code_highlight' do %>
  Lista: haku kesti noin 6284 millisekuntia (6284420580 nanosekuntia.)
  Hajautustaulu: haku kesti noin 0 millisekuntia (805106 nanosekuntia.)
<% end %>

<p>
  <em>
    Edellä kuvatut ja kursseilla käyttämämme listat ja hajautustaulut poikkeavat toki sisäiseltä toteutukselta hieman toisistaan. Ohjelmointikielten tarjoamissa tietorakenteissa on hieman enemmän erilaisia optimointeja -- näihinkin palataan myöhemmillä kursseilla. Tämän kurssin puitteissa riittää em. tietorakenteiden käyttöosaaminen sekä jonkintasoinen ymmärrys niiden tehokkuuseroista sekä käyttötapauksista.
  </em>
</p>

<% partial 'partials/exercise', locals: { name: 'Lista ja hajautustaulu (3 osaa)' } do %>

  <p>
    Toteuta edellistä esimerkkiä noudattaen luokat Lista ja Hajautustaulu pakkaukseen <code>tietorakenteita</code>. Kohdat on pisteytetty askeleittain, jotka ovat seuraavat:
  </p>

  <h2>Lista</h2>
  
  <ol>
    <li>
      Listan luominen
    </li>
    <li>
      Arvojen lisääminen listalle (osat 1 ja 2)
    </li>
    <li>
      Listalla olevan arvon olemassaolon tarkastaminen
    </li>
    <li>
      Listalla olevan arvon poistaminen
    </li>
    <li>
      Listan indeksistä hakeminen ja listan koko
    </li>
  </ol>

  <h2>Hajautustaulu, osa 1</h2>
  
  <ol>
    <li>
      Avain-arvo -paria kuvaavan luokan toteutus
    </li>
    <li>
      Hajautustaulun luominen
    </li>
    <li>
      Arvon hakeminen hajautustaulusta
    </li>
    <li>
      Hajautustauluun lisääminen (ei kasvatusta)
    </li>
  </ol>

  <h2>Hajautustaulu, osa 2</h2>

  <ol>
    <li>
      Hajautustaulun koon kasvattaminen tarvittaessa
    </li>
    <li>
      Hajautustaulusta poistaminen
    </li>
  </ol>
  
  <p>
    Sitä mukaa kun kehität listaa ja hajautustaulua, päivitä luokan Ohjelma metodia <code>osiaToteutettu</code> palauttamaan valmiiksi saamasi osan numero. Voit palauttaa tehtävän vaikket tekisikään kaikkia osia, jolloin saat pisteitä tehtävän niistä osista, jotka olet tehnyt.
  </p>

  <p>
    Esimerkiksi, kun olet saanut listan luomisen, arvojen lisäämisen ja arvon poistamisen toimimaan, olet vaiheessa 3, jolloin metodin <code>osiaToteutettu</code> tulisi palautta arvo <code>3</code>.
  </p>
  
<% end %>


<% partial 'partials/material_heading' do %>
  Loppurutistus
<% end %>

<p>
  Kurssi on melkein ohi. Tehdään lopuksi vielä muutamia laajempia tehtäviä. Lisää tehtäviä löytyy (kohta julkaistavasta) kertausosiosta.
</p>



<% partial 'partials/exercise', locals: { name: 'Tunteikkaat elokuva-arviot (3 osaa)' } do %>

  <p>
    Tässä tehtävässä nivotaan yhteen aiemmin harjoiteltuja hajautustauluja, tiedoston lukemista sekä tehdään pieni askel koneoppimisen suuntaan. Koneoppiminen on tietojenkäsittelytieteen osa-alue, missä tutkitaan ja rakennetaan ohjelmia, jotka voivat oppia muunmuassa niille annetusta datasta.
  </p>

  <p>
    Käytössämme oleva data (kansiossa src oleva tiedosto arviot.txt) sisältää yli 8000 englanninkielistä elokuva-arviota, joihin on valmiiksi lisätty tunnearvio. Tunnearviot on annettu skaalalla nollasta neljään, missä arvot ovat seuraavat:
  </p>

  <ul>
    <li>0 - negatiivinen</li>
    <li>1 - hieman negatiivinen</li>
    <li>2 - neutraali</li>
    <li>3 - hieman positiivinen</li>
    <li>4 - positiivinen</li>
  </ul>

  <p>
    Teemme seuraavaksi ohjelman, joka pyrkii arvioimaan liittyykö tekstimuotoiseen elokuva-arvioon negatiivinen, positiivinen vai neutraali tunne.
  </p>


  <h2>Sanojen lukumäärä</h2>

  <p>
    Toteuta tehtäväpohjassa annettuun luokkaan <code>TunteikkaatArviot</code> metodi <code>public int sanojenLukumaara(String sana)</code>. Metodin tulee kertoa sille parametrina annetun merkkijonon <code>sana</code> esiintymislukumäärä luokan konstruktorille annetussa merkkijonolistassa.
  </p>

  <p>
    Kannattanee tässä jo miettiä minkälainen tietorakenne olisi hyvä sanojen lukumäärän tallentamiseen. Saat merkkijonoon liittyvät yksittäiset sanat selville esimerkiksi String-luokan <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#split-java.lang.String-" target="_blank">split</a>-metodin avulla:
  </p>

  <% partial 'partials/code_highlight' do %>
    String merkkijono = "hei kaikki siellä";
    String[] palat = merkkijono.split(" ");<% end %>

  <p>
    Voit kokeilla ohjelmasi toimintaa esimerkiksi seuraavalla koodilla:
  </p>

  <% partial 'partials/code_highlight' do %>
    List&lt;String&gt; rivit = lueRivit("src/arviot.txt");
    TunteikkaatArviot arviot = new TunteikkaatArviot(rivit);
    System.out.println(arviot.sanojenLukumaara("what"));
    System.out.println(arviot.sanojenLukumaara("is"));
    System.out.println(arviot.sanojenLukumaara("love"));
    System.out.println(arviot.sanojenLukumaara("chuck"));
    System.out.println(arviot.sanojenLukumaara("norris"));
    System.out.println(arviot.sanojenLukumaara("mikkihiiri"));
  <% end %>

  <p>
    Ylläoleva esimerkki tuottaa seuraavanlaisen tulostuksen.
  </p>

  <% partial 'partials/sample_output' do %>
    338
    2538
    172
    2
    1
    0
  <% end %>

  <p>
    Huom! Käsittele pienellä ja isolla kirjoitetut sanat samoina sanoina!
  </p>


  <h2>Yksittäisen sanan tunne</h2>

  <p>
    Tehtäväpohjassa annetut tiedostot <code>arviot-lyhyt-1.txt</code>, <code>arviot-lyhyt-2.txt</code> ja <code>arviot.txt</code> sisältävät elokuva-arvioita. Tiedostojen muoto on seuraavanlainen, missä jokaisen rivin ensimmäinen arvo on arvioon liitetty tunnearvo skaalalla nollasta neljään. Tätä seuraa konkreettinen tekstimuotoinen arvio. Esimerkiksi:
  </p>

  <pre>
1 Simply put , there should have been a more compelling excuse to pair Susan Sarandon and Goldie Hawn .
3 Definitely in the guilty pleasure B-movie category , Reign of Fire is so incredibly inane that it is laughingly enjoyable .
3 It 's an experience in understanding a unique culture that is presented with universal appeal .
0 The French director has turned out nearly 21\/2 hours of unfocused , excruciatingly tedious cinema that , half an hour in , starts making water torture seem appealing .
  </pre>

  <p>
    Yllä on kuvattu neljän eri elokuvan saamat arviot, sekä niihin liitetyt tunnearvot. Ensimmäinen arvio on hieman negatiivinen, kaksi seuraavaa hieman positiivisia, ja viimeinen on negatiivinen.
  </p>

  <p>
    Toteuta tässä osiossa metodiin <code>public double sananTunne(String sana)</code> toiminnallisuus, joka palauttaa parametrina annetulle sanalle keskimääräisen tunnearvon.
  </p>

  <p>
    Keskimääräinen tunnearvo lasketaan niiden arvioiden keskiarvona, joissa sana esiintyy. Jos sana esiintyy useaan kertaan arviossa, tulee arvio ottaa useampaan kertaan huomioon. Jos sanaan ei esiinny kertaakaan, palauta neutraali arvo, eli 2.0.
  </p>

  <p>
    Ylläolevassa esimerkissä sana "it" esiintyy kahdesti, kummassakin lauseessa arvio on 3. Sanan "it" keskimääräiseksi tunnearvoksi tulee siis (3+3) / 2 = 3. Vastaavasti sana "that" esiintyy kolmesti, ja tunnearvoksi tulee (3+3+0) / 3 = 2.
  </p>

  <p>
    Voit kokeilla ohjelmasi toimintaa esimerkiksi seuraavalla koodilla:
  </p>

  <% partial 'partials/code_highlight' do %>
    List&lt;String&gt; rivit = lueRivit("src/arviot.txt");
    TunteikkaatArviot arviot = new TunteikkaatArviot(rivit);
    System.out.println(arviot.sananTunne("poor"));
    System.out.println(arviot.sananTunne("is"));
    System.out.println(arviot.sananTunne("love"));
    System.out.println(arviot.sananTunne("damme"));
    System.out.println(arviot.sananTunne("norris"));
  <% end %>

  <p>
    Ylläoleva esimerkki tuottaa seuraavanlaisen tulostuksen.
  </p>

  <% partial 'partials/sample_output' do %>
    0.8235294117647058
    2.0260047281323876
    2.645348837209302
    2.5
    2.0
  <% end %>

  <p>
    Toteuta lisäksi myös metodi <code>public String sananTunneMerkkijonona(String sana)</code>, joka tarkastelee sanaan liittyvää tunnearvoa ja palauttaa tunnearvoon liittyvän merkkijonon. Jos tunnearvo on pienempi tai yhtäsuuri kuin 1.9, tulee palauttaa merkkijono "negatiivinen". Jos taas tunnearvo on pienempi tai yhtäsuuri kuin 2.1, tulee palauttaa merkkijono "neutraali". Muulloin palautetaan merkkijono "positiivinen".
  </p>

  <% partial 'partials/code_highlight' do %>
    List&lt;String&gt; rivit = lueRivit("src/arviot.txt");
    TunteikkaatArviot arviot = new TunteikkaatArviot(rivit);
    System.out.println(arviot.sananTunneMerkkijonona("poor"));
    System.out.println(arviot.sananTunneMerkkijonona("is"));
    System.out.println(arviot.sananTunneMerkkijonona("love"));
    System.out.println(arviot.sananTunneMerkkijonona("damme"));
    System.out.println(arviot.sananTunneMerkkijonona("norris"));
  <% end %>

  <% partial 'partials/sample_output' do %>
    negatiivinen
    neutraali
    positiivinen
    positiivinen
    neutraali
  <% end %>

  <p>
    Huom! Käsittele pienellä ja isolla kirjoitetut sanat samoina sanoina! String-luokan metodeista toLowerCase ja toUpperCase on tässä hyötyä.
  </p>


  <h2>Lauseen tunne</h2>

  <p>
    Toteuta seuraavaksi metodi <code>public double lauseenTunne(String lause)</code>, joka palauttaa lauseen tunteen. Laske lauseen tunnearvo lauseeseen liittyvien sanojen tunnearvojen keskiarvona.
  </p>

  <% partial 'partials/code_highlight' do %>
    List&lt;String&gt; rivit = lueRivit("src/arviot.txt");
    TunteikkaatArviot arviot = new TunteikkaatArviot(rivit);

    System.out.println(arviot.lauseenTunne("unicorn is a mythical creature"));
    System.out.println(arviot.lauseenTunne("chuck norris made a happy meal cry"));
    System.out.println(arviot.lauseenTunne("the movie was an utter and complete failure"));
  <% end %>

  <% partial 'partials/sample_output' do %>
    2.181146685022733
    2.104368086244505
    1.73662040170538
  <% end %>

  <p>
    Toteuta vielä lopuksi metodi <code>public String lauseenTunneMerkkijonona(string lause)</code>, joka palauttaa lauseen tunteen merkkijonomuodossa. Käytä tässä samaa muunnosta kuin edellisessä osassa.
  </p>

  <% partial 'partials/code_highlight' do %>
    List&lt;String&gt; rivit = lueRivit("src/arviot.txt");
    TunteikkaatArviot arviot = new TunteikkaatArviot(rivit);

    System.out.println(arviot.lauseenTunneMerkkijonona("unicorn is a mythical creature"));
    System.out.println(arviot.lauseenTunneMerkkijonona("chuck norris made a happy meal cry"));
    System.out.println(arviot.lauseenTunneMerkkijonona("the movie was an utter and complete failure"));
  <% end %>

  <% partial 'partials/sample_output' do %>
    positiivinen
    positiivinen
    negatiivinen
  <% end %>


  <p>
    Huom! Kuten edellä, käsittele pienellä ja isolla kirjoitetut sanat samoina sanoina!
  </p>

<% end %>


<% partial 'partials/exercise', locals: { name: 'Pong AI' } do %>

  <p>
    Tehtäväpohjassa on mukana versio klassisesta <a href="https://en.wikipedia.org/wiki/Pong" target="_blank" norel>Pong</a>-pelistä. Tehtävänäsi on tutustua peliin ja toteuttaa pakkauksessa <code>pong.ai</code> olevaan luokkaan <code>MunPongAly</code> tekoäly, joka vähintäänkin voittaa esimerkkinä annetun luokan <code>FollowingPongAi</code>.
  </p>
  
<% end %>


<% partial 'partials/hint', locals: { name: 'Sovelluksen käytettävyys' } do %>

  <p>
    Tärkein sovelluksen testaamisen liittyvä ihmisryhmä on sovelluksen käyttäjät. Käyttäjät toimivat ohjelman parissa ja huomaavat toiminnassa esiintyviä puutteita.
  </p>
  
  <p>
    Sovelluksen käytettävyyteen liittyy useita erilaisia näkökulmia, joista osa on <a href="https://www.iso.org/standard/16883.html" target="_blank" rel="noopener">standardoitu</a>. Käytettävyyden kannalta oleellisia ominaisuuksia ovat muunmuassa:
  </p>
  
  <ul>
    <li>
      Tavoitteiden saavuttaminen. Ohjelmiston käyttäjillä on tavoitteita, joita ohjelmiston avulla halutaan saavuttaa. Miten hyvin ohjelmisto auttaa käyttäjiä saavuttamaan tavoitteensa? Miten tehokkaasti käyttäjät saavuttavat tavoitteensa? Joutuvatko he käyttämään liikaa aikaa tavoitteiden saavuttamiseen? Voisiko tätä helpottaa sovelluksen suunnittelussa?
    </li>
    <li>
      Tyytyväisyys sovelluksen toimintaan. Miten tyytyväisiä käyttäjät ovat sovelluksen toimintaan? Onko sovelluksen käyttö sujuvaa?
    </li>
    <li>
      Ohjelmiston käytön oppiminen. Kuinka nopeasti ohjelmiston käyttö on opittavissa? Minkälaisia ohjeita sovelluksen käyttö vaatii? Tarjoaako ohjelmisto näitä ohjeita? Kuinka hyvin käyttäjä muistaa miten sovellusta käytetään?
    </li>
    <li>
      Virhealttius. Kuinka paljon käyttäjä tekee virheitä sovellusta käyttäessään? Voisiko virheiden määrää vähentää?
    </li>
  </ul>
  
  <p>
    Käytettävyyden lisäksi sovelluksissa oleellista on myös saavutettavuus, millä tarkoitetaan erilaisten käyttäjäryhmien huomiointia sovelluksen rakentamisessa. Näitä käsitellään tarkemmin Human-Computer Interaction -teeman kursseilla (Ihmisen ja tietokoneen välinen vuorovaikutus).
  </p>
  
<% end %>




<% partial 'partials/material_heading' do %>
  Sovellukset ohjelmointiympäristön ulkopuolella
<% end %>


<p>
  Sovelluksemme ovat tähän mennessä toimineet vain ohjelmointiympäristössä. Tämä ei kuitenkaan ole käytännössä totta, sillä ohjelman käynnistäminen ohjelmointiympäristössä vastaa melko vahvasti sen käynnistämistä ohjelmointiympäristön ulkopuolella. Voimme määritellä luokan, jossa olevaa metodia <code>public static void main</code> käytetään ohjelman käynnistämiseen. 
</p>

<p>
  Oracle tarjoaa <a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/javapackager.html" target="_blank" norel></a>-työvälineen sovellusten paketointia varten. Osoitteessa <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/deploy/packager.html" target="_blank" norel>https://docs.oracle.com/javase/8/docs/technotes/guides/deploy/packager.html</a> on ohjeita välineen käyttöön.
</p>

<p>
  Edellä mainittuja ohjeita seuraamalla voit tehdä luomistasi ohjelmista versiot, joita voit jakaa myös muille. Tietojenkäsittelytieteen opinnoissa kuten Tietokantojen perusteissa (TKT-10004) keskitytään myös verkossa toimivien sovellusten luomiseen. Juuri käymäsi kurssi on eräs esitietovaatimus näihin kursseihin.
</p>


<% partial 'partials/hint', locals: { name: 'Mitä seuraavaksi?' } do %>

  <p>
    Tämän kurssin jälkeen on hyvä ottaa kurssit Tietokantojen perusteet sekä Tietorakenteet ja algoritmit. Kurssin tietokantojen perusteet jälkeen kannattaa ottaa kurssi Ohjelmistotekniikan menetelmät. Jos kurssia Tietokoneen toiminta ei ole vielä suorittanut, myös sen ottaminen on suositeltavaa. Muistathan, että kurssin Tietorakenteet ja algoritmit esitietovaatimuksena on kurssi Johdatus yliopistomatematiikkaan.
  </p>

<% end %>

<%= partial 'partials/quiz', locals: { id: '5a987a0f7863c4000454a043' } %>

<%= partial 'partials/quiz', locals: { id: '5ad9c629e4fd840004f3f001' } %>




<% partial 'partials/material_heading' do %>
  Ohjelmien testaaminen
<% end %>

- testikattavuus, ...







<p>
  TODO: javafxports https://mvnrepository.com/artifact/org.javafxports/jfxmobile-plugin/2.0.29
</p>