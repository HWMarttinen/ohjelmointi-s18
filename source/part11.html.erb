---
  title: Osa 11
  exercise_page: true
  quiz_page: true
  published: false
---

<% partial 'partials/hint', locals: { name: 'Yhdennentoista osan tavoitteet' } do %>

  <p>
    Osaa käsitellä yksi- ja useampiulotteisia taulukoita, ja ymmärtää miten taulukot käyttävät tilaa tietokoneen muistissa. Kertaa indeksien käyttöä. Osaa kertoa sekä taulukoiden että hajautustaulujen eduista. Tuntee ainakin yhden järjestämisalgoritmin sekä hakualgoritmin, ja tietää miten Javan omia järjestämiseen tarkoitettuja apuvälineitä käytetään. Tuntee rajapinnan Comparable ja hyödyntää sitä olioiden järjestämisessä. 
  </p>

<% end %>


<p>
  TODO: sosiaalinen pääomakysely
</p>



<% partial 'partials/material_heading' do %>
  Satunnaisuus ohjelmissa
<% end %>

<p>
  Satunnaisuutta tarvitaan esimerkiksi salausalgoritmeissa, koneoppimisessa sekä tietokonepelien ennustettavuuden vähentämisessä. Satunnaisuutta mallinnetaan käytännössä satunnaislukujen avulla, joiden luomiseen Java tarjoaa valmiin <code>Random</code>-luokan. Random-luokasta voi tehdä olion jota voi käyttää seuraavalla tavalla.
</p>

<% partial 'partials/code_highlight' do %>
  import java.util.Random;

  public class Arvontaa {
      public static void main(String[] args) {
          Random arpoja = new Random(); // luodaan apuväline arpoja

          for (int i = 0; i &lt; 10; i++) {
              // Arvotaan ja tulostetaan satunnainen luku
              int luku = arpoja.nextInt(10);
              System.out.println(luku);
          }
      }
  }
<% end %>

<p>
  Yllä olevassa esimerkissä luodaan ensin <code>Random</code>-luokasta olio. Random-olio tarjoaa metodin <code>nextInt</code>, jolle annetaan parametrina kokonaisluku. Metodi palauttaa satunnaisen kokonaisluvun väliltä <code>[0,kokonaisluku[</code> eli <em>0..(annettu kokonaisluku - 1)</em>.
</p>

<p>
  Ohjelman tuottama tulostus ei ole aina sama. Yksi mahdollinen tulostusesimerkki on seuraava:
</p>

<% partial 'partials/sample_output' do %>
  2
  2
  4
  3
  4
  5
  6
  0
  7
  8
<% end %>

<% partial 'partials/exercise', locals: { name: 'TODO: ohjelma, joka tulostaa satunnaislukuja väliltä 0-100' } do %>
  <p>
    LOL
  </p>

<% end %>

<p>
  Metodin <code>nextInt</code> avulla pystyy luomaan hyvin monipuolista satunnaisuutta. Ohjelmoija saattaisi esimerkiksi haluta, että ohjelman ilmoittama lämpötila on satunnainen ja väliltä [-30,50]. Tällöin ratkaisu on arpoa lukuja nollan ja kahdeksankymmenen väliltä ja miinustaa arvotusta luvusta 30.
</p>


<% partial 'partials/code_highlight' do %>
  Random arpoja = new Random();
  int lampotila = arpoja.nextInt(81) - 30;
  System.out.println(lampotila);
<% end %>

<% partial 'partials/exercise', locals: { name: 'Noppa' } do %>

  <p>
    Tehtäväpohjassa on luokka <code>Noppa</code>, jonka runko on seuraava:
  </p>

  <% partial 'partials/code_highlight' do %>
    import java.util.Random;

    public class Noppa {
        private Random random;
        private int tahkojenMaara;

        public Noppa(int tahkojenMaara) {
            this.random = new Random();
            // Alusta oliomuuttuja tahkojenMaara tässä
        }

        public int heita() {
            // arvo täällä luku jonka tulee olla yhdestä tahkojen määrään
            // ja palauta se
        }
    }
  <% end %>

  <p>
    Muokkaa luokkaa siten, että sen konstruktori<code>Noppa(int tahkojenMaara)</code> luo uuden noppa-olion annetulla nopan tahkojen (eri oman numeronsa sisältämien "puolien") määrällä. Muokkaa myös metodia <code>heita</code> siten, että se antaa satunnaisen nopanheiton tuloksen, jonka arvon tulee olla väliltä <code>1...tahkojen määrä</code>.
  </p>

  <p>
    Seuraavassa noppaa testaava pääohjelma:
  </p>

  <% partial 'partials/code_highlight' do %>
    public class Ohjelma {
        public static void main(String[] args) {
            Noppa noppa = new Noppa(6);

            for (int i = 0; i &lt; 10; i++) {
                System.out.println(noppa.heita());
            }
        }
    }
  <% end %>

  <p>
    Tulostus voisi olla esimerkiksi seuraava:
  </p>

  <% partial 'partials/sample_output' do %>
    1
    6
    3
    5
    3
    3
    2
    2
    6
    1
  <% end %>

<% end %>

<p>
  Random-luokasta tehdyn olion kautta päästään käsiksi myös satunnaisiin liukulukuihin, joita käytetään muunmuassa todennäköisyyslaskennan yhteydessä; tietokoneilla todennäköisyyksiä simuloidaan yleensä väliltä [0..1] olevilla luvuilla.
</p>

<p>
  Random-oliolta satunnaisia liukulukuja saa metodilla <code>nextDouble</code>. Tarkastellaan seuraavia säämahdollisuuksia:
</p>

<ul>
  <li>Sataa räntää todennäköisyydellä 0.1 (10%)</li>
  <li>Sataa lunta todennäköisyydellä 0.3 (30%)</li>
  <li>Aurinko paistaa todennäköisyydellä 0.6 (60%)</li>
</ul>

<p>
  Luodaan edellä olevista arvioista sääennustaja.
</p>

<% partial 'partials/code_highlight' do %>
  import java.util.ArrayList;
  import java.util.Random;

  public class SaaEnnustaja {
      private Random random;

      public SaaEnnustaja() {
          this.random = new Random();
      }

      public String ennustaSaa() {
          double todennakoisyys = this.random.nextDouble();

          if (todennakoisyys &lt;= 0.1) {
              return "Sataa räntää";
          } else if (todennakoisyys &lt;= 0.4) { // 0.1 + 0.3
              return "Sataa lunta";
          } else { // loput, 1.0 - 0.4 = 0.6
              return "Aurinko paistaa";
          }
      }

      public int ennustaLampotila() {
          return (int) (4 * this.random.nextGaussian() - 3);
      }
  }
<% end %>

<p>
  Metodi <code>ennustaLampotila</code> on monella tapaa mielenkiintoinen. Metodin sisällä tehtävä kutsu <code>this.random.nextGaussian()</code> on tavallinen metodikutsu, jonka kaltaisia olemme nähneet aikaisemminkin. Kiinnostavaa tässä <code>Random</code>-luokan ilmentymän tarjoamassa metodissa on se, että metodin palauttama luku on normaalijakautunut (normaalijakautuneilla luvuilla voi kuvata esimerkiksi ihmisten pituuksia ja painoja -- jos et koe mielenkiintoa satunnaisuuden eri lajeihin se ei haittaa!).
</p>

<% partial 'partials/code_highlight' do %>
  public int ennustaLampotila() {
      return (int) (4 * this.random.nextGaussian() - 3);
  }
<% end %>

<p>
  Edellisessä esimerkissä käytetään eksplisiittistä tyyppimuunnosta liukulukujen muuntamiseen kokonaisluvuiksi <code>(int)</code>. Vastaavalla menetelmällä voidaan muuttaa myös kokonaislukuja liukuluvuiksi kirjoittamalla <code>(double) kokonaisluku</code>
</p>

<p>
  Luodaan vielä pääohjelma josta luokkaa <code>SaaEnnustaja</code> käytetään.
</p>

<% partial 'partials/code_highlight' do %>
  // importit 

  public class Ohjelma {

      public static void main(String[] args) {
          SaaEnnustaja ennustaja = new SaaEnnustaja();

          // tallennetaan päivät listalle
          ArrayList&lt;String&gt; paivat = new ArrayList&lt;&gt;();
          paivat.add("Ma");
          paivat.add("Ti");
          paivat.add("Ke");
          paivat.add("To");
          paivat.add("Pe");
          paivat.add("La");
          paivat.add("Su");

          System.out.println("Seuraavan viikon sääennuste:");

          for (String paiva: paivat) {
              String saaEnnuste = ennustaja.ennustaSaa();
              int lampotilaEnnuste = ennustaja.ennustaLampotila();

              System.out.println(paiva + ": " + saaEnnuste + " " + lampotilaEnnuste + " astetta.");
          }
      }
  }
<% end %>

<p>
  Ohjelman tulostus voisi olla esimerkiksi seuraavanlainen:
</p>

<% partial 'partials/sample_output' do %>
  Seuraavan viikon sääennuste:
  Ma: Sataa lunta 1 astetta.
  Ti: Sataa lunta 1 astetta.
  Ke: Aurinko paistaa -2 astetta.
  To: Aurinko paistaa 0 astetta.
  Pe: Sataa lunta -3 astetta.
  La: Sataa lunta -3 astetta.
  Su: Aurinko paistaa -5 astetta
<% end %>

<% partial 'partials/exercise', locals: { name: 'Lottoarvonta' } do %>

  <p>
    Tehtävänäsi on täydentää luokkaa <code>Lottorivi</code>, joka arpoo viikon lottonumerot. Lottonumerot ovat väliltä 1&ndash;40 ja niitä arvotaan 7. Lottorivi koostuu siis seitsemästä eri numerosta väliltä 1&ndash;40.
  </p>
  <p>
    Luokalle toivotaan seuraava toiminnot:
  </p>

  <ul>
    <li>
      konstruktori <code>Lottorivi</code> luo uuden Lottorivi-olion joka sisältää uudet, arvotut numerot
    </li>
    <li>
      metodi <code>numerot</code> palauttaa tämän lottorivin lottonumerot
    </li>
    <li>
      metodi <code>sisaltaaNumeron</code> kertoo onko arvotuissa numeroissa annettu numero
    </li>
    <li>
      metodi <code>arvoNumerot</code> arpoo riville uudet numerot
    </li>
    <li>
      metodi <code>equals</code> kertoo onko lottorivin luvun täsmälleen samat kuin parametrina annetun lottorivin luvut.
    </li>
  </ul>

  <p>
    Luokan runko on seuraava:
  </p>

  <% partial 'partials/code_highlight' do %>
    import java.util.ArrayList;
    import java.util.Random;

     public class LottoRivi {
        private ArrayList&lt;Integer&gt; numerot;

        public LottoRivi() {
            this.arvoNumerot();
        }

        public ArrayList&lt;Integer&gt; numerot() {
            return this.numerot;
        }

        public boolean sisaltaaNumeron(int numero) {
            // Testaa tässä onko numero jo arvottujen numeroiden joukossa
            return false;
        }

        public void arvoNumerot() {
            // alustetaan lista numeroille
            this.numerot = new ArrayList&lt;&gt;();
            // Kirjoita numeroiden arvonta tänne käyttämällä metodia sisaltaaNumeron()
        }

        public boolean equals(Object toinen) {
            return false;
        }
    }
  <% end %>

  <p>
    Tehtäväpohjan mukana tulee seuraava pääohjelma:
  </p>

  <% partial 'partials/code_highlight' do %>
    import java.util.ArrayList;

    public class Ohjelma {
        public static void main(String[] args) {
            Lottorivi rivi = new Lottorivi();
            ArrayList&lt;Integer&gt; lottonumerot = rivi.numerot();

            System.out.println("Lottonumerot:");
            for (int numero: lottonumerot) {
                System.out.print(numero + " ");
            }

            System.out.println("");
        }
    }
  <% end %>

  <p>
    Ohjelman mahdollisia tulostuksia ovat seuraavat:
  </p>

  <% partial 'partials/sample_output' do %>
    Lottonumerot:
    3 5 10 14 15 27 37
  <% end %>

  <% partial 'partials/sample_output' do %>
    Lottonumerot:
    2 9 11 18 23 32 34
  <% end %>

  <p>
    <strong>Huom!</strong> Sama numero saa esiintyä lottorivissä vain kerran. Lottorivin numeroiden ei tarvitse olla järjestyksessä.
  </p>

<% end %>

<% partial 'partials/hint', locals: { name: 'Lukujen satunnaisuudesta' } do %>

  <p>
    Tietokoneiden toiminta on ennustettavissa sillä ne suorittavat niille annettuja komentoja orjallisesti. Ovatko siis tietokoneen luomat luvut todellisuudessa satunnaisia?
  </p>

  <p>
    Tietokoneohjelmissa käytetyt satunnaisluvut ovat tyypillisesti pseudosatunnaislukuja, eli ne vaikuttavat satunnaisluvuilta, mutta seuraavat todellisuudessa jonkinlaista algoritmisesti luotua toistuvaa lukusarjaa. Suurimmalle osalle tietokoneohjelmista pseudosatunnaisluvut ovat riittävän hyviä -- esimerkiksi youtube-videoiden satunnaisessa toistossa normaali käyttäjä tuskin huomaa eroa. Toisaalta, jos satunnaislukuja käytetään tieteelliseen laskentaan, heikosti toimivat pseudosatunnaislukuja luovat algoritmit saattavat jopa johtaa tulosten kyseenalaistamiseen. Eräs esimerkki tällaisesta on hetken 1960-luvulla käytössä ollut IBM:n <a href="https://en.wikipedia.org/wiki/RANDU" target="_blank" norel>RANDU</a>.
  </p>

  <p>
    Kaikki tietokoneohjelmien satunnaisuus ei kuitenkaan ole pseudosatunnaisuutta. Vahvempaan satunnaisuuteen pyrkivät ohjelmat hyödyntävät muunmuassa jonkinlaisia tosielämän satunnaiseksi ajateltuja ilmiöitä satunnaislukujen luomiseen. Tällaisia ilmiöitä ovat esimerkiksi avaruussäteily tai vaikkapa <a href="https://www.wired.com/2003/08/random/" target="_blank" norel>laavalamppujen toiminta</a>.
  </p>

  <p>
    Lisää aiheesta osoitteessa <a href="https://www.random.org/randomness/" target="_blank" norel>https://www.random.org/randomness/</a>.
  </p>

<% end %>


<% partial 'partials/material_heading' do %>
  Geneerinen tyyppi
<% end %>


<p>
  Olemme listoihin tutustumisesta lähtien kertoneet erilaisille tietorakenteille niiden sisältämän arvon tyypin. Esimerkiksi String-tyyppisiä olioita sisältävä lista on esitelty muodossa <code>ArrayList&lt;String&gt;</code>. Tässä on saattanut kuitenkin ihmetyttää se, että miten ihmeessä listat ja muutkin tietorakenteet voivat sisältää erityyppisiä oliota.
</p>

<p>
  Geneerisyys (<em>generics</em>) liittyy olioita säilövien luokkien tapaan säilöä vapaavalintaisen tyyppisiä olioita. Vapaavalintaisuus perustuu luokkien määrittelyssä käytettyyn geneeriseen tyyppiparametriin, jonka avulla voidaan määritellä <em>olion luontivaiheessa</em> valittavia tyyppejä. Luokan geneerisyys määritellään antamalla luokan nimen jälkeen haluttu määrä luokan tyyppiparametreja luokan nimen jälkeen tulevien pienempi kuin ja suurempi kuin -merkkien väliin <code>public class Luokka&lt;Tyyppiparametri1, Tyyppiparametri2, ...&gt;</code>. Tyyppiparametrit määritellään tyypillisesti yhdellä kirjaimella.
</p>

<p>
  Toteutetaan oma geneerinen luokka <code>Lokero</code>, johon voi asettaa yhden minkälaisen tahansa olion.
</p>

<% partial 'partials/code_highlight' do %>
  public class Lokero&lt;T&gt; {
      private T alkio;

      public void asetaArvo(T alkio) {
          this.alkio = alkio;
      }

      public T haeArvo() {
          return alkio;
      }
  }
<% end %>

<p>
  Määrittely <code>public class Lokero&lt;T&gt;</code> kertoo että luokalle <code>Lokero</code> tulee antaa konstruktorissa tyyppiparametri. Konstruktorikutsun jälkeen kaikki olion sisäiset muuttujat tulevat olemaan kutsun yhteydessä annettua tyyppiä. Luodaan merkkijonon tallentava lokero.
</p>

<% partial 'partials/code_highlight' do %>
  Lokero&lt;String&gt; merkkijono = new Lokero&lt;&gt;();
  merkkijono.asetaArvo(":)");

  System.out.println(merkkijono.haeArvo());
<% end %>

<% partial 'partials/sample_output' do %>
  :)
<% end %>

<p>
  Yllä olevalla ohjelmalla merkkijono-nimisen <code>Lokero</code>-olion <strong>ajonaikainen</strong> toteutus on seuraavanlainen.
</p>

<% partial 'partials/code_highlight' do %>
  public class Lokero&lt;String&gt; {
      private String alkio;

      public void asetaArvo(String alkio) {
          this.alkio = alkio;
      }

      public String haeArvo() {
          return alkio;
      }
  }
<% end %>

<p>
  Tyyppiparametria vaihtamalla voidaan luoda myös muuntyyppisiä olioita tallentavia <code>Lokero</code>-olioita. Esimerkiksi kokonaisluvun saa tallennettua seuraavasti.
</p>

<% partial 'partials/code_highlight' do %>
  Lokero&lt;Integer&gt; luku = new Lokero&lt;&gt;();
  luku.asetaArvo(5);

  System.out.println(luku.haeArvo());
<% end %>

<% partial 'partials/sample_output' do %>
  5
<% end %>

<p>
  Vastaavasti esimerkiksi <code>Random</code>-olion sisältävän lokeron saa luotua seuraavalla tavalla. 
</p>

<% partial 'partials/code_highlight' do %>
  Lokero&lt;Random&gt; luku = new Lokero&lt;&gt;();
  luku.asetaArvo(new Random());

  System.out.println(luku.haeArvo().nextDouble());
<% end %>

<p>
  Tyyppiparametrien määrää ei ole rajattu, vaan määrä riippuu toteutuksesta. Ohjelmoija voisi halutessaan toteuttaa esimerkiksi <code>Pari</code>-luokan, johon voi laittaa kaksi halutun tyyppistä oliota.
</p>

<% partial 'partials/code_highlight' do %>
  public class Pari&lt;T, K&gt; {
      private T eka;
      private K toka;

      public void asetaArvot(T eka, K toka) {
          this.eka = eka;
          this.toka = toka;
      }

      public T haeEka() {   
          return this.eka;
      }

      public K haeToka() {
          return this.toka;
      }
  }
<% end %>

<p>
  Huomattava osa Javan tietorakenteista käyttää tyyppiparametreja ja mahdollistaa eri tyyppisten muuttujien lisäämisen niihin. Esimerkiksi ArrayList saa yhden tyyppiparametrin, HashMap kaksi.
</p>

<% partial 'partials/code_highlight' do %>
  List&lt;String&gt; merkkijonot = new ArrayList&lt;&gt;();
  Map&lt;String, String&gt; avainArvoParit = new HashMap&lt;&gt;();
<% end %>

<p>
  Jatkossa kun näet esimerkiksi tyypin <code>ArrayList&lt;String&gt;</code> tiedät että sen sisäisessä rakenteessa on käytetty geneeristä tyyppiparametria. Sama periaate löytyy esimerkiksi rajapinnassa Comparable.
</p>


<% partial 'partials/exercise', locals: { name: 'TODO: tehtava' } do %>

  <p>
    TODO: geneerinen tyyppi 1
  </p>

<% end %>

<% partial 'partials/exercise', locals: { name: 'TODO: tehtava' } do %>

  <p>
    TODO: geneerinen tyyppi 2
  </p>

<% end %>


<% partial 'partials/material_heading' do %>
  ArrayList ja Hajautustaulu
<% end %>

<p>
  ArrayList ja Hajautustaulu ovat ohjemoinnissa hyvin yleisesti käytettyjä tietorakenteita. Tarkastellaan tässä niiden todellista toteutusta. Kerrataan ensin lyhyesti taulukon käyttöä, jonka jälkeen rakennetaan esimerkinomaisesti ensin ArrayListiä imitoiva tietorakenne <code>Lista</code>, jota hyödynnetään sitten tietorakenteen <code>Hajautustaulu</code> tekemisessä.
</p>


<% partial 'partials/material_sub_heading' do %>
  Lyhyt kertaus taulukoista
<% end %>

<p>
  Taulukko on olio, joka sisältää rajatun määrän numeroituja paikkoja arvoille. Taulukon pituus (tai koko) on siinä olevien paikkojen lukumäärä, eli kuinka monta arvoa taulukkoon voi laittaa. Taulukon koko on aina ennalta määrätty: koko määrätään taulukon luomisen yhteydessä eikä sitä voi muuttaa.
</p>

<p>
  Taulukkotyyppi määritellään hakasuluilla, jota edeltää taulukossa olevien alkioiden tyyppi (alkioidentyyppi[]). Taulukko luodaan <code>new</code>-kutsulla, jota seuraa taulukon alkioiden tyyppi, hakasulut, sekä hakasulkujen sisään asetettava luotavan taulukon alkioiden lukumäärä.
</p>

<% partial 'partials/code_highlight' do %>
  int[] luvut = new int[3];
  String[] merkkijonot = new String[5];
<% end %>

<p>
  Taulukon alkioihin viitataan taulukon indeksien perusteella. Alla olevassa esimerkissä luodaan kolmepaikkainen kokonaislukutaulukko, jonka jälkeen taulukon indekseihin 0 ja 2 asetetaan arvot. Tämän jälkeen arvot tulostetaan.
</p>

<% partial 'partials/code_highlight' do %>
  int[] luvut = new int[3];
  luvut[0] = 2;
  luvut[2] = 5;

  System.out.println(luvut[0]);
  System.out.println(luvut[2]);
<% end %>

<% partial 'partials/sample_output' do %>
  2
  5
<% end %>

<p>
  Yksittäisen arvon asettaminen taulukon tiettyyn paikkaan tapahtuu kuten arvon asetus tavalliseen muuttujaan, mutta taulukkoon asetettaessa kerrotaan paikkaa kuvaava indeksi. 
</p>

<p>
  Taulukko-olion koon saa selville taulukko-olioon liittyvän julkisen oliomuuttujan <code>length</code> avulla, ja taulukon alkioiden läpikäynti voidaan toteuttaa esimerkiksi for-toistolauseen avulla.
</p>

<% partial 'partials/code_highlight' do %>
  int[] luvut = new int[4];
  luvut[0] = 42;
  luvut[1] = 13;
  luvut[2] = 12;
  luvut[3] = 7;

  System.out.println("Taulukossa on " + luvut.length + " alkiota.");

  for (int i = 0; i &lt; luvut.length; i++) {
      System.out.println(luvut[i]);
  }
<% end %>


<% partial 'partials/sample_output' do %>
  Taulukossa on 4 alkiota.
  42
  13
  12
  7
<% end %>

<% partial 'partials/exercise', locals: { name: 'Etsityn alkion indeksi' } do %>

  <p>
    Tehtäväpohjassa on valmiina taulukko, joka sisältää lukuja. Täydennä ohjelmaa siten, että käyttäjältä kysyttyä lukua etsitään taulukosta. Jos luku löytyy taulukosta, ohjelma kertoo luvun indeksin. Jos lukua taas ei löydy taulukosta, ohjelma kertoo ettei lukua löydy.
  </p>

  <% partial 'partials/sample_output' do %>
    Mitä etsitään? <font color="red">3</font>
    Luku 3 löytyy indeksistä 4.
  <% end %>

  <% partial 'partials/sample_output' do %>
    Mitä etsitään? <font color="red">7</font>
    Luku 7 löytyy indeksistä 7.
  <% end %>

  <% partial 'partials/sample_output' do %>
    Mitä etsitään? <font color="red">22</font>
    Lukua 22 ei löydy.
  <% end %>

<% end %>

<p>
  Taulukoita voi käyttää täysin samalla tavalla kuin muitakin muuttujia, eli niitä voi käyttää esimerkiksi oliomuuttujina, metodin parametreina, metodin paluuarvona ym. 
</p>

<p>
  Merkittävä osa yleisesti käytetyistä tietorakenteista käyttää taulukoita niiden sisäisessä toteutuksessa. 
</p>


<% partial 'partials/material_sub_heading' do %>
  Listarakenne
<% end %>

<p>
  Tarkastellaan erästä tapaa Javan tarjoaman ArrayList-tietorakenteen toteuttamiseen. Javan ArrayList hyödyntää sisäisesti taulukkoa, jonka alkioiden tyyppi on määritelty luokalle ArrayList annettavan tyyppiparametrin avulla. Tämän takia listalle saa lisätä käytännössä minkä tyyppisiä arvoja tahansa. Lista tarjoaa useita metodeja, joista tämän esimerkin kannalta oleellisia ovat <code>add</code> eli lisääminen, <code>contains</code> eli olemassaolon tarkastaminen, <code>remove</code> eli poistaminen sekä <code>get</code>, eli tietystä indeksistä hakeminen.
</p>

<% partial 'partials/code_highlight' do %>
  ArrayList&lt;String&gt; merkkijonot = new ArrayList&lt;&gt;();
  System.out.println(merkkijonot.contains("Hei!"));
  merkkijonot.add("Hei!");
  System.out.println(merkkijonot.contains("Hei!"));
  merkkijonot.remove("Hei!");
  System.out.println(merkkijonot.contains("Hei!"));
<% end %>

<% partial 'partials/sample_output' do %>
  false
  true
  false
<% end %>

<% partial 'partials/material_sub_sub_heading' do %>
  Listan luominen
<% end %>

<p>
  Luodaan luokka <code>Lista</code>. Listarakenne sisältää geneerisen taulukon -- eli taulukon, jonka alkioiden tyyppi määräytyy ajonaikaisesti tyyppiparametreista. Asetetaan taulukon alkukooksi <code>10</code>. Taulukko luodaan object tyyppisenä ja muunnetaan geneerisen tyyppiseksi <code>(T[]) new Object[10];</code> -- tämä tehdään, sillä kutsu <code>new T[10];</code> ei ainakaan toistaiseksi toimi Javassa.
</p>

<% partial 'partials/code_highlight' do %>
  public class Lista&lt;T&gt; {
      private T[] arvot;

      public Lista() {
          this.arvot = (T[]) new Object[10];
      }
  }
<% end %>

<p>
  Lista kapseloi taulukon. Alkutilanteessa jokainen taulukon indeksi sisältää <code>null</code>-viitteen.
</p>

<% partial 'partials/material_sub_sub_heading' do %>
  Arvojen lisääminen listalle
<% end %>

<p>
  Lisätään luokalle metodi <code>public void lisaa(T arvo)</code>, mikä mahdollistaa arvojen lisäämisen listalle. Luodaan luokalle tätä varten erillinen kokonaislukumuuttuja, joka pitää kirjaa taulukon ensimmäisestä tyhjästä paikasta.
</p>

<% partial 'partials/code_highlight' do %>
  public class Lista&lt;T&gt; {

      private T[] arvot;
      private int arvoja;

      public Lista() {
          this.arvot = (T[]) new Object[10];
          this.arvoja = 0;
      }

      public void lisaa(T arvo) {
          this.arvot[this.arvoja] = arvo;
          this.arvoja++; // sama kuin this.arvoja = this.arvoja + 1;
      }
  }
<% end %>

<p>
  Nyt arvojen lisääminen listalle onnistuu -- tai, ainakin listan luominen ja metodin kutsuminen onnistuu -- emme vielä voi testata ovatko arvot todellisuudessa listalla.
</p>

<% partial 'partials/code_highlight' do %>
  Lista&lt;String&gt; lista = new Lista&lt;&gt;();
  lista.lisaa("hei");
  lista.lisaa("maailma");
<% end %>

<% partial 'partials/material_sub_sub_heading' do %>
  Arvojen lisääminen listalle, osa 2
<% end %>

<p>
  Edellä kuvatussa <code>lisaa</code>-metodissa on pieni ongelma. Ongelma ilmenee kun seuraava ohjelmakoodi suoritetaan.
</p>

<% partial 'partials/code_highlight' do %>
  Lista&lt;String&gt; lista = new Lista&lt;&gt;();
  for (int i = 0; i &lt; 11; i++) {
      lista.lisaa("hei");
  }
<% end %>

<% partial 'partials/sample_output' do %>
  Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: 10
  at tietorakenteita.Lista.lisaa(Lista.java:14)
  at tietorakenteita.Ohjelma.main(Ohjelma.java:8)
<% end %>

<p>
  Listan koko ei kasva. Eräs ArrayList-luokan oleellisimmista toiminnallisuuksista on se, että sen koko kasvaa aina tarvittaessa -- ohjelmoijan ei siis tarvitse varoa listan täyttymistä.
</p>

<p>
  Lisätään ohjelmaan listan koon kasvattamiseen liittyvä toiminnallisuus. Listan kokoa kasvatetaan aina jos täyteen listaan (eli listan sisällä olevaan täyteen taulukkoon) yritetään lisätä arvo. Kasvattaminen toteutetaan luomalla uusi taulukko, johon vanhan taulukon arvot kopioidaan. Tämän jälkeen vanha taulukko jätetään heitteille, ja uudesta taulukosta tulee olion käyttämä taulukko.
</p>

<p>
  Uuden taulukon koko määräytyy Javassa kaavalla <code>vanhakoko + vanhaKoko / 2</code>. Hyödynnetään samaa kaavaa omassa toteutuksessamme. Luodaan kasvattamista varten erillinen metodi <code>kasvata</code>, joka on vain luokan omien metodien käytössä (eli sillä on <code>private</code>-näkyvyys).
</p>

<% partial 'partials/code_highlight' do %>
  private void kasvata() {
      int uusiKoko = this.arvot.length + this.arvot.length / 2;
      T[] uusi = (T[]) new Object[uusiKoko];
      for (int i = 0; i &lt; this.arvot.length; i++) {
          uusi[i] = this.arvot[i];
      }
  
      this.arvot = uusi;
  }
<% end %>

<p>
  Toteutus luo uuden taulukon, jonka koko on 1.5-kertainen vanhaan taulukkoon verrattuna. Tämän jälkeen kaikki vanhan taulukon alkiot kopioidaan uuteen taulukkoon ja lopulta olion <code>arvot</code>-muuttujan -- eli taulukon -- arvoksi asetetaan uusi taulukko. Javan automaattinen roskienkerääjä poistaa vanhan taulukon kun siihen ei enää viitata.
</p>

<p>
  Muokataan vielä metodia <code>lisaa</code> siten, että taulukon kokoa kasvatetaan tarvittaessa.
</p>

<% partial 'partials/code_highlight' do %>
  public void lisaa(T arvo) {
      if(this.arvoja == this.arvot.length) {
          kasvata();
      }
  
      this.arvot[this.arvoja] = arvo;
      this.arvoja++;
  }
<% end %>

<p>
  Nyt arvoja voi lisätä listalle lähes rajattomasti.
</p>


<% partial 'partials/hint', locals: { name: 'Edellä kuvatun kasvatusmenetelmän tehokkuudesta' } do %>

  <p>
    Edellä kuvattu menetelmä kopioi kasvatuksen yhteydessä jokaisen vanhan taulukon arvon uuteen taulukkoon. Mikäli taulukossa on esimerkiksi kaksi miljoonaa alkiota, kopiointi käy kaksi miljoonaa alkiota läpi.
  </p>

  <p>
    Menetelmän tehokkuuteen -- ja parannusehdotuksiin -- paneudutaan muunmuassa kursseilla Tietorakenteet ja algoritmit sekä Algoritmien suunnittelu ja analyysi.
  </p>

<% end %>


<% partial 'partials/material_sub_sub_heading' do %>
  Arvon olemassaolon tarkastaminen
<% end %>

<p>
  Luodaan listalle seuraavaksi metodi <code>public boolean sisaltaa(T arvo)</code>, minkä avulla voidaan tarkistaa onko alkio listalla. Hyödynnetään tässä tietoa siitä, että jokainen Javan olio -- riippumatta sen tyypistä -- perii Object-luokan (tai on Object-tyyppinen). Tämän takia jokaisella oliolla on metodi <code>public boolean equals(Object object)</code>, jota voidaan käyttää yhtäsuuruuden tarkasteluun.
</p>

<p>
  Luokan <code>Lista</code> muuttuja <code>arvoja</code> sisältää tiedon arvojen tämän hetkisestä lukumäärästä. Voimme siis toteuttaa <code>sisaltaa</code>-metodin siten, että tarkastelemme vain ne listan indeksit, joissa on arvoja.
</p>

<% partial 'partials/code_highlight' do %>
  public boolean sisaltaa(T arvo) {
      for (int i = 0; i &lt; this.arvoja; i++) {
          if (this.arvot[i].equals(arvo)) {
              return true;
          }
      }
  
      return false;
  }
<% end %>

<p>
  Ohjelmassa on nyt mahdollisuus listalla olevien alkioiden olemassaolon tarkasteluun.
</p>

<% partial 'partials/code_highlight' do %>
  Lista&lt;String&gt; lista = new Lista&lt;&gt;();
  System.out.println(lista.sisaltaa("hei"));
  lista.lisaa("hei");
  System.out.println(lista.sisaltaa("hei"));
<% end %>


<% partial 'partials/sample_output' do %>
  false
  true
<% end %>

<p>
  Edellä esitetty menetelmä olettaa, että käyttäjä ei lisää listalle <code>null</code>-viitettä ja että equals-metodi tarkastaa ettei parametrina saatu arvo ole null.
</p>


<% partial 'partials/material_sub_sub_heading' do %>
  Arvon poistaminen
<% end %>

<p>
  Toteuttamallemme listalle voi nyt lisätä arvoja, jonka lisäksi arvon olemassaolon voi tarkastaa. Toteutetaan vielä arvon poistaminen. Toteutetaan metodi <code>public void poista(T arvo)</code>, joka poistaa listalta <em>yhden</em> <code>arvo</code>-arvoisen alkion.
</p>

<p>
  Yksinkertainen toteutus olisi seuraava.
</p>


<% partial 'partials/code_highlight' do %>
  public void poista(T arvo) {
      for (int i = 0; i &lt; this.arvoja; i++) {
          if (arvo == this.arvot[i] || this.arvot[i].equals(arvo)) {
              this.arvot[i] = null;
              this.arvoja--;
              return true;
          }
      }
  
      return false;
  }
<% end %>

<p>
  Yllä oleva lähestymistapa on kuitenkin ongelmallinen, sillä se jättää listalle "tyhjiä" kohtia, jonka lisäksi esimerkiksi edellä esitetty etsiminen ei enää.
</p>

<p>
  Ongelman voi ratkaista useammalla tavalla, joista yksi on siirtää jokaista poistettua arvoa seuraavaa arvoa vasemmalle. Lisätään tämä toiminnallisuus ohjelmaan.
</p>

<% partial 'partials/code_highlight' do %>
  public void poista(T arvo) {
      boolean loytyi = false;
      for (int i = 0; i &lt; this.arvoja; i++) {
          if (loytyi) {
              this.arvot[i - 1] = this.arvot[i];
          } else if (arvo == this.arvot[i] || this.arvot[i].equals(arvo)) {
              this.arvoja--;
              loytyi = true;
          }
      }
  }
<% end %>

<p>
  Emme ole kovin tyytyväisiä edelliseen ratkaisuun, sillä siinä tehdään monta asiaa samaan aikaan. Metodissa sekä etsitään alkiota että siirretään alkioita. Pilkotaan toiminnallisuus kahteen erilliseen metodiin: <code>private int arvonIndeksi(T arvo)</code>, joka etsii parametrina annetun arvon indeksin, sekä <code>private void siirraVasemmalle(int indeksista)</code>, joka siirtää annetusta indeksistä lähtien alkioita yhden vasemmalle.
</p>

<p>
  Toteutetaan ensin metodi <code>private int arvonIndeksi(T arvo)</code>, joka etsii annetun arvon indeksin. Metodi palauttaa negatiivisen luvun mikäli arvoa ei löydy.
</p>

<% partial 'partials/code_highlight' do %>
  private int arvonIndeksi(T arvo) {
      for (int i = 0; i &lt; this.arvoja; i++) {
          if (this.arvot[i].equals(arvo)) {
              return i;
          }
      }

      return -1;
  }
<% end %>

<p>
  Toteutetaan tämän jälkeen metodi <code>private void siirraVasemmalle(int indeksistaLahtien)</code>, joka siirtää arvoja annetusta indeksistä lähtien vasemmalle.
</p>

<% partial 'partials/code_highlight' do %>
  private void siirraVasemmalle(int indeksistaLahtien) {
      for (int i = indeksistaLahtien; i &lt; this.arvoja - 1; i++) {
          this.arvot[i] = this.arvot[i + 1];
      }
  }
<% end %>

<p>
  Nyt metodi <code>poista</code> voidaan toteuttaa edellisten avulla hieman selkokielisemmäksi.
</p>

<% partial 'partials/code_highlight' do %>
  public void poista(T arvo) {
      int arvonIndeksi = arvonIndeksi(arvo);
      if (arvonIndeksi &lt; 0) {
          return; // ei löydy
      }

      siirraVasemmalle(arvonIndeksi);
      this.arvoja--;
  }
<% end %>

<% partial 'partials/hint', locals: { name: 'Edellä kuvatun poistomenetelmän tehokkuudesta' } do %>

  <p>
    Edellä kuvattu menetelmä kopioi poiston yhteydessä jokaisen poistettua alkiota seuraavan alkion vasemmalle. Pohdi toteutuksen tehokkuutta tilanteessa, missä listaa käytetään jonona.
  </p>

  <p>
    Tämänkin menetelmän tehokkuuteen -- ja parannusehdotuksiin -- paneudutaan muunmuassa kursseilla Tietorakenteet ja algoritmit sekä Algoritmien suunnittelu ja analyysi.
  </p>

<% end %>

<p>
  Luokassa lista on nyt hieman toistuvaa koodia. Metodi <code>sisaltaa</code> on hyvin samankaltainen metodin <code>arvonIndeksi</code> kanssa. Muokataan vielä metodia <code>sisaltaa</code> siten, että se toteutetaan metodin <code>arvonIndeksi</code> avulla.
</p>

<% partial 'partials/code_highlight' do %>
  public boolean sisaltaa(T arvo) {
      return arvonIndeksi(arvo) &gt;= 0;
  }
<% end %>

<p>
  Nyt käytössämme on lista, joka tarjoaa metodit <code>lisaa</code>, <code>sisaltaa</code>, ja <code>poista</code>. Lista myös kasvaa tarvittaessa. Listan toteutusta voisi toki vielä kehittää esimerkiksi lisäämällä toiminnallisuuden, mikä pienentää listan kokoa jos arvojen määrä pienenee hyvin pieneksi.
</p>

<% partial 'partials/code_highlight' do %>
  Lista&lt;String&gt; lista = new Lista&lt;&gt;();
  System.out.println(lista.sisaltaa("hei"));
  lista.lisaa("hei");
  System.out.println(lista.sisaltaa("hei"));
  lista.poista("hei");
  System.out.println(lista.sisaltaa("hei"));
<% end %>

<% partial 'partials/sample_output' do %>
  false
  true
  false
<% end %>


<% partial 'partials/material_sub_sub_heading' do %>
  Kohdasta hakeminen
<% end %>

<p>
  Lisätään listalle vielä metodi <code>public T arvo(int indeksi)</code>, joka palauttaa listan tietyssä indeksissä sijaitsevan arvon. Mikäli ohjelmoija hakee arvoa listan ulkopuolelta, heitetään virhe <code>IndexOutOfBoundsException</code>. 
</p>

<% partial 'partials/code_highlight' do %>
  public T arvo(int indeksi) {
      if (indeksi &lt; 0 || indeksi &gt;= this.arvoja) {
          throw new ArrayIndexOutOfBoundsException("Indeksi " + indeksi + " alueen [0, " + this.arvoja + "[ ulkopuolella.");
      }

      return this.arvot[indeksi];
  }
<% end %>

<p>
  Metodin käyttöä edesauttaisi, mikäli luokan käyttäjällä olisi tieto haettavien arvojen indekseistä. Muutetaan vielä metodi <code>arvonIndeksi(T arvo)</code> kaikkien käytettäväksi, eli vaihdetaan sen näkyvyysmääre <code>private</code> muotoon <code>public</code>.
</p>

<% partial 'partials/code_highlight' do %>
  public int arvonIndeksi(T arvo) {
      for (int i = 0; i &lt; this.arvoja; i++) {
          if (this.arvot[i].equals(arvo)) {
              return i;
          }
      }

      return -1;
  }
<% end %>


<% partial 'partials/code_highlight' do %>
  Lista&lt;String&gt; lista = new Lista&lt;&gt;();
  System.out.println(lista.sisaltaa("hei"));
  lista.lisaa("hei");
  System.out.println(lista.sisaltaa("hei"));
  int indeksi = lista.arvonIndeksi("hei");
  System.out.println(indeksi);
  System.out.println(lista.arvo(indeksi));
  lista.poista("hei");
  System.out.println(lista.sisaltaa("hei"));
<% end %>

<% partial 'partials/sample_output' do %>
  false
  true
  0
  hei
  false
<% end %>

<% partial 'partials/material_sub_sub_heading' do %>
  Listan koko
<% end %>

<p>
  Lisätään listalle vielä metodi listan koon tarkastamiseen. Listan koon saa selville muuttujasta <code>arvoja</code>. 
</p> 

<% partial 'partials/code_highlight' do %>
  public int koko() {
      return this.arvoja;
  }
<% end %>

<p>
  Nyt listan alkioiden läpikäynti onnistuu mm. for-lauseella.
</p>

<% partial 'partials/code_highlight' do %>
  Lista&lt;String&gt; lista = new Lista&lt;&gt;();
  lista.lisaa("hei");
  lista.lisaa("maailma");

  for(int i = 0; i &lt; lista.koko(); i++) {
      System.out.println(lista.arvo(i)); 
  }
<% end %>

<% partial 'partials/sample_output' do %>
  hei
  maailma
<% end %>


<% partial 'partials/exercise', locals: { name: 'Lista (3 osaa)' } do %>

  <p>
    TODO: vain listan toteutus
  </p>

<% end %>


<% partial 'partials/exercise', locals: { name: 'TODO: pino' } do %>
  <p>
    TODO: pino taulukon avulla
  </p>
<% end %>


<% partial 'partials/material_sub_heading' do %>
  Hajautustaulu
<% end %>

<p>
  Hajautustaulu on toteutettu taulukkona, missä jokainen alkio sisältää listan. Listalle tallennetaan (avain,arvo)-pareja. Käyttäjä voi hakea hajautustaulusta arvoja avaimen perusteella, ja toisaalta käyttäjä voi lisätä hajautustauluun avain-arvo -pareja. Kukin avain voi esiintyä hajautustaulussa korkeintaan kerran.
</p>

<p>
  Hajautustaulun toiminta perustuu avaimen hajautusarvoon. Kun hajautustauluun lisätään (avain,arvo)-pari, lasketaan avaimeen liittyvä hajautusarvo. Hajautusarvo määrää hajautustaulun sisäisen taulukon indeksin, missä olevaan listaan (avain,arvo)-pari lisätään.
</p>

<p>
  Hahmotellaan hajautustaulun toimintaa.
</p>


<% partial 'partials/material_sub_sub_heading' do %>
  Avain-arvo -pari
<% end %>

<p>
  Luodaan ensin avain-arvo -paria kuvaava luokka <code>Pari</code>. Haluamme tehdä hajautustaulusta mahdollisimman yleiskäyttöisen, joten avaimen ja arvon tyyppi määrätään ajonaikaisesti. Pari sisältää avaimen ja arvon sekä niihin liittyvät get-metodit. Geneeriset tyypit K ja V ovat nimetty sanojen key ja value perusteella.
</p>

<% partial 'partials/code_highlight' do %>
  public class Pari&lt;K, V&gt; {

      private K avain;
      private V arvo;

      public Pari(K avain, V arvo) {
          this.avain = avain;
          this.arvo = arvo;
      }

      public K getAvain() {
          return avain;
      }

      public V getArvo() {
          return arvo;
      }

      public void setArvo(V arvo) {
          this.arvo = arvo;
      }
  }
<% end %>

<p>
  Avain-arvo -parien luominen on suoraviivaista.
</p>

<% partial 'partials/code_highlight' do %>
  Pari&lt;String, Integer&gt; pari = new Pari&lt;&gt;("yksi", 1);
  System.out.println(pari.getAvain() + " -&gt; " + pari.getArvo());
<% end %>


<% partial 'partials/sample_output' do %>
  yksi -&gt; 1
<% end %>


<% partial 'partials/material_sub_sub_heading' do %>
  Hajautustaulun luominen
<% end %>

<p>
  Hajautustaulu sisältää taulukon listoja. Jokainen listan arvo on edellä kuvattu pari, joka sisältää avain-arvo -parin. Hajautustaululla on lisäksi tieto arvojen lukumäärästä. Tässä käytössämme on edellä luotu luokka <code>Lista</code>.
</p>

<% partial 'partials/code_highlight' do %>
  public class Hajautustaulu&lt;K, V&gt; {

      private Lista&lt;Pari&lt;K, V&gt;&gt;[] arvot;
      private int arvoja;

      public Hajautustaulu() {
          this.arvot = new Lista[32];
          this.arvoja = 0;
      }
  }
<% end %>


<% partial 'partials/material_sub_sub_heading' do %>
  Arvon hakeminen
<% end %>

<p>
  Toteutetaan ensin metodi <code>public V hae(K avain)</code>, jota käytetään arvon hakemiseen avaimen perusteella.
</p>

<p>
  Metodissa lasketaan ensin avaimen hajautusarvo ja päätellään sen perusteella hajautustaulun sisäisen taulukon indeksi, mistä arvoja haetaan. Avaimen hajautusarvon laskemiseen käytetään jokaisella oliolla olevaa <code>hashCode</code>-metodia. Jakojäännöstä käytetään hajautusarvon hajautustaulun koon sisällä pysymiseen. 
</p>
  
<p>
  Mikäli hajautusarvon ja jakojäänneksen avulla lasketussa indeksissä ei ole listaa, ei indeksiin ole lisätty vielä yhtäkään avain-arvo -paria, eikä avaimelle ole tallennettu arvoa. Tällöin palautetaan null-viite. Muussa tapauksessa taulukon indeksissä oleva lista käydään läpi, ja avaimen yhtäsuuruutta vertaillaan jokaiseen listan avain-arvo -parin avaimeen. Mikäli joku listalla olevista avaimista vastaa avainta, jonka perusteella arvoa haetaan, palautetaan kyseinen arvo. Muulloin avainta (ja siihen liittyvää arvoa) ei löydy, ja palautetaan arvo null.
</p>

<% partial 'partials/code_highlight' do %>
  public V hae(K avain) {
      int hajautusArvo = Math.abs(avain.hashCode() % this.arvot.length);
      if (this.arvot[hajautusArvo] == null) {
          return null;
      }
  
      Lista&lt;Pari&lt;K, V&gt;&gt; arvotIndeksissa = this.arvot[hajautusArvo];

      for (int i = 0; i &lt; arvotIndeksissa.koko(); i++) {
          if (arvotIndeksissa.arvo(i).getAvain().equals(avain)) {
              return arvotIndeksissa.arvo(i).getArvo();
          }
      }
  
      return null;
  }
<% end %>


<% partial 'partials/hint', locals: { name: 'Miksei hajautustaulua toteuteta listana?' } do %>

  <p>
    Hajautustaulun toimintaperiaate perustuu siihen, että avain-arvo -parit jaetaan hajautusarvon perusteella pieniin joukkoihin. Tällöin avaimen perusteella haettaessa käydään läpi vain hyvin pieni joukko avain-arvo -pareja -- olettaen toki, että hajautusarvo on järkevä.
  </p>

  <p>
    Jos hajautusarvo on aina sama -- esimerkiksi 1 -- vastaa hajautustaulun sisäinen toteutus listaa -- kaikki arvot ovat samalla listalla. Jos taas hajautusarvo on hyvin satunnainen, arvot hajautetaan mahdollisimman tasaisesti taulukon eri listoille.
  </p>

  <p>
    Hajautustaulu toimii lisäksi siten, että hajautustaulun käyttämää taulukkoa kasvatetaan mikäli arvojen määrä on tarpeeksi iso (tyypillisesti noin 75% taulukon koosta). Tyypillisesti miljoonia avain-arvo -pareja sisältävän hajautustaulun taulukon yhdessä indeksissä on vain muutama avain-arvo -pari. Tämä tarkoittaa käytännössä sitä, että avain-arvo -parin olemassaolon selvittämiseen tarvitaan vain hajautusarvon laskeminen sekä muutaman olion tarkastelu -- tämä on paljon nopeampaa kuin listan läpikäynti.
  </p>
  
<% end %>


<% partial 'partials/material_sub_sub_heading' do %>
  Hajautustauluun lisääminen, osa 1
<% end %>

<p>
  Toteutetaan hajautustauluun lisäämisen käytettävän metodin <code>public void lisaa(K avain, V arvo)</code> ensimmäinen versio. Ensimmäisessä versiossa hajautustaulun sisältämän taulukon kokoa ei kasvateta lisäyksen yhteydessä.
</p>

<p>
  Metodi laskee ensin avaimelle hajautusarvon ja päättelee hajautusarvon perusteella hajautustaulun sisäisen taulukon indeksin. Jos taulukon kyseisessä indeksissä ei ole arvoa, taulukon indeksiin lisätään lista. Tämän jälkeen taulukon indeksissä oleva lista käydään läpi ja sieltä etsitään avain-arvo -paria, jonka avain vastaa lisättävän avain-arvo -parin avainta. Mikäli vastaava avain löytyy, päivitetään olemassaolevan avain-arvo -parin arvo vastaamaan uutta avainta. Muulloin listaan lisätään uusi avain-arvo -pari -- tällöin myös hajautustaulussa olevien arvojen lukumäärää kasvatetaan yhdellä.
</p>

<% partial 'partials/code_highlight' do %>
  public void lisaa(K avain, V arvo) {
      int hajautusArvo = Math.abs(avain.hashCode() % arvot.length);
      if (arvot[hajautusArvo] == null) {
          arvot[hajautusArvo] = new Lista<>();
      }

      Lista&lt;Pari&lt;K, V&gt;&gt; arvotIndeksissa = arvot[hajautusArvo];

      int indeksi = -1;
      for (int i = 0; i &lt; arvotIndeksissa.koko(); i++) {
          if (arvotIndeksissa.arvo(i).getAvain().equals(avain)) {
              indeksi = i;
              break;
          }
      }

      if (indeksi &lt; 0) {
          arvotIndeksissa.lisaa(new Pari&lt;&gt;(avain, arvo));
          this.arvoja++;
      } else {
          arvotIndeksissa.arvo(indeksi).setArvo(arvo);
      }
  }
<% end %>

<p>
  Metodi on melko monimutkainen. Pilkotaan se pienempiin osiin -- ensimmäisen osan vastuulla on avaimeen liittyvän listan hakeminen ja toisen osan vastuulla on avaimen indeksin etsiminen listalta.
</p>

<% partial 'partials/code_highlight' do %>
  private Lista&lt;Pari&lt;K, V&gt;&gt; haeAvaimeenLittyvaLista(K avain) {
      int hajautusArvo = Math.abs(avain.hashCode() % arvot.length);
      if (arvot[hajautusArvo] == null) {
          arvot[hajautusArvo] = new Lista&lt;&gt;();
      }

      return arvot[hajautusArvo];
  }
  
  private int haeAvaimenIndeksi(Lista&lt;Pari&lt;K, V&gt;&gt; lista, K avain) {
      for (int i = 0; i &lt; lista.koko(); i++) {
          if (lista.arvo(i).getAvain().equals(avain)) {
              return i;
          }
      }

      return -1;
  }
<% end %>

<p>
  Nyt metodi <code>public void lisaa(K avain, V arvo)</code> voidaan toteuttaa hieman selkeämmin.
</p>

<% partial 'partials/code_highlight' do %>
  public void lisaa(K avain, V arvo) {
      Lista&lt;Pari&lt;K, V&gt;&gt; arvotIndeksissa = haeAvaimeenLittyvaLista(avain);
      int indeksi = haeAvaimenIndeksi(arvotIndeksissa, avain);
  
      if (indeksi &lt; 0) {
          arvotIndeksissa.lisaa(new Pari&lt;&gt;(avain, arvo));
          this.arvoja++;
      } else {
          arvotIndeksissa.arvo(indeksi).setArvo(arvo);
      }
  }
<% end %>


<% partial 'partials/material_sub_sub_heading' do %>
  Hajautustauluun lisääminen, osa 2
<% end %>

<p>
  Edellä kuvattu hajautustauluun lisääminen toimii osittain. Toiminnallisuuden suurin puute on se, että taulukon kokoa ei kasvateta kun arvojen määrä kasvaa liian suureksi. Lisätään ohjelmaan kasvatustoiminnallisuus, mikä tuplaa hajautustaulun sisäisen taulukon koon. Kasvatustoiminnallisuuden tulee myös sijoittaa jokainen hajautustaulussa olevan taulukon arvo uuteen taulukkoon.
</p>

<p>
  Hahmotellaan kasvatustoiminnallisuuden alku. Kasvatustoiminnallisuudessa luodaan uusi taulukko, jonka koko on edelliseen verrattuna kaksinkertainen. Tämän jälkeen alkuperäinen taulukko käydään indeksi indeksiltä läpi ja olemassaolevat avain-arvo -parit kopioidaan uuteen taulukkoon. Lopulta alkuperäinen taulukko korvataan uudella taulukolla.
</p>

<p>
  Alla on hahmoteltu metodin toimintaa. Kopiointia ei ole vielä toteutettu.
</p>

<% partial 'partials/code_highlight' do %>
  private void kasvata() {
      // luodaan uusi taulukko
      Lista&lt;Pari&lt;K, V&gt;&gt;[] uusi = new Lista[this.arvot.length * 2];

      for (int i = 0; i &lt; this.arvot.length; i++) {
          // kopioidaan vanhan taulukon arvot uuteen

      }

      // korvataan vanha taulukko uudella
      this.arvot = uusi;
  }
<% end %>

<p>
  Hahmotellaan seuraavaksi metodia, joka kopioi alkuperäisen taulukon yhden indeksin sisältämän listan arvot uuteen taulukkoon. Kopioinnin yhteydessä jokaisen kopioitavan avain-arvo -parin sijainti taulukossa lasketaan uudelleen -- tämä tehdään, sillä taustalla olevan taulukon koko kasvaa ja avain-arvot -parit halutaan sijoittaa taulukkoon mahdollisimman tasaisesti.
</p>

<% partial 'partials/code_highlight' do %>
  private void kopioi(Lista&lt;Pari&lt;K, V&gt;&gt;[] uusi, int indeksista) {
      for (int i = 0; i &lt; this.arvot[indeksista].koko(); i++) {
          Pari&lt;K, V&gt; arvo = this.arvot[indeksista].arvo(i);
  
          int hajautusarvo = Math.abs(arvo.getAvain().hashCode() % uusi.length);
          if(uusi[hajautusarvo] == null) {
              uusi[hajautusarvo] = new Lista&lt;&gt;();
          }
  
          uusi[hajautusarvo].lisaa(arvo);
      }
  }
<% end %>

<p>
  Nyt kopioi-metodia voidaan kutsua kasvata-metodista.
</p>


<% partial 'partials/code_highlight' do %>
  private void kasvata() {
      // luodaan uusi taulukko
      Lista&lt;Pari&lt;K, V&gt;&gt;[] uusi = new Lista[this.arvot.length * 2];

      for (int i = 0; i &lt; this.arvot.length; i++) {
          // kopioidaan vanhan taulukon arvot uuteen
          kopioi(uusi, indeksista);
      }

      // korvataan vanha taulukko uudella
      this.arvot = uusi;
  }
<% end %>

<p>
  Lisätään lopuksi kasvatustoiminnallisuus osaksi lisäystoiminnallisuutta. Hajautustaulun kokoa kasvatetaan aina jos hajautustaulussa olevien avain-arvo -parien määrä on yli 75% taulukon koosta.
</p>

<% partial 'partials/code_highlight' do %>
  public void lisaa(K avain, V arvo) {
      Lista&lt;Pari&lt;K, V&gt;&gt; arvotIndeksissa = haeAvaimeenLittyvaLista(avain);
      int indeksi = haeAvaimenIndeksi(arvotIndeksissa, avain);

      if (indeksi &lt; 0) {
          arvotIndeksissa.lisaa(new Pari&lt;&gt;(avain, arvo));
          this.arvoja++;
      } else {
          arvotIndeksissa.arvo(indeksi).setArvo(arvo);
      }

      if (1.0 * this.arvoja / this.arvot.length &gt; 0.75) {
          kasvata();
      }
  }
<% end %>



<% partial 'partials/material_sub_sub_heading' do %>
  Poistaminen
<% end %>

<p>
  Lisätään hajautustauluun vielä toiminnallisuus avain-arvo -parin poistamiseen avaimen perusteella. Poistotoiminnallisuus palauttaa null-arvon mikäli arvoa ei löydy, muuten metodi palauttaa poistettavaan avaimeen liittyvän arvon.
</p>

<p>
  Voimme hyödyntää valmiiksi toteuttamiamme metodeja poistotoiminnallisuudessa. Selitä itsellesi (ääneen) alla olevan metodin konkreettinen toiminta.
</p>


<% partial 'partials/code_highlight' do %>
  public V poista(K avain) {
      Lista&Lt;Pari&lt;K, V&gt;&gt; arvotIndeksissa = haeAvaimeenLittyvaLista(avain);
      if (arvotIndeksissa.koko() == 0) {
          return null;
      }

      int indeksi = haeAvaimenIndeksi(arvotIndeksissa, avain);
      if (indeksi &lt; 0) {
          return null;
      }

      Pari&lt;K, V&gt; pari = arvotIndeksissa.arvo(indeksi);
      arvotIndeksissa.poista(pari);
      return pari.getArvo();
  }
<% end %>


<% partial 'partials/exercise', locals: { name: 'Lista ja hajautustaulu (3 osaa)' } do %>

  <p>
    TODO: hajautustaulun toteutus, mutta siten, että itse toteutetun listan sijaan käytetään Javan ArrayListiä.
  </p>

  <p>
    Toteuta edellistä esimerkkiä noudattaen luokat Lista ja Hajautustaulu pakkaukseen <code>tietorakenteita</code>. Kohdat on pisteytetty askeleittain, jotka ovat seuraavat:
  </p>

  <h2>Lista</h2>
  
  <ol>
    <li>
      Listan luominen
    </li>
    <li>
      Arvojen lisääminen listalle (osat 1 ja 2)
    </li>
    <li>
      Listalla olevan arvon olemassaolon tarkastaminen
    </li>
    <li>
      Listalla olevan arvon poistaminen
    </li>
    <li>
      Listan indeksistä hakeminen ja listan koko
    </li>
  </ol>

  <h2>Hajautustaulu, osa 1</h2>
  
  <ol>
    <li>
      Avain-arvo -paria kuvaavan luokan toteutus
    </li>
    <li>
      Hajautustaulun luominen
    </li>
    <li>
      Arvon hakeminen hajautustaulusta
    </li>
    <li>
      Hajautustauluun lisääminen (ei kasvatusta)
    </li>
  </ol>

  <h2>Hajautustaulu, osa 2</h2>

  <ol>
    <li>
      Hajautustaulun koon kasvattaminen tarvittaessa
    </li>
    <li>
      Hajautustaulusta poistaminen
    </li>
  </ol>
  
  <p>
    Sitä mukaa kun kehität listaa ja hajautustaulua, päivitä luokan Ohjelma metodia <code>osiaToteutettu</code> palauttamaan valmiiksi saamasi osan numero. Voit palauttaa tehtävän vaikket tekisikään kaikkia osia, jolloin saat pisteitä tehtävän niistä osista, jotka olet tehnyt.
  </p>

  <p>
    Esimerkiksi, kun olet saanut listan luomisen, arvojen lisäämisen ja arvon poistamisen toimimaan, olet vaiheessa 3, jolloin metodin <code>osiaToteutettu</code> tulisi palautta arvo <code>3</code>.
  </p>
  
<% end %>


<% partial 'partials/material_sub_heading' do %>
  Hakemisen tehokkuudesta
<% end %>

<p>
  Tarkastellaan vielä hakemisen tehokkuutta listasta ja hajautustaulusta. Tehokkuusmittauksia voi tehdä metodin <code>System.nanotime()</code> palauttaman nanosekunteja kuvaavan arvon avulla. Ohjelma luo ensin miljoona alkiota hajautustauluun ja listaan, jonka jälkeen hajautustaulusta ja listasta etsitään tuhatta satunnaista arvoa. Noin 50% arvoista löytyy listalta ja hajautustaulusta.
</p>

<% partial 'partials/code_highlight' do %>
  Lista&lt;String&gt; lista = new Lista&lt;&gt;();
  Hajautustaulu&lt;String, String&gt; taulu = new Hajautustaulu&lt;&gt;();

  for (int i = 0; i &lt; 1000000; i++) {
      lista.lisaa("" + i);
      taulu.lisaa("" + i, "" + i);
  }

  Lista&lt;String&gt; haettavat = new Lista&lt;&gt;();
  Random arpoja = new Random();
  for (int i = 0; i &lt; 1000; i++) {
      haettavat.lisaa("" + arpoja.nextInt(2000000));
  }

  long listanHakuAloitus = System.nanoTime();
  for (int i = 0; i &lt; haettavat.koko(); i++) {
      lista.sisaltaa(haettavat.arvo(i));            
  }
  long listanHakuLopetus = System.nanoTime();
  
  long hajautustaulunHakuAloitus = System.nanoTime();
  for (int i = 0; i &lt; haettavat.koko(); i++) {
      taulu.hae(haettavat.arvo(i));            
  }
  long hajautustaulunHakuLopetus = System.nanoTime();

  
  long listanHaku = listanHakuLopetus - listanHakuAloitus;
  System.out.println("Lista: haku kesti noin " + listanHaku / 1000000 + " millisekuntia (" +
      listanHaku + " nanosekuntia.)");
  
  long hajautustaulunHaku = hajautustaulunHakuLopetus - hajautustaulunHakuAloitus;
  System.out.println("Hajautustaulu: haku kesti noin " + hajautustaulunHaku / 1000000 +
      " millisekuntia (" + hajautustaulunHaku + " nanosekuntia.)");
<% end %>


<% partial 'partials/code_highlight' do %>
  Lista: haku kesti noin 6284 millisekuntia (6284420580 nanosekuntia.)
  Hajautustaulu: haku kesti noin 0 millisekuntia (805106 nanosekuntia.)
<% end %>

<p>
  <em>
    Edellä kuvatut ja kursseilla käyttämämme listat ja hajautustaulut poikkeavat toki sisäiseltä toteutukselta hieman toisistaan. Ohjelmointikielten tarjoamissa tietorakenteissa on hieman enemmän erilaisia optimointeja -- näihinkin palataan myöhemmillä kursseilla. Tämän kurssin puitteissa riittää em. tietorakenteiden käyttöosaaminen sekä jonkintasoinen ymmärrys niiden tehokkuuseroista sekä käyttötapauksista.
  </em>
</p>


<% partial 'partials/material_heading' do %>
  Moniulotteinen tieto
<% end %>

<p>
  Aiemmat taulukkoesimerkkimme ovat käsitelleet yksiulotteisia taulukoita, missä indeksi kertoo sijainnin yhdessä ulottuvuudessa. Taulukon voi luoda myös useampiulotteisena, jolloin taulukossa olevaa tietoa voi tarkastella useamman indeksin avulla. Tämä on kätevää esimerkiksi silloin, jos tieto on useampiulotteista kuten esimerkiksi koordinaatistossa.
</p>

<p>
  Kaksiulotteinen taulukko, jossa on kaksi riviä ja kolme saraketta, luodaan seuraavasti:
</p>

<% partial 'partials/code_highlight' do %>
  int rivit = 2;
  int sarakkeet = 3;
  int[][] kaksiulotteinenTaulukko = new int[rivit][sarakkeet];
<% end %>

<p>
  Yllä luomme taulukon, jonka jokainen rivi viittaa taulukkoon, jossa on tietty määrä sarakkeita. Kaksiulotteisen taulukon läpikäynti onnistuu kahden sisäkkäisen while-toistolauseen avulla seuraavasti:
</p>

<% partial 'partials/code_highlight' do %>
  int rivit = 2;
  int sarakkeet = 3;
  int[][] kaksiulotteinenTaulukko = new int[rivit][sarakkeet];

  for (int y = 0; y &lt; kaksiulotteinenTaulukko.length; y++) {
      for (int x = 0; x &lt; kaksiulotteinenTaulukko[y].length; x++) {
          int arvo = kaksiulotteinenTaulukko[y][x];
          System.out.println("arvo kohdassa (" + x + ", " + y + "): " + arvo);
      }
  }
<% end %>

<p>
  Ylläolevan ohjelman tulostus on seuraava.
</p>

<% partial 'partials/sample_output' do %>
  arvo kohdassa (0, 0): 0
  arvo kohdassa (1, 0): 0
  arvo kohdassa (2, 0): 0
  arvo kohdassa (0, 1): 0
  arvo kohdassa (1, 1): 0
  arvo kohdassa (2, 1): 0
<% end %>

<p>
  Saatoit yllättyä. Selityksenä tulostukselle on se, että int-tyyppisten muuttujien oletusarvo on 0.
</p>

<p>
  Voimme muuttaa taulukon arvoja kuten ennenkin. Alla asetamme kahteen kohtaan uudet arvot.
</p>

<% partial 'partials/code_highlight' do %>
  int rivit = 2;
  int sarakkeet = 3;
  int[][] kaksiulotteinenTaulukko = new int[rivit][sarakkeet];

  kaksiulotteinenTaulukko[0][1] = 4;
  kaksiulotteinenTaulukko[1][1] = 1;
  kaksiulotteinenTaulukko[1][0] = 8;


  for (int y = 0; y &lt; kaksiulotteinenTaulukko.length; y++) {
      for (int x = 0; x &lt; kaksiulotteinenTaulukko[y].length; x++) {
          int arvo = kaksiulotteinenTaulukko[y][x];
          System.out.println("arvo kohdassa (" + x + ", " + y + "): " + arvo);
      }
  }
<% end %>

<p>
  Nyt tulostus näyttää seuraavalta:
</p>

<% partial 'partials/sample_output' do %>
  arvo kohdassa (0, 0): 0
  arvo kohdassa (1, 0): 4
  arvo kohdassa (2, 0): 0
  arvo kohdassa (0, 1): 8
  arvo kohdassa (1, 1): 1
  arvo kohdassa (2, 1): 0
<% end %>

<p>
  QUIZEJA: mitä ohjelma tulostaa

</p>

<p>
  Kaksiulotteinen taulukko on oikeastaan <a href="https://fi.wikipedia.org/wiki/Matriisi" target="_blank" rel="noopener">matriisi</a>.  Matriiseja käytetään muunmuassa tietokonegrafiikassa, missä yksittäiset pikselit esitetään matriisin avulla.
</p>


<% partial 'partials/exercise', locals: { name: 'Piirto-ohjelma' } do %>

  <p>
    Tehtäväpohjaan on toteutettu graafinen sovellus, mikä sisältää kaksiulotteisen taulukon. Tehtävänäsi on muuttaa sovelluksen toimintaa siten, että kun käyttäjä painaa hiirtä sovelluksessa tai liikuttaa hiirtä kun nappi on pohjassa, ikkunaan piirretään.
  </p>

  <p>
    Tee tätä varten kaksi asiaa: (1) muuta sovelluksessa olevan taulukon "piirrettava" arvoja sopivasti kun käyttäjä käyttää hiirtä, ja (2) piirrä komentoa <code>piirturi(x, y, 2, 2)</code> käyttäen ne alkiot, joiden arvo on 1. Käytä koordinaatteina x, y taulukon indeksejä.
  </p>

  <p>
    Kun sovellus toimii, voit käyttää sitä vaikkapa seuraavanlaisen taideteoksen tekemiseen. Tehtävässä ei ole testejä.
  </p>

  <img src="/img/exercises/06-14-piirturi-ok.png" />


<% end %>



<% partial 'partials/material_sub_heading' do %>
  Simulaatiot
<% end %>

<p>
  luodaan kaksi taulukkoa, joista toinen on aina se näytettävä
</p>


<% partial 'partials/exercise', locals: { name: 'Game of Life (2 osaa)' } do %>

  <p>
    Toteutimme aiemmin Game of Life -pelin logiikan sisäkkäisiä hajautustauluja käyttäen. Tarkastellaan nyt samaa kaksiulotteisten taulukkojen avulla.
  </p>
  
  <p>
    <a href="https://en.wikipedia.org/wiki/Conway's_Game_of_Life" target="_blank">Game of Life</a> on neljää yksinkertaista sääntöä seuraava soluautomaatti:
  </p>

  <ol>
    <li>Jos elävän solun naapureina on alle kaksi elävää solua, se kuolee alikansoituksen takia.</li>
    <li>Jos elävän solun naapureina on kaksi tai kolme elävää solua, se jää henkiin.</li>
    <li>Jos elävän solun naapureina on yli kolme elävää solua, se kuolee ylikansoituksen takia.</li>
    <li>Jos kuolleen solun naapureina on tasan kolme elävää solua, se syntyy eli muuttuu eläväksi.</li>
  </ol>

  <p>
    Peli ei sisällä minkäänlaisia liikkumissääntöjä, mutta se silti luo tilanteita, missä erilaiset hahmot liikkuvat ruudulla. Katso pelin keksineen <a href="https://youtu.be/E8kUJL04ELA" target="_blank">John Conwayn mietteitä pelistä sekä sääntöjen selitys</a>.
  </p>

  <p>
    Tässä tehtävässä toteutetaan oleellisilta osin Game of Life-pelin säännöt. Toteutusta varten tehtäväpohjassa on luokka GameOfLife, joka sisältää kaksiulotteisen taulukon, sekä luokka GameOfLifeSovellus, jota voidaan käyttää pelin visualisointiin.
  </p>

  <h2>Elossa olevien naapurien lukumäärä</h2>

  <p>
    Täydennä luokassa GameOfLife olevaa metodia <code>public int elossaOleviaNaapureita(int[][] taulukko, int x, int y)</code> siten, että se laskee annetun x, y -koordinaatin elossa olevien naapureiden lukumäärän. Naapuri on elossa jos sen arvo on 1.
  </p>

  <p>
    Naapureita ovat kaikki ne alkiot, jotka ovat kulman tai sivun kautta yhteydessä alkioon.
  </p>

  <p>
    Huomaa, että metodin tulee varoa ArrayIndexOutOfBounds-virhettä. Indeksissä -1 ei esimerkiksi voi olla ketään. Vastaavasti taulukon leveyden tai korkeuden yli ei voi mennä (esim. <code>taulukko[taulukko.length][0]</code> tai <code>taulukko[0][taulukko[0].length]</code>).
  </p>

  <p>
    Voit kokeilla metodiasi muunmuassa seuraavilla esimerkeillä.
  </p>

  <% partial 'partials/code_highlight' do %>
    GameOfLife gol = new GameOfLife(3, 3);

    int[][] taulukko = new int[3][3];
    taulukko[0][0] = 1;
    taulukko[0][1] = 1;
    taulukko[1][1] = 1;
    taulukko[2][2] = 1;

    System.out.println(gol.elossaOleviaNaapureita(taulukko, 0, 0));
    System.out.println(gol.elossaOleviaNaapureita(taulukko, 1, 0));
    System.out.println(gol.elossaOleviaNaapureita(taulukko, 1, 1));
    System.out.println(gol.elossaOleviaNaapureita(taulukko, 2, 2));
  <% end %>

  <% partial 'partials/sample_output' do %>
    2
    3
    3
    1
  <% end %>

  <% partial 'partials/code_highlight' do %>
    GameOfLife gol = new GameOfLife(4, 4);

    int[][] taulukko = {{1, 1, 1, 1}, {1, 1, 1, 1}, {1, 0, 1, 0}, {0, 1, 0, 1}};

    System.out.println(gol.elossaOleviaNaapureita(taulukko, 0, 0));
    System.out.println(gol.elossaOleviaNaapureita(taulukko, 1, 1));
    System.out.println(gol.elossaOleviaNaapureita(taulukko, 2, 2));
    System.out.println(gol.elossaOleviaNaapureita(taulukko, 3, 3));
  <% end %>

  <% partial 'partials/sample_output' do %>
    3
    7
    5
    1
  <% end %>


  <h2>Kehittyminen</h2>


  <p>
    Täydennä seuraavaksi GameOfLife-luokan metodia <code>public void kehity()</code> siten, että se käy yhden Game of Life -pelin askeleen.
  </p>

  <p>
    Toteuta toiminnallisuus niin, että luot toisen taulukon, jonka koko on sama kuin alkuperäisen taulukon. Käy tämän jälkeen alkuperäistä taulukkoa läpi alkio alkiolta siten, että seuraat seuraavia sääntöjä:
  </p>

  <ol>
    <li>Jos alkuperäisen taulukon alkion arvo on 1 ja sillä on alle kaksi elävää naapuria, kopioon asetetaan alkion arvoksi 0.</li>
    <li>Jos alkuperäisen taulukon alkion arvo on 1 ja sillä on kaksi tai kolme elävää naapuria, kopioon asetetaan alkion arvoksi 1.</li>
    <li>Jos alkuperäisen taulukon alkion arvo on 1 ja sillä on yli kolme elävää naapuria, kopioon asetetaan alkion arvoksi 0.</li>
    <li>Jos alkuperäisen taulukon alkion arvo on 0 ja sillä on tasan kolme elävää naapuria, kopioon asetetaan alkion arvoksi 1.</li>
  </ol>

  <p>
    Käytä naapureiden lukumäärän selvittämisessä edellisessä osassa tehtyä metodia. Kun olet käynyt koko taulukon läpi, vaihda kopio taulukon paikalle.
  </p>


  <p>
    Kokeile tämän jälkeen sovelluksen toimintaa graafisen käyttöliittymän kautta. Sovelluksen pitäisi käynnistyä -- yksi mahdollinen hetkellinen tila on seuraavanlainen.
  </p>

  <img src="/img/exercises/06-15-gameoflife.png" width="600"/>
  
<% end %>



<% partial 'partials/hint', locals: { name: 'Taulukko vs. Hajautustaulu' } do %>

  <p>
    Taulukon toiminnallisuutta vastaavan toiminnallisuuden pystyy toteuttamaan hajautustaulun avulla. Eikö hajautustaulun käyttö olisi yleisesti ottaen parempi vaihtoehto, sillä sitä ei esimerkiksi tarvitse kasvattaa lainkaan?
  </p>

  <p>
    Kun hajautustaulusta haetaan tietoa tietyllä avaimella, metodin hashCode perusteella selvitetään paikka, mistä tietoa haetaan. Samassa paikassa voi olla useampi arvo (listassa), jolloin haettavaa avainta verrataan jokaiseen listalla olevaan arvoon equals-metodia käyttäen. Kun taulukosta haetaan arvoa tietyllä avaimella -- eli indeksillä -- ei vastaavaa toiminnallisuutta tarvitse tehdä. Taulukossa joko on arvo tai arvoa ei ole. Taulukkoon liittyy pieni tehokkuushyöty ohjelman suorituskyvyn kannalta.
  </p>

  <p>
    Tämä tehokkuushyöty kuitenkin tulee lisääntyneen virhealttiuden sekä työmäärän kustannuksella. Hajautustauluun on valmiiksi toteutettuna sisäisen taulukon kasvattaminen ja sen toiminnallisuutta on testattu hyvin laajasti. Taulukkoa käytettäessä tällaista etua ei ole -- uutta toiminnallisuutta toteuttaessa saattaa päätyä virheisiin, mikä kasvattaa työmäärää. Virheet ovat toki luonnollinen osa ohjelmistokehitystä.
  </p>

  <p>
    Kun ajattelemme muistin käyttöä, hajautustaululla voi olla -- tapauksesta riippuen -- pieni etu. Kun taulukko luodaan, muistista varataan heti tila koko taulukolle. Mikäli taulukon jokaiseen indeksiin ei tarvitse lisätä tietoa, on osa tästä tiedosta varattuna turhaan. Hajautustaululla taas tällaista muistin varaamista ei ennakkoon tehdä -- hajautustaulun kokoa kasvatetaan tarvittaessa.
  </p>
  
<% end %>


<% partial 'partials/exercise', locals: { name: 'Miinaharava' } do %>

  <p>
    TODO:
  </p>

<% end %>



<div class="code-states-visualizer-widget" data-input='{"code":"public class Esimerkki {\n    public static void main(String[] args) {\n        int rivit = 2;\n        int sarakkeet = 3;\n        int[][] taulukko = new int[rivit][sarakkeet];\n\n        taulukko[0][1] = 4;\n        taulukko[1][1] = 1;\n        taulukko[1][0] = 8;\n\n        for (int y = 0; y < taulukko.length; y++) {\n            for (int x = 0; x < taulukko[y].length; x++) {\n                int arvo = taulukko[y][x];\n                System.out.println(\"(\" + x + \", \" + y + \"): \" + arvo);\n            }\n        }\n    }\n}","stdin":"","trace":[{"stdout":"","event":"call","line":3,"stack_to_render":[{"func_name":"main:3","encoded_locals":{},"ordered_varnames":[],"parent_frame_id_list":[],"is_highlighted":true,"is_zombie":false,"is_parent":false,"unique_hash":"1","frame_id":1}],"globals":{},"ordered_globals":[],"func_name":"main","heap":{}},{"stdout":"","event":"step_line","line":3,"stack_to_render":[{"func_name":"main:3","encoded_locals":{},"ordered_varnames":[],"parent_frame_id_list":[],"is_highlighted":true,"is_zombie":false,"is_parent":false,"unique_hash":"2","frame_id":2}],"globals":{},"ordered_globals":[],"func_name":"main","heap":{}},{"stdout":"","event":"step_line","line":4,"stack_to_render":[{"func_name":"main:4","encoded_locals":{"rivit":2},"ordered_varnames":["rivit"],"parent_frame_id_list":[],"is_highlighted":true,"is_zombie":false,"is_parent":false,"unique_hash":"4","frame_id":4}],"globals":{},"ordered_globals":[],"func_name":"main","heap":{}},{"stdout":"","event":"step_line","line":5,"stack_to_render":[{"func_name":"main:5","encoded_locals":{"rivit":2,"sarakkeet":3},"ordered_varnames":["rivit","sarakkeet"],"parent_frame_id_list":[],"is_highlighted":true,"is_zombie":false,"is_parent":false,"unique_hash":"7","frame_id":7}],"globals":{},"ordered_globals":[],"func_name":"main","heap":{}},{"stdout":"","event":"step_line","line":7,"stack_to_render":[{"func_name":"main:7","encoded_locals":{"rivit":2,"sarakkeet":3,"taulukko":["REF",143]},"ordered_varnames":["rivit","sarakkeet","taulukko"],"parent_frame_id_list":[],"is_highlighted":true,"is_zombie":false,"is_parent":false,"unique_hash":"12","frame_id":12}],"globals":{},"ordered_globals":[],"func_name":"main","heap":{"143":["LIST",["REF",145],["REF",146]],"145":["LIST",0,0,0],"146":["LIST",0,0,0]}},{"stdout":"","event":"step_line","line":8,"stack_to_render":[{"func_name":"main:8","encoded_locals":{"rivit":2,"sarakkeet":3,"taulukko":["REF",143]},"ordered_varnames":["rivit","sarakkeet","taulukko"],"parent_frame_id_list":[],"is_highlighted":true,"is_zombie":false,"is_parent":false,"unique_hash":"19","frame_id":19}],"globals":{},"ordered_globals":[],"func_name":"main","heap":{"143":["LIST",["REF",145],["REF",146]],"145":["LIST",0,4,0],"146":["LIST",0,0,0]}},{"stdout":"","event":"step_line","line":9,"stack_to_render":[{"func_name":"main:9","encoded_locals":{"rivit":2,"sarakkeet":3,"taulukko":["REF",143]},"ordered_varnames":["rivit","sarakkeet","taulukko"],"parent_frame_id_list":[],"is_highlighted":true,"is_zombie":false,"is_parent":false,"unique_hash":"26","frame_id":26}],"globals":{},"ordered_globals":[],"func_name":"main","heap":{"143":["LIST",["REF",145],["REF",146]],"145":["LIST",0,4,0],"146":["LIST",0,1,0]}},{"stdout":"","event":"step_line","line":11,"stack_to_render":[{"func_name":"main:11","encoded_locals":{"rivit":2,"sarakkeet":3,"taulukko":["REF",143]},"ordered_varnames":["rivit","sarakkeet","taulukko"],"parent_frame_id_list":[],"is_highlighted":true,"is_zombie":false,"is_parent":false,"unique_hash":"33","frame_id":33}],"globals":{},"ordered_globals":[],"func_name":"main","heap":{"143":["LIST",["REF",145],["REF",146]],"145":["LIST",0,4,0],"146":["LIST",8,1,0]}},{"stdout":"","event":"step_line","line":11,"stack_to_render":[{"func_name":"main:11","encoded_locals":{"y":0,"rivit":2,"sarakkeet":3,"taulukko":["REF",143]},"ordered_varnames":["rivit","sarakkeet","taulukko","y"],"parent_frame_id_list":[],"is_highlighted":true,"is_zombie":false,"is_parent":false,"unique_hash":"36","frame_id":36}],"globals":{},"ordered_globals":[],"func_name":"main","heap":{"143":["LIST",["REF",145],["REF",146]],"145":["LIST",0,4,0],"146":["LIST",8,1,0]}},{"stdout":"","event":"step_line","line":12,"stack_to_render":[{"func_name":"main:12","encoded_locals":{"y":0,"rivit":2,"sarakkeet":3,"taulukko":["REF",143]},"ordered_varnames":["rivit","sarakkeet","taulukko","y"],"parent_frame_id_list":[],"is_highlighted":true,"is_zombie":false,"is_parent":false,"unique_hash":"40","frame_id":40}],"globals":{},"ordered_globals":[],"func_name":"main","heap":{"143":["LIST",["REF",145],["REF",146]],"145":["LIST",0,4,0],"146":["LIST",8,1,0]}},{"stdout":"","event":"step_line","line":12,"stack_to_render":[{"func_name":"main:12","encoded_locals":{"x":0,"y":0,"rivit":2,"sarakkeet":3,"taulukko":["REF",143]},"ordered_varnames":["rivit","sarakkeet","taulukko","y","x"],"parent_frame_id_list":[],"is_highlighted":true,"is_zombie":false,"is_parent":false,"unique_hash":"43","frame_id":43}],"globals":{},"ordered_globals":[],"func_name":"main","heap":{"143":["LIST",["REF",145],["REF",146]],"145":["LIST",0,4,0],"146":["LIST",8,1,0]}},{"stdout":"","event":"step_line","line":13,"stack_to_render":[{"func_name":"main:13","encoded_locals":{"x":0,"y":0,"rivit":2,"sarakkeet":3,"taulukko":["REF",143]},"ordered_varnames":["rivit","sarakkeet","taulukko","y","x"],"parent_frame_id_list":[],"is_highlighted":true,"is_zombie":false,"is_parent":false,"unique_hash":"49","frame_id":49}],"globals":{},"ordered_globals":[],"func_name":"main","heap":{"143":["LIST",["REF",145],["REF",146]],"145":["LIST",0,4,0],"146":["LIST",8,1,0]}},{"stdout":"","event":"step_line","line":14,"stack_to_render":[{"func_name":"main:14","encoded_locals":{"arvo":0,"x":0,"y":0,"rivit":2,"sarakkeet":3,"taulukko":["REF",143]},"ordered_varnames":["rivit","sarakkeet","taulukko","y","x","arvo"],"parent_frame_id_list":[],"is_highlighted":true,"is_zombie":false,"is_parent":false,"unique_hash":"56","frame_id":56}],"globals":{},"ordered_globals":[],"func_name":"main","heap":{"143":["LIST",["REF",145],["REF",146]],"145":["LIST",0,4,0],"146":["LIST",8,1,0]}},{"stdout":"(0, 0): 0\n","event":"step_line","line":12,"stack_to_render":[{"func_name":"main:12","encoded_locals":{"x":0,"y":0,"rivit":2,"sarakkeet":3,"taulukko":["REF",143]},"ordered_varnames":["rivit","sarakkeet","taulukko","y","x"],"parent_frame_id_list":[],"is_highlighted":true,"is_zombie":false,"is_parent":false,"unique_hash":"59","frame_id":59}],"globals":{},"ordered_globals":[],"func_name":"main","heap":{"143":["LIST",["REF",145],["REF",146]],"145":["LIST",0,4,0],"146":["LIST",8,1,0]}},{"stdout":"(0, 0): 0\n","event":"step_line","line":12,"stack_to_render":[{"func_name":"main:12","encoded_locals":{"x":1,"y":0,"rivit":2,"sarakkeet":3,"taulukko":["REF",143]},"ordered_varnames":["rivit","sarakkeet","taulukko","y","x"],"parent_frame_id_list":[],"is_highlighted":true,"is_zombie":false,"is_parent":false,"unique_hash":"60","frame_id":60}],"globals":{},"ordered_globals":[],"func_name":"main","heap":{"143":["LIST",["REF",145],["REF",146]],"145":["LIST",0,4,0],"146":["LIST",8,1,0]}},{"stdout":"(0, 0): 0\n","event":"step_line","line":13,"stack_to_render":[{"func_name":"main:13","encoded_locals":{"x":1,"y":0,"rivit":2,"sarakkeet":3,"taulukko":["REF",143]},"ordered_varnames":["rivit","sarakkeet","taulukko","y","x"],"parent_frame_id_list":[],"is_highlighted":true,"is_zombie":false,"is_parent":false,"unique_hash":"67","frame_id":67}],"globals":{},"ordered_globals":[],"func_name":"main","heap":{"143":["LIST",["REF",145],["REF",146]],"145":["LIST",0,4,0],"146":["LIST",8,1,0]}},{"stdout":"(0, 0): 0\n","event":"step_line","line":14,"stack_to_render":[{"func_name":"main:14","encoded_locals":{"arvo":4,"x":1,"y":0,"rivit":2,"sarakkeet":3,"taulukko":["REF",143]},"ordered_varnames":["rivit","sarakkeet","taulukko","y","x","arvo"],"parent_frame_id_list":[],"is_highlighted":true,"is_zombie":false,"is_parent":false,"unique_hash":"74","frame_id":74}],"globals":{},"ordered_globals":[],"func_name":"main","heap":{"143":["LIST",["REF",145],["REF",146]],"145":["LIST",0,4,0],"146":["LIST",8,1,0]}},{"stdout":"(0, 0): 0\n(1, 0): 4\n","event":"step_line","line":12,"stack_to_render":[{"func_name":"main:12","encoded_locals":{"x":1,"y":0,"rivit":2,"sarakkeet":3,"taulukko":["REF",143]},"ordered_varnames":["rivit","sarakkeet","taulukko","y","x"],"parent_frame_id_list":[],"is_highlighted":true,"is_zombie":false,"is_parent":false,"unique_hash":"79","frame_id":79}],"globals":{},"ordered_globals":[],"func_name":"main","heap":{"143":["LIST",["REF",145],["REF",146]],"145":["LIST",0,4,0],"146":["LIST",8,1,0]}},{"stdout":"(0, 0): 0\n(1, 0): 4\n","event":"step_line","line":12,"stack_to_render":[{"func_name":"main:12","encoded_locals":{"x":2,"y":0,"rivit":2,"sarakkeet":3,"taulukko":["REF",143]},"ordered_varnames":["rivit","sarakkeet","taulukko","y","x"],"parent_frame_id_list":[],"is_highlighted":true,"is_zombie":false,"is_parent":false,"unique_hash":"80","frame_id":80}],"globals":{},"ordered_globals":[],"func_name":"main","heap":{"143":["LIST",["REF",145],["REF",146]],"145":["LIST",0,4,0],"146":["LIST",8,1,0]}},{"stdout":"(0, 0): 0\n(1, 0): 4\n","event":"step_line","line":13,"stack_to_render":[{"func_name":"main:13","encoded_locals":{"x":2,"y":0,"rivit":2,"sarakkeet":3,"taulukko":["REF",143]},"ordered_varnames":["rivit","sarakkeet","taulukko","y","x"],"parent_frame_id_list":[],"is_highlighted":true,"is_zombie":false,"is_parent":false,"unique_hash":"87","frame_id":87}],"globals":{},"ordered_globals":[],"func_name":"main","heap":{"143":["LIST",["REF",145],["REF",146]],"145":["LIST",0,4,0],"146":["LIST",8,1,0]}},{"stdout":"(0, 0): 0\n(1, 0): 4\n","event":"step_line","line":14,"stack_to_render":[{"func_name":"main:14","encoded_locals":{"arvo":0,"x":2,"y":0,"rivit":2,"sarakkeet":3,"taulukko":["REF",143]},"ordered_varnames":["rivit","sarakkeet","taulukko","y","x","arvo"],"parent_frame_id_list":[],"is_highlighted":true,"is_zombie":false,"is_parent":false,"unique_hash":"94","frame_id":94}],"globals":{},"ordered_globals":[],"func_name":"main","heap":{"143":["LIST",["REF",145],["REF",146]],"145":["LIST",0,4,0],"146":["LIST",8,1,0]}},{"stdout":"(0, 0): 0\n(1, 0): 4\n(2, 0): 0\n","event":"step_line","line":12,"stack_to_render":[{"func_name":"main:12","encoded_locals":{"x":2,"y":0,"rivit":2,"sarakkeet":3,"taulukko":["REF",143]},"ordered_varnames":["rivit","sarakkeet","taulukko","y","x"],"parent_frame_id_list":[],"is_highlighted":true,"is_zombie":false,"is_parent":false,"unique_hash":"99","frame_id":99}],"globals":{},"ordered_globals":[],"func_name":"main","heap":{"143":["LIST",["REF",145],["REF",146]],"145":["LIST",0,4,0],"146":["LIST",8,1,0]}},{"stdout":"(0, 0): 0\n(1, 0): 4\n(2, 0): 0\n","event":"step_line","line":12,"stack_to_render":[{"func_name":"main:12","encoded_locals":{"x":3,"y":0,"rivit":2,"sarakkeet":3,"taulukko":["REF",143]},"ordered_varnames":["rivit","sarakkeet","taulukko","y","x"],"parent_frame_id_list":[],"is_highlighted":true,"is_zombie":false,"is_parent":false,"unique_hash":"100","frame_id":100}],"globals":{},"ordered_globals":[],"func_name":"main","heap":{"143":["LIST",["REF",145],["REF",146]],"145":["LIST",0,4,0],"146":["LIST",8,1,0]}},{"stdout":"(0, 0): 0\n(1, 0): 4\n(2, 0): 0\n","event":"step_line","line":11,"stack_to_render":[{"func_name":"main:11","encoded_locals":{"y":0,"rivit":2,"sarakkeet":3,"taulukko":["REF",143]},"ordered_varnames":["rivit","sarakkeet","taulukko","y"],"parent_frame_id_list":[],"is_highlighted":true,"is_zombie":false,"is_parent":false,"unique_hash":"107","frame_id":107}],"globals":{},"ordered_globals":[],"func_name":"main","heap":{"143":["LIST",["REF",145],["REF",146]],"145":["LIST",0,4,0],"146":["LIST",8,1,0]}},{"stdout":"(0, 0): 0\n(1, 0): 4\n(2, 0): 0\n","event":"step_line","line":11,"stack_to_render":[{"func_name":"main:11","encoded_locals":{"y":1,"rivit":2,"sarakkeet":3,"taulukko":["REF",143]},"ordered_varnames":["rivit","sarakkeet","taulukko","y"],"parent_frame_id_list":[],"is_highlighted":true,"is_zombie":false,"is_parent":false,"unique_hash":"109","frame_id":109}],"globals":{},"ordered_globals":[],"func_name":"main","heap":{"143":["LIST",["REF",145],["REF",146]],"145":["LIST",0,4,0],"146":["LIST",8,1,0]}},{"stdout":"(0, 0): 0\n(1, 0): 4\n(2, 0): 0\n","event":"step_line","line":12,"stack_to_render":[{"func_name":"main:12","encoded_locals":{"y":1,"rivit":2,"sarakkeet":3,"taulukko":["REF",143]},"ordered_varnames":["rivit","sarakkeet","taulukko","y"],"parent_frame_id_list":[],"is_highlighted":true,"is_zombie":false,"is_parent":false,"unique_hash":"114","frame_id":114}],"globals":{},"ordered_globals":[],"func_name":"main","heap":{"143":["LIST",["REF",145],["REF",146]],"145":["LIST",0,4,0],"146":["LIST",8,1,0]}},{"stdout":"(0, 0): 0\n(1, 0): 4\n(2, 0): 0\n","event":"step_line","line":12,"stack_to_render":[{"func_name":"main:12","encoded_locals":{"x":0,"y":1,"rivit":2,"sarakkeet":3,"taulukko":["REF",143]},"ordered_varnames":["rivit","sarakkeet","taulukko","y","x"],"parent_frame_id_list":[],"is_highlighted":true,"is_zombie":false,"is_parent":false,"unique_hash":"117","frame_id":117}],"globals":{},"ordered_globals":[],"func_name":"main","heap":{"143":["LIST",["REF",145],["REF",146]],"145":["LIST",0,4,0],"146":["LIST",8,1,0]}},{"stdout":"(0, 0): 0\n(1, 0): 4\n(2, 0): 0\n","event":"step_line","line":13,"stack_to_render":[{"func_name":"main:13","encoded_locals":{"x":0,"y":1,"rivit":2,"sarakkeet":3,"taulukko":["REF",143]},"ordered_varnames":["rivit","sarakkeet","taulukko","y","x"],"parent_frame_id_list":[],"is_highlighted":true,"is_zombie":false,"is_parent":false,"unique_hash":"123","frame_id":123}],"globals":{},"ordered_globals":[],"func_name":"main","heap":{"143":["LIST",["REF",145],["REF",146]],"145":["LIST",0,4,0],"146":["LIST",8,1,0]}},{"stdout":"(0, 0): 0\n(1, 0): 4\n(2, 0): 0\n","event":"step_line","line":14,"stack_to_render":[{"func_name":"main:14","encoded_locals":{"arvo":8,"x":0,"y":1,"rivit":2,"sarakkeet":3,"taulukko":["REF",143]},"ordered_varnames":["rivit","sarakkeet","taulukko","y","x","arvo"],"parent_frame_id_list":[],"is_highlighted":true,"is_zombie":false,"is_parent":false,"unique_hash":"130","frame_id":130}],"globals":{},"ordered_globals":[],"func_name":"main","heap":{"143":["LIST",["REF",145],["REF",146]],"145":["LIST",0,4,0],"146":["LIST",8,1,0]}},{"stdout":"(0, 0): 0\n(1, 0): 4\n(2, 0): 0\n(0, 1): 8\n","event":"step_line","line":12,"stack_to_render":[{"func_name":"main:12","encoded_locals":{"x":0,"y":1,"rivit":2,"sarakkeet":3,"taulukko":["REF",143]},"ordered_varnames":["rivit","sarakkeet","taulukko","y","x"],"parent_frame_id_list":[],"is_highlighted":true,"is_zombie":false,"is_parent":false,"unique_hash":"135","frame_id":135}],"globals":{},"ordered_globals":[],"func_name":"main","heap":{"143":["LIST",["REF",145],["REF",146]],"145":["LIST",0,4,0],"146":["LIST",8,1,0]}},{"stdout":"(0, 0): 0\n(1, 0): 4\n(2, 0): 0\n(0, 1): 8\n","event":"step_line","line":12,"stack_to_render":[{"func_name":"main:12","encoded_locals":{"x":1,"y":1,"rivit":2,"sarakkeet":3,"taulukko":["REF",143]},"ordered_varnames":["rivit","sarakkeet","taulukko","y","x"],"parent_frame_id_list":[],"is_highlighted":true,"is_zombie":false,"is_parent":false,"unique_hash":"136","frame_id":136}],"globals":{},"ordered_globals":[],"func_name":"main","heap":{"143":["LIST",["REF",145],["REF",146]],"145":["LIST",0,4,0],"146":["LIST",8,1,0]}},{"stdout":"(0, 0): 0\n(1, 0): 4\n(2, 0): 0\n(0, 1): 8\n","event":"step_line","line":13,"stack_to_render":[{"func_name":"main:13","encoded_locals":{"x":1,"y":1,"rivit":2,"sarakkeet":3,"taulukko":["REF",143]},"ordered_varnames":["rivit","sarakkeet","taulukko","y","x"],"parent_frame_id_list":[],"is_highlighted":true,"is_zombie":false,"is_parent":false,"unique_hash":"143","frame_id":143}],"globals":{},"ordered_globals":[],"func_name":"main","heap":{"143":["LIST",["REF",145],["REF",146]],"145":["LIST",0,4,0],"146":["LIST",8,1,0]}},{"stdout":"(0, 0): 0\n(1, 0): 4\n(2, 0): 0\n(0, 1): 8\n","event":"step_line","line":14,"stack_to_render":[{"func_name":"main:14","encoded_locals":{"arvo":1,"x":1,"y":1,"rivit":2,"sarakkeet":3,"taulukko":["REF",143]},"ordered_varnames":["rivit","sarakkeet","taulukko","y","x","arvo"],"parent_frame_id_list":[],"is_highlighted":true,"is_zombie":false,"is_parent":false,"unique_hash":"150","frame_id":150}],"globals":{},"ordered_globals":[],"func_name":"main","heap":{"143":["LIST",["REF",145],["REF",146]],"145":["LIST",0,4,0],"146":["LIST",8,1,0]}},{"stdout":"(0, 0): 0\n(1, 0): 4\n(2, 0): 0\n(0, 1): 8\n(1, 1): 1\n","event":"step_line","line":12,"stack_to_render":[{"func_name":"main:12","encoded_locals":{"x":1,"y":1,"rivit":2,"sarakkeet":3,"taulukko":["REF",143]},"ordered_varnames":["rivit","sarakkeet","taulukko","y","x"],"parent_frame_id_list":[],"is_highlighted":true,"is_zombie":false,"is_parent":false,"unique_hash":"155","frame_id":155}],"globals":{},"ordered_globals":[],"func_name":"main","heap":{"143":["LIST",["REF",145],["REF",146]],"145":["LIST",0,4,0],"146":["LIST",8,1,0]}},{"stdout":"(0, 0): 0\n(1, 0): 4\n(2, 0): 0\n(0, 1): 8\n(1, 1): 1\n","event":"step_line","line":12,"stack_to_render":[{"func_name":"main:12","encoded_locals":{"x":2,"y":1,"rivit":2,"sarakkeet":3,"taulukko":["REF",143]},"ordered_varnames":["rivit","sarakkeet","taulukko","y","x"],"parent_frame_id_list":[],"is_highlighted":true,"is_zombie":false,"is_parent":false,"unique_hash":"156","frame_id":156}],"globals":{},"ordered_globals":[],"func_name":"main","heap":{"143":["LIST",["REF",145],["REF",146]],"145":["LIST",0,4,0],"146":["LIST",8,1,0]}},{"stdout":"(0, 0): 0\n(1, 0): 4\n(2, 0): 0\n(0, 1): 8\n(1, 1): 1\n","event":"step_line","line":13,"stack_to_render":[{"func_name":"main:13","encoded_locals":{"x":2,"y":1,"rivit":2,"sarakkeet":3,"taulukko":["REF",143]},"ordered_varnames":["rivit","sarakkeet","taulukko","y","x"],"parent_frame_id_list":[],"is_highlighted":true,"is_zombie":false,"is_parent":false,"unique_hash":"163","frame_id":163}],"globals":{},"ordered_globals":[],"func_name":"main","heap":{"143":["LIST",["REF",145],["REF",146]],"145":["LIST",0,4,0],"146":["LIST",8,1,0]}},{"stdout":"(0, 0): 0\n(1, 0): 4\n(2, 0): 0\n(0, 1): 8\n(1, 1): 1\n","event":"step_line","line":14,"stack_to_render":[{"func_name":"main:14","encoded_locals":{"arvo":0,"x":2,"y":1,"rivit":2,"sarakkeet":3,"taulukko":["REF",143]},"ordered_varnames":["rivit","sarakkeet","taulukko","y","x","arvo"],"parent_frame_id_list":[],"is_highlighted":true,"is_zombie":false,"is_parent":false,"unique_hash":"170","frame_id":170}],"globals":{},"ordered_globals":[],"func_name":"main","heap":{"143":["LIST",["REF",145],["REF",146]],"145":["LIST",0,4,0],"146":["LIST",8,1,0]}},{"stdout":"(0, 0): 0\n(1, 0): 4\n(2, 0): 0\n(0, 1): 8\n(1, 1): 1\n(2, 1): 0\n","event":"step_line","line":12,"stack_to_render":[{"func_name":"main:12","encoded_locals":{"x":2,"y":1,"rivit":2,"sarakkeet":3,"taulukko":["REF",143]},"ordered_varnames":["rivit","sarakkeet","taulukko","y","x"],"parent_frame_id_list":[],"is_highlighted":true,"is_zombie":false,"is_parent":false,"unique_hash":"175","frame_id":175}],"globals":{},"ordered_globals":[],"func_name":"main","heap":{"143":["LIST",["REF",145],["REF",146]],"145":["LIST",0,4,0],"146":["LIST",8,1,0]}},{"stdout":"(0, 0): 0\n(1, 0): 4\n(2, 0): 0\n(0, 1): 8\n(1, 1): 1\n(2, 1): 0\n","event":"step_line","line":12,"stack_to_render":[{"func_name":"main:12","encoded_locals":{"x":3,"y":1,"rivit":2,"sarakkeet":3,"taulukko":["REF",143]},"ordered_varnames":["rivit","sarakkeet","taulukko","y","x"],"parent_frame_id_list":[],"is_highlighted":true,"is_zombie":false,"is_parent":false,"unique_hash":"176","frame_id":176}],"globals":{},"ordered_globals":[],"func_name":"main","heap":{"143":["LIST",["REF",145],["REF",146]],"145":["LIST",0,4,0],"146":["LIST",8,1,0]}},{"stdout":"(0, 0): 0\n(1, 0): 4\n(2, 0): 0\n(0, 1): 8\n(1, 1): 1\n(2, 1): 0\n","event":"step_line","line":11,"stack_to_render":[{"func_name":"main:11","encoded_locals":{"y":1,"rivit":2,"sarakkeet":3,"taulukko":["REF",143]},"ordered_varnames":["rivit","sarakkeet","taulukko","y"],"parent_frame_id_list":[],"is_highlighted":true,"is_zombie":false,"is_parent":false,"unique_hash":"183","frame_id":183}],"globals":{},"ordered_globals":[],"func_name":"main","heap":{"143":["LIST",["REF",145],["REF",146]],"145":["LIST",0,4,0],"146":["LIST",8,1,0]}},{"stdout":"(0, 0): 0\n(1, 0): 4\n(2, 0): 0\n(0, 1): 8\n(1, 1): 1\n(2, 1): 0\n","event":"step_line","line":11,"stack_to_render":[{"func_name":"main:11","encoded_locals":{"y":2,"rivit":2,"sarakkeet":3,"taulukko":["REF",143]},"ordered_varnames":["rivit","sarakkeet","taulukko","y"],"parent_frame_id_list":[],"is_highlighted":true,"is_zombie":false,"is_parent":false,"unique_hash":"185","frame_id":185}],"globals":{},"ordered_globals":[],"func_name":"main","heap":{"143":["LIST",["REF",145],["REF",146]],"145":["LIST",0,4,0],"146":["LIST",8,1,0]}},{"stdout":"(0, 0): 0\n(1, 0): 4\n(2, 0): 0\n(0, 1): 8\n(1, 1): 1\n(2, 1): 0\n","event":"step_line","line":17,"stack_to_render":[{"func_name":"main:17","encoded_locals":{"rivit":2,"sarakkeet":3,"taulukko":["REF",143]},"ordered_varnames":["rivit","sarakkeet","taulukko"],"parent_frame_id_list":[],"is_highlighted":true,"is_zombie":false,"is_parent":false,"unique_hash":"190","frame_id":190}],"globals":{},"ordered_globals":[],"func_name":"main","heap":{"143":["LIST",["REF",145],["REF",146]],"145":["LIST",0,4,0],"146":["LIST",8,1,0]}},{"stdout":"(0, 0): 0\n(1, 0): 4\n(2, 0): 0\n(0, 1): 8\n(1, 1): 1\n(2, 1): 0\n","event":"return","line":17,"stack_to_render":[{"func_name":"main:17","encoded_locals":{"rivit":2,"sarakkeet":3,"taulukko":["REF",143],"__return__":["VOID"]},"ordered_varnames":["rivit","sarakkeet","taulukko","__return__"],"parent_frame_id_list":[],"is_highlighted":true,"is_zombie":false,"is_parent":false,"unique_hash":"192","frame_id":192}],"globals":{},"ordered_globals":[],"func_name":"main","heap":{"143":["LIST",["REF",145],["REF",146]],"145":["LIST",0,4,0],"146":["LIST",8,1,0]}}],"userlog":"Debugger VM maxMemory: 455M\n"}'></div>


<% partial 'partials/material_heading' do %>
  Olioita taulukossa? 
<% end %>


<% partial 'partials/material_heading' do %>
  Vertaisarviointi: Ohjelmien testaaminen
<% end %>

<p>
  Kymmenennessä osassa kirjoitimme omia testejä valmiille malliratkaisulle. Nyt on taas vertaisarvioinnin aika! Anna vertaispalautetta kahdesta jonkun toisen kurssilaisen lähettämästä tehtävästä ja arvioi lopuksi itse tekemääsi tehtävää. Itse tekemäsi tehtävä näkyy vain jos olet tehnyt sen -- jos et tehnyt tehtävää, pääset arvioimaan yhden ylimääräisen tehtävän.
</p>

<% partial 'partials/hint', locals: { name: 'Vertaisarviointi' } do %>

  <p>
    Alla on kolme Crowdsorcereriin tehtyä tehtävää: kaksi jonkun kurssitoverisi lähettämää ja yksi itsearviointia varten. Niiden yhteydessä on muistin virkistykseksi ohjeistus, jonka pohjalta kyseiset tehtävänannot on tehty.
  </p>

  <p>
    Tarkastele jokaisen tehtävän tehtävänantoa ja testejä. Arvioi niiden selkeyttä, kattavuutta ja sitä, kuinka hyvin ne vastaavat valmiina annettua lähdekoodia.
  </p>

  <p>
    Palautteenannon avuksi on annettu väittämiä. Voit valita kuinka samaa mieltä niiden kanssa olet painamalla hymiöitä. Annathan myös sanallista palautetta sille varattuun kenttään! Lisää vielä tehtävää mielestäsi kuvaavia tageja ja paina Lähetä.
  </p>

  <p>
    Anna arvio kummallekin vertaispalautetehtävälle ja lopuksi vielä omallesi.
  </p>

  <p>
    Muista olla reilu ja ystävällinen. Hyvä palaute on rehellistä, mutta kannustavaa!
  </p>

  <p>
    Voit halutessasi ladata arvioitavan tehtävän tehtäväpohjan ja malliratkaisun koneellesi, ja testata niiden käyttöä. Molemmat tulevat ZIP-paketeissa, jolloin sinun täytyy purkaa ne, ennen kuin voit avata ne NetBeansissä.
  </p>

<% end %>

<p>TODO: crowdsorcererit ei vielä toimi</p>


<% partial 'partials/general_callout', locals: { name: 'Kirjoita testit valmiille malliratkaisulle 1' } do %>

  <p>
    Lähdekoodin kohdalla on valmis malliratkaisu. Keksi sitä vastaava tehtävänanto ja kirjoita testit luokan Submission metodille vertaile. Lähetettyäsi tehtävän saat tiedon siitä, kääntyikö testikoodi ja menivätkö testisi läpi. Jos eivät, lue virheviesti ja lähdekoodi uudestaan ja korjaa testisi sen mukaisesti.
  </p>

  <p>
    Tehtävien luomistehtävät käsitellään pisteytyksessä bonuksena.
  </p>  

<% end %>

<div class='crowdsorcerer-widget' data-assignment='17' peer-review data-exercises='3'></div>

<% partial 'partials/general_callout', locals: { name: 'Kirjoita testit valmiille malliratkaisulle 2' } do %>

  <p>
    Lähdekoodin kohdalla on valmis malliratkaisu. Keksi sitä vastaava tehtävänanto ja kirjoita testit luokan Submission metodille annaKokonaisluku. Huomaa, että lähdekoodissa ei käytetä ääkkösiä.
  </p>
  <p>
    Lähetettyäsi tehtävän saat tiedon siitä, kääntyikö testikoodi ja menivätkö testisi läpi. Jos eivät, lue virheviesti ja lähdekoodi uudestaan ja korjaa testisi sen mukaisesti.
  </p>

  <p>
    Tehtävien luomistehtävät käsitellään pisteytyksessä bonuksena.
  </p>  

<% end %>

<div class='crowdsorcerer-widget' data-assignment='19' peer-review data-exercises='3'></div>


<%= partial 'partials/quiz', locals: { id: '5a987a0f7863c4000454a044' } %>


