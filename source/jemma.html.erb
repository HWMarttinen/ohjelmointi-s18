


<% partial 'partials/material_heading' do %>
  Tehtäväpohjien rakenne ja Maven
<% end %>

<p>
  Ohjelmoinnin jatkokurssista lähtien kurssin tehtäväpohjat käyttävät <a href="https://maven.apache.org/" target="_blank" norel>Maven</a>-nimistä projektinhallintatyövälinettä. Kyseinen työväline helpottaa kurssin tehtävien mukana tuotavien kirjastojen hallintaa. Tehtäviin tämä vaikuttaa siten, että niiden kansiorakenne muuttuu hieman. 
</p>

<p>
  Jatkossa tehtävän juurikansiossa on tiedosto pom.xml, joka kuvaa tehtäväpohjan rakenteen. Kansio <code>src</code> sisältää kansiot <code>main</code> ja <code>test</code>, jotka sisältävät lähdekooditiedostot sekä testitiedostot.

</p>


<% partial 'partials/material_sub_heading' do %>
  Metodit ja ohjelman nimentä
<% end %>

<p>
  Tarkastellaan ohjelman nimentää ja selventämistä vielä metodien avulla. 
</p>

<p>
  <em>
    Vuosi on karkausvuosi, jos se on jaollinen 4:llä. Kuitenkin jos vuosi on jaollinen 100:lla, se on karkausvuosi vain silloin, kun se on jaollinen myös 400:lla.
  </em>
</p>



<p>
  TODO: muutama esimerkki eri ääripäistä -- yhdessä ohjelmassa ei ole lainkaan metodeja, toisessa ohjelma koostuu pelkistä metodeista.
</p>

<% partial 'partials/code_highlight' do %>
  public static boolean jaollinen(int luku, int luvulla) {
      return luku % luvulla == 0;

      // tai 
      if (luku % luvulla == 0) {
        return true;
      }

      return false;
  }
<% end %>


<% partial 'partials/code_highlight' do %>
  public static boolean ei(boolean arvo) {
      return !arvo;

      // tai 
      if (arvo == true) {
        return false;
      }

      return true;

      // tai
      if (arvo) {
        return false;
      }

      return true;
  }
<% end %>


<% partial 'partials/code_highlight' do %>
  if(ei(jaollinen(luku, 400))) {
    // heh
  }
<% end %>



<pre>
$/Osa08_01.SamaPaivays$ tree
.
├── pom.xml
└── src
    ├── main
    │   └── java
    │       ├── Paaohjelma.java
    │       └── Paivays.java
    └── test
        └── java
            └── PaivaysTest.java

</pre>


<p>
  Ohjelmien toiminta ei käytännössä juurikaan muutu. Toisin kuin ennen, ohjelmien tarvitsemat kirjastot eivät kuitenkaan tule tehtäväpohjan mukana, vaan Mavenilta tulee pyytää tarvittaessa niiden lataamista. Tämä onnistuu klikkaamalla tehtäväpohjan Dependencies-kuvaketta Projects-välilehdellä ja valitsemalla "Download declared dependencies."
</p>

<img src="/img/maven-1.png"/>

<br/>

<p>
  Riippuen tietokoneesi käyttöjärjestelmästä, on mahdollista, että joudut lisäämään Maven-ohjelmaan ajo-oikeudet kun sitä käytetään ensimmäistä kertaa. Windowsille ohjeita löytyy yleisesti ottaen googlettamalla ja mm. täältä: <a href="https://www.online-tech-tips.com/computer-tips/set-file-folder-permissions-windows/" target="_blank" norel>https://www.online-tech-tips.com/computer-tips/set-file-folder-permissions-windows/</a> -- myös pajassa neuvotaan tähän liittyen. 
</p>


<% partial 'partials/material_sub_heading' do %>
  Ongelmia ja ratkaisuja
<% end %>

<p>
  Mavenin käyttöönottoon on liittynyt kurssilla ongelmia. Tässä lyhyt ongelmanratkaisuopas.
</p>

<% partial 'partials/material_sub_sub_heading' do %>
  Linux ja Mac
<% end %>

<p>
  Ongelma: Maven-binäärin suoritusoikeudet puuttuvat. Mavenin virhe on (esimerkiksi) muotoa.
</p>

<pre>
Cannot run program
  /Applications/tmcbeans.app/Contents/Resources/tmcbeans/java/maven/bin/mvn"
  (in directory "/Users/[nimi]/NetBeansProjects/hy-[kurssi]/[tehtava]"):
  error=13,
  Permission denied
</pre>

<p>
  Ratkaisu: lisää maven-binäärille suoritusoikeudet. Suorita terminaalissa (pääte) komento.
</p>

<pre>
chmod +x /Applications/tmcbeans.app/Contents/Resources/tmcbeans/java/maven/bin/mvn
</pre>

<p>
  Huomaa, että edellä polku on sama kuin virheviestin "Cannot run program"-polku.
</p>

<% partial 'partials/material_sub_sub_heading' do %>
  Windows
<% end %>

<p>
  Ongelma: Ympäristömuuttuja <code>JAVA_HOME</code> ei ole asetettu. Käytännössä Maven yrittää etsiä Javaa, mutta ei löydä sitä.
</p>

<p>
  Ratkaisu: Lisää Windowsiin JAVA_HOME ympäristömuuttuja (esim.) osoitteessa <a href="https://confluence.atlassian.com/doc/setting-the-java_home-variable-in-windows-8895.html" target="_blank" norel>https://confluence.atlassian.com/doc/setting-the-java_home-variable-in-windows-8895.html</a> olevia ohjeita seuraamalla. Huomaa, että kansion tulee olla jdk, ei jre.
</p>


<% partial 'partials/material_sub_sub_heading' do %>
  Tietojenkäsittelytieteen laitoksen koneet
<% end %>

<p>
  Ongelma: Riippuvuuksien lataaminen ei onnistu tai ne eivät toimi. Tässä syynä on joko loppunut levytila tai verkkoyhteysongelma. Levytilan tilanteen saa selvitettyä komennolla "quota".
</p>

<p>
  Ratkaisu:
</p>

<ol>
  <li>
    Poista vanhat ohjelmoinnin perusteiden (ja mahdollisesti muiden TMCtä käyttävien kurssien) tehtäväpohjat. Nämä löytyvät kotikansiosta kansion NetBeansProjects alta. Kannattanee harkita myös muiden turhien tiedostojen poistamista sekä esimerkiksi selaimen välimuistin tyhjentämistä ajoittain.
  </li>

  <li>
    Poista kotikansiossa olevan .m2-kansion sisältö. Tämä tehdään sillä Maven luo ladattavista riippuvuuksista (eli kirjastoista) vahingossa tyhjät tiedostot mikäli levytila on loppunut.
  </li>

  <li>
    (Jatkuva) Kun saat tehtäviä lähetettyä TMC:lle, klikkaa tehtäväpohjaa ja valitse "clean". Tämä poistaa tehtäväpohjasta käännetyt tiedostot.
  </li>
</ol>




<% partial 'partials/exercise', locals: { name: 'Breakout' } do %>

  <p>
    <a href="https://en.wikipedia.org/wiki/Breakout_(video_game)" target="_blank" rel="noopener">Breakout</a> on <a href="https://en.wikipedia.org/wiki/Atari,_Inc." target="_blank" rel="noopener">Atarin</a> vuonna 1976 julkaisema videopeli. Pelin ideana käyttää pelin alalaidassa olevaa mailaa pelissä liikkuvan pallon lyömiseen siten, että pallolla saadaan rikottua ylälaidassa olevia palasia.
  </p>

  <p>
    Termi "Breakout" tulee tilanteesta, missä pelaaja saa pallon ylälaidassa olevien palasten yläpuolelle, missä pallo tekee tuhoa useammalle palalle samaan aikaan.
  </p>

  <p>
    Tässä tehtävässä fiilistellään Breakout-pelin tekemistä.
  </p>

  <p>
    Tehtäväpohjaan on toteutettuna ensimmäisiä palasia Breakout peliin. Tehtävänäsi on täydentää pelin toimintaa. Alla lista täydennysehdotuksista:
  </p>

  <ol>
    <li>Tällä hetkellä pelin ylälaidassa on vain muutama vaivainen palikka. Muokkaa peliä siten, että ylälaidassa on useita erivärisiä palikoita. Hae inspiraatiota <a href="https://images.google.com" target="_blank" rel="noopener">Googlen kuvahausta</a> avainsanalla "Breakout".</li>
    <li>Pelin pelattavuus on tällä hetkellä melko heikko. Mailalla ei osuta palloon, vaikka kuinka yritettäisiin. Lisää peliin mahdollisuus osua mailalla palloon -- palloon osumisen pitäisi muuttaa pallon suuntaa. Osoitteesta <a href="http://www.edu4java.com/en/game/game6.html" target="_blank" rel="noopener">http://www.edu4java.com/en/game/game6.html</a> olevasta oppaasta saattaa olla hyötyä. Hifistelyä kaipaavat voivat lähteä liikenteeseen kysymyksestä <a href="http://gamedev.stackexchange.com/questions/10911/a-ball-hits-the-corner-where-will-it-deflect" target="_blank" rel="noopener">A ball hits the corner, where will it deflect?</a></li>
    <li>Kun pallon osuminen mailaan on hanskassa, lisää samanlainen osumistoiminnallisuus kaikkiin paloihin. Tässä kohtaa paloja ei vielä tarvitse poistaa.</li>
    <li>Kun pallo osuu palaan, pala pitäisi poistaa. Sehän on melkein jo peli!</li>
    <li>Mieti minkälaisia luokkia pelissä kannattaisi olla. Nyt piirtämiseen käytetty paikka sisältää varmaankin jo hyvin paljon koodia.. Siistimisen paikka!</li>
  </ol>

  <p>
    Tehtävässä ei ole automaattisia testejä ja se on yhden pisteen arvoinen. Voit palauttaa tehtävän jo kun saat ensimmäisen parannusehdotuksen tehtyä mutta peliä saa toki viilata enemmänkin.
  </p>

<% end %>



<% partial 'partials/exercise', locals: { name: 'Kellosta olio' } do %>

  <p>
    Teimme aiemmin luokan <code>YlhaaltaRajoitettuLaskuri</code> ja rakennettiin laskurien avulla pääohjelmaan kello. Tehdään tässä tehtävässä kellostakin oma olio -- kello sisältää kolme viisaria, jotka jokainen esitetään ylhäältä rajoitetun laskurin avulla. Luokan kello runko näyttää seuraavalta:
  </p>

  <% partial 'partials/code_highlight' do %>
    public class Kello {
    private YlhaaltaRajoitettuLaskuri tunnit;
    private YlhaaltaRajoitettuLaskuri minuutit;
    private YlhaaltaRajoitettuLaskuri sekunnit;

    public Kello(int tunnitAlussa, int minuutitAlussa, int sekunnitAlussa) {
    // laskurit tunneille, minuuteille ja sekunneille;
    // laskurien arvot tulee asettaa parametreina saatuun aikaan
    }

    public void etene() {
    // kello etenee sekunnilla
    }

    public String toString() {
    // palauttaa kellon merkkijonoesityksen
    }
    }
  <% end %>

  <p>
    Luokkaan YlhaaltaRajoitettuLaskuri on kopioitu eräs ratkaisu viime osan tehtävään. Toteuta luokan <code>Kello</code> konstruktori ja puuttuvat metodit kolmea ylhäältä rajoitettua laskuria hyödyntäen.
  </p>

  <p>
    Voit testata kelloasi seuraavalla pääohjelmalla:
  </p>

  <% partial 'partials/code_highlight' do %>
    public class Main {
    public static void main(String[] args) {
    Kello kello = new Kello(23, 59, 50);

    int i = 0;
    while (i &lt; 20) {
    System.out.println(kello);
    kello.etene();
    i++;
    }
    }
    }
  <% end %>

  <p>
    Tulostuksen tulisi edetä seuraavasti:
  </p>

  <% partial 'partials/sample_output' do %>
    23:59:50
    23:59:51
    23:59:52
    23:59:53
    23:59:54
    23:59:55
    23:59:56
    23:59:57
    23:59:58
    23:59:59
    00:00:00
    00:00:01
    ...
  <% end %>

<% end %>



<% partial 'partials/exercise', locals: { name: 'Työntekijän eläkevakuutus' } do %>

  <p>
    Työntekijän eläkevakuutus (TyEL) on lakisääteinen ja pakollinen maksu, jolla rahoitetaan suurin osa nykyisistä ja tulevista työeläkkeistä. Työntekijän eläkevakuutuksen maksamisesta vastaa sekä työnantaja että työntekijä: <a href="http://www.etk.fi/uutinen/tyoelakemaksut-vuonna-2017/" target="_blank">Eläketurvakeskuksen mukaan</a> työnantajan maksama TyEL-maksu on vuonna 2017 noin 18% työntekijän palkasta, kun taas työntekijä maksaa palkastaan TyEL-maksua noin 6%.
  </p>

  <p>
    Työnantaja maksaa osuutensa bruttopalkan lisäksi, kun taas työntekijän maksama osuus otetaan bruttopalkasta (eli palkasta ennen ennakonpidätyksiä, vakuutusmaksuja ja muita vähennyksiä).
  </p>

  <p>
    Toteuta ohjelma, joka kertoo TyEL-kulut annetulle bruttopalkalle. Ohjelman tulee kertoa annetun bruttopalkan perusteella työnantajan maksut sekä palkasta tehtävät pidätykset. Käytä edellä annettuja arvioita (työnantajan osuus 18% ja työntekijän osuus 6%).
  </p>

  <% partial 'partials/sample_output' do %>
    Syötä bruttopalkka: <font color="red">800</font>
    Työnantaja maksaa TyEL-maksuja: 144
    Työntekijä maksaa työnantajalle vähintään: 944

    Työntekijä maksaa TyEL-maksuja: 48
    Työntekijän palkka TyEL-maksun jälkeen: 752

    TyEL-kulut yhteensä: 192
  <% end %>


  <% partial 'partials/sample_output' do %>
    Syötä bruttopalkka: <font color="red">1000</font>
    Työnantaja maksaa TyEL-maksuja: 180
    Työntekijä maksaa työnantajalle vähintään: 1180

    Työntekijä maksaa TyEL-maksuja: 60
    Työntekijän palkka TyEL-maksun jälkeen: 940

    TyEL-kulut yhteensä: 240
  <% end %>
<% end %>


<% partial 'partials/exercise', locals: { name: 'Lukujen keskiarvo' } do %>

  <p>
    Tehtävänannossa tulee käyttäjän syöttämien lukujen summan laskeva ohjelma. Ohjelma kysyy lukuja kunnes käyttäjä syöttää nollan. Tämän jälkeen lukujen lukeminen loppuu, ja ohjelma tulostaa lukujen summan luvun.
  </p>

  <p>
    Muokkaa ohjelmaa siten, että ohjelma tulostaa syötettyjen lukujen summa lisäksi syötettyjen lukujen keskiarvon.
  </p>

<% end %>

<% partial 'partials/exercise', locals: { name: 'Salapaikka ranskassa' } do %>

  <p>
    Kameralta kuvien kopioimiseen tarkoitetun ohjelmiston toteuttaja löysi ohjelmastaan virheen, jonka lopputulos näkyy tehtäväpohjassa olevan ohjelman näyttämässä kuvassa. Ohjelmiston toteuttaja kertoo seuraavaa.
  </p>
  
  <p>
    "Tämä virhe oli aika harmittava. Se muutti kaikki siniset ja vihreät väriarvot pelkäksi kohinaksi, joten niistä ei ole mitään iloa eikä niitä saa koskaan takaisin kuvaan. Lisäksi punaisen värin määrä jokaisessa pikselissä jakautui noin kymmenellä kopioinnin yhteydessä, joten kuvan punainen väri on aivan liian tumma."
  </p>

  <p>
    Selvitä kopiointiohjelmiston mitä kuvassa näkyy ja mistä kuva on otettu. Tietokoneella kuvatiedostoja käsitellään yleensä <a href="https://fi.wikipedia.org/wiki/RGB-v%C3%A4rimalli" target="_blank" norel>RGB-värimallin</a> kautta. Tässä tapauksessa jokaisen värin arvo on välillä 0-1, ja jokainen väriarvo esitetään desimaalilukuna.
  </p>
  

<% end %>



<% partial 'partials/exercise', locals: { name: 'Fibonaccin lukujono' } do %>

  <p>
    Fibonaccin lukujonon ajatuksena on laskea yhteen kaksi edellistä lukua, ja näin saada seuraavan luvun arvo. Lukujonon ensimmäiset kaksi lukua ovat 0 ja 1. Seuraavan luvun saa laskettua aina kahden edellisen luvun summana.
  </p>

  <p>
    Toteuta ohjelma, joka ensin laskee Fibonaccin lukujonon ensimmäiset 40 lukua listalle. Ohjelma kysyy tämän jälkeen käyttäjältä halutun Fibonaccin luvun kohtaa. Kun käyttäjä syöttää luvun -- oleta, että luku on indeksi listalla -- ohjelma tulostaa halutun luvun.
  </p>

  <p>
    Ohjelman suoritus päättyy kun käyttäjä syöttää luvun -1.
  </p>

  <% partial 'partials/sample_output' do %>
    Monesko luku? <font color="red">0</font>
    0
    Monesko luku? <font color="red">1</font>
    1
    Monesko luku? <font color="red">7</font>
    13
    Monesko luku? <font color="red">22</font>
    17711
    Monesko luku? <font color="red">-1</font>

    Kiitos!
  <% end %>
<% end %>



<% partial 'partials/exercise', locals: { name: 'Pong' } do %>

  <p>
    Tässä tehtävässä täydennetään erästä tietokonepelien klassikkoa, <a href="https://en.wikipedia.org/wiki/Pong" target="_blank" norel>Pongia</a>. Tavoitteena pelissä on saada pallo lyötyä vastustajan mailasta ohi. Pisteen saa aina kun pallo osuu seinään. Tehtäväpohjaan on hahmoteltu Pong-peliä, joka näyttää seuraavalta:
  </p>

  <img src="/img/pong-screenshot.png"/>

  <p>
    Pelin saa käynnistettyä valitsemalla luokan PongApplication ja suorittamalla sen. Vasenta mailaa voi ohjata napeilla w ja s, oikeaa mailaa nuolinäppäimillä.
  </p>
  
  <p>
    Pohjasta puuttuu kuitenkin merkittävä osa pelin toiminnallisuudesta. Tässä tehtävässä tavoitteenasi on tutustua olemassaolevaan ohjelmaan ja täydentää peliä sopivasti. Tässä muutamia täydennysehdotuksia:
  </p>

  <ol>
    <li>
      Pisteiden tulee muuttua kun pallo osuu seinään.
    </li>
    <li>
      Jos pallo osuu mailaan sen tulee kimmota mailasta.
    </li>
    <li>
      Mailan nopeuden pitäisi olla suurempi.
    </li>
    <li>
      Mailan ei pitäisi poistua alueelta.
    </li>
    <li>
      pallon nopeuden tulee kasvaa pelin edetessä.
    </li>
    <li>
      ...
    </li>
  </ol>

  <p>
    Tehtävässä ei ole testejä ja sen tekemisestä saa yhden pisteen. Saat itse käytännössä määritellä mitä tehtävän tekeminen tarkoittaa, eli voit vapaasti tehdä pelistä hyvinkin monimuotoisen, jota ehkäpä päädyt jopa demoamaan jollekin.
  </p>

  
<% end %>




<li>
  typonator-olio?
</li>
<li>
  emojohdanto?
</li>
<li>
  luokkakaaviot selkeämmiksi (ei käsin piirretyn näköisiä)
</li>
<li>
  selitystehtävä olioista? vertaispalaute selitystehtävästä?
</li>

-----


<% partial 'partials/material_heading' do %>
  Muutamia yleishyödyllisiä tekniikoita
<% end %>


<p>
  Tutustutaan seuraavaksi muutamaan ohjelmoinnissa varsin näppärään tekniikaan sekä luokkaan.
</p>


<% partial 'partials/material_sub_heading' do %>
  Säännölliset lausekkeet
<% end %>

<p>
  Säännöllinen lauseke määrittelee joukon merkkijonoja tiiviissä muodossa. Säännöllisiä lausekkeita käytetään muunmuassa merkkijonojen oikeellisuuden tarkistamiseen. Merkkijonojen oikeellisuuden tarkastaminen tapahtuu luomalla säännöllinen lauseke, joka määrittelee merkkijonot, jotka ovat oikein.
</p>

<p>
  Tarkastellaan ongelmaa, jossa täytyy tarkistaa, onko käyttäjän antama opiskelijanumero oikeanmuotoinen. Opiskelijanumero alkaa merkkijonolla "01", jota seuraa 7 numeroa väliltä 0&ndash;9.
</p>

<p>
  Opiskelijanumeron oikeellisuuden voisi tarkistaa esimerkiksi käymällä opiskelijanumeroa esittävän merkkijonon läpi merkki merkiltä <code>charAt</code>-metodin avulla. Toinen tapa olisi tarkistaa että ensimmäinen merkki on "0", ja käyttää <code>Integer.parseInt</code> metodikutsua merkkijonon muuntamiseen numeroksi. Tämän jälkeen voisi tarkistaa että <code>Integer.parseInt</code>-metodin palauttama luku on pienempi kuin 20000000.
</p>

<p>
  Oikeellisuuden tarkistus säännöllisten lausekkeiden avulla tapahtuu ensin sopivan säännöllisen lausekkeen määrittelyn. Tämän jälkeen käytetään <code>String</code>-luokan metodia <code>matches</code>, joka tarkistaa vastaako merkkijono parametrina annettua säännöllistä lauseketta. Opiskelijanumeron tapauksessa sopiva säännöllinen lauseke on <code>"01[0-9]{7}"</code>, ja käyttäjän syöttämän opiskelijanumeron tarkistaminen käy seuraavasti:
</p>

<% partial 'partials/code_highlight' do %>
  System.out.print("Anna opiskelijanumero: ");
  String numero = lukija.nextLine();

  if (numero.matches("01[0-9]{7}")) {
  System.out.println("Muoto on oikea.");
  } else {
  System.out.println("Muoto ei ole oikea.");
  }
<% end %>

<p>
  Käydään seuraavaksi läpi eniten käytettyjä säännöllisten lausekkeiden merkintöjä.
</p>


<% partial 'partials/material_sub_sub_heading' do %>
  Vaihtoehtoisuus (pystyviiva)
<% end %>

<p>
  Pystyviiva tarkoittaa, että säännöllisen lausekkeen osat ovat vaihtoehtoisia. Esimerkiksi lauseke <code>00|111|0000</code> määrittelee merkkijonot <code>00</code>, <code>111</code> ja <code>0000</code>. Metodi <code>matches</code> palauttaa arvon <code>true</code> jos merkkijono vastaa jotain määritellyistä vaihtoehdoista.
</p>

<% partial 'partials/code_highlight' do %>
  String merkkijono = "00";

  if (merkkijono.matches("00|111|0000")) {
  System.out.println("Merkkijonosta löytyi joku kolmesta vaihtoehdosta");
  } else {
  System.out.println("Merkkijonosta ei löytynyt yhtäkään vaihtoehdoista");
  }
<% end %>


<% partial 'partials/sample_output' do %>
  Merkkijonosta löytyi joku kolmesta vaihtoehdosta
<% end %>

<p>
  Säännöllinen lauseke <code>00|111|0000</code> vaatii että merkkijono on täsmälleen määritellyn muotoinen: se ei määrittele <em>"contains"</em>-toiminnallisuutta.
</p>

<% partial 'partials/code_highlight' do %>
  String merkkijono = "1111";

  if (merkkijono.matches("00|111|0000")) {
  System.out.println("Merkkijonosta löytyi joku kolmesta vaihtoehdosta");
  } else {
  System.out.println("Merkkijonosta ei löytynyt yhtäkään vaihtoehdoista");
  }
<% end %>

<% partial 'partials/sample_output' do %>
  Merkkijonosta ei löytynyt yhtäkään vaihtoehdoista
<% end %>


<% partial 'partials/material_sub_sub_heading' do %>
  Merkkijonon osaan rajattu vaikutus (sulut)
<% end %>

<p>
  Sulkujen avulla voi määrittää, mihin säännöllisen lausekkeen osaan sulkujen sisällä olevat merkinnät vaikuttavat. Jos haluamme sallia merkkijonot <code>00000</code> ja <code>00001</code>, voimme määritellä ne pystyviivan avulla muodossa <code>00000|00001</code>. Sulkujen avulla voimme rajoittaa vaihtoehtoisuuden vain osaan merkkijonoa. Lauseke <code>0000(0|1)</code> määrittelee merkkijonot <code>00000</code> ja <code>00001</code>.
</p>

<p>
  Vastaavasti säännöllinen lauseke <code>auto(|n|a)</code> määrittelee sanan auto yksikön nominatiivin (auto), genetiivin (auton), partitiivin (autoa) ja akkusatiivin (auto tai auton).
</p>

<% partial 'partials/code_highlight' do %>
  System.out.print("Kirjoita joku sanan auto yksikön taivutusmuoto: ");
  String sana = lukija.nextLine();

  if (sana.matches("auto(|n|a|ssa|sta|on|lla|lta|lle|na|ksi|tta)")) {
  System.out.println("Oikein meni! RRrakastan tätä kieltä!");
  } else {
  System.out.println("Taivutusmuoto ei ole oikea.");
  }
<% end %>


<% partial 'partials/material_sub_sub_heading' do %>
  Toistomerkinnät
<% end %>

<p>
  Usein halutaan, että merkkijonossa toistuu jokin tietty alimerkkijono. Säännöllisissä lausekkeissa on käytössä seuraavat toistomerkinnät:
</p>

<ul>
  <li>Merkintä <strong><code>*</code></strong> toisto 0... kertaa, esim<br/>
    <% partial 'partials/code_highlight' do %>
      String merkkijono = "trolololololo";

      if (merkkijono.matches("trolo(lo)*")) {
      System.out.println("Muoto on oikea.");
      } else {
      System.out.println("Muoto ei ole oikea.");
      }
    <% end %>

    <% partial 'partials/sample_output' do %>
      Muoto on oikea.
    <% end %>
  </li>

  <li>Merkintä <strong><code>+</code></strong> toisto 1... kertaa, esim<br/>
    <% partial 'partials/code_highlight' do %>
      String merkkijono = "trolololololo";

      if (merkkijono.matches("tro(lo)+")) {
      System.out.println("Muoto on oikea.");
      } else {
      System.out.println("Muoto ei ole oikea.");
      }
    <% end %>

    <% partial 'partials/sample_output' do %>
      Muoto on oikea.
    <% end %>

    <% partial 'partials/code_highlight' do %>
      String merkkijono = "nänänänänänänänä Bätmään!";

      if (merkkijono.matches("(nä)+ Bätmään!")) {
      System.out.println("Muoto on oikea.");
      } else {
      System.out.println("Muoto ei ole oikea.");
      }
    <% end %>

    <% partial 'partials/sample_output' do %>
      Muoto on oikea.
    <% end %>
  </li>

  <li>Merkintä <strong><code>?</code></strong> toisto 0 tai 1 kertaa, esim<br/>

    <% partial 'partials/code_highlight' do %>
      String merkkijono = "You have to accidentally the whole meme";

      if (merkkijono.matches("You have to accidentally (delete )?the whole meme")) {
      System.out.println("Muoto on oikea.");
      } else {
      System.out.println("Muoto ei ole oikea.");
      }
    <% end %>

    <% partial 'partials/sample_output' do %>
      Muoto on oikea.
    <% end %>
  </li>

  <li>Merkintä <strong><code>{a}</code></strong> toisto <code>a</code> kertaa, esim<br/>
    <% partial 'partials/code_highlight' do %>
      String merkkijono = "1010";

      if (merkkijono.matches("(10){2}")) {
      System.out.println("Muoto on oikea.");
      } else {
      System.out.println("Muoto ei ole oikea.");
      }
    <% end %>

    <% partial 'partials/sample_output' do %>
      Muoto on oikea.
    <% end %>
  </li>

  <li>Merkintä <strong><code>{a,b}</code></strong> toisto <code>a</code> ... <code>b</code> kertaa, esim<br/>
    <% partial 'partials/code_highlight' do %>
      String merkkijono = "1";

      if (merkkijono.matches("1{2,4}")) {
      System.out.println("Muoto on oikea.");
      } else {
      System.out.println("Muoto ei ole oikea.");
      }
    <% end %>

    <% partial 'partials/sample_output' do %>
      Muoto ei ole oikea.
    <% end %>
  </li>

  <li>Merkintä <strong><code>{a,}</code></strong> toisto <code>a</code> ... kertaa, esim<br/>
    <% partial 'partials/code_highlight' do %>
      String merkkijono = "11111";

      if (merkkijono.matches("1{2,}")) {
      System.out.println("Muoto on oikea.");
      } else {
      System.out.println("Muoto ei ole oikea.");
      }
    <% end %>

    <% partial 'partials/sample_output' do %>
      Muoto on oikea.
    <% end %>
  </li>
</ul>

<p>
  Samassa säännöllisessä lausekkeessa voi käyttää myös useampia toistomerkintöjä. Esimerkiksi säännöllinen lauseke <code>5{3}(1|0)*5{3}</code> määrittelee merkkijonot, jotka alkavat ja loppuvat kolmella vitosella. Välissä saa tulla rajaton määrä ykkösiä ja nollia.
</p>


<% partial 'partials/material_sub_sub_heading' do %>
  Merkkiryhmät (hakasulut)
<% end %>

<p>
  Merkkiryhmän avulla voi määritellä lyhyesti joukon merkkejä. Merkit kirjoitetaan hakasulkujen sisään, ja merkkivälin voi määrittää viivan avulla. Esimerkiksi merkintä <code>[145]</code> tarkoittaa samaa kuin <code>(1|4|5)</code> ja merkintä <code>[2-36-9]</code> tarkoittaa samaa kuin <code>(2|3|6|7|8|9)</code>. Vastaavasti merkintä <code>[a-c]*</code> määrittelee säännöllisen lausekkeen, joka vaatii että merkkijono sisältää vain merkkejä <code>a</code>, <code>b</code> ja <code>c</code>.
</p>


<%= partial 'partials/quiz', locals: { id: '5a02e242fb43ca000414c18f' } %>


<% partial 'partials/exercise', locals: { name: 'Säännölliset lausekkeet (3 osaa)' } do %>

  <p>
    Harjoitellaan hieman säännöllisten lausekkeiden käyttöä. Tehtävissä haetut metodit tehdään luokkaan <code>Tarkistin</code>.
  </p>


  <h2>Viikonpäivä</h2>

  <p>
    Tee säännöllisen lausekkeen avulla metodi <code>public boolean onViikonpaiva(String merkkijono)</code>, joka palauttaa <code>true</code> jos sen parametrina saama merkkijono on viikonpäivän lyhenne (ma, ti, ke, to, pe, la tai su).
  </p>

  <p>
    Esimerkkitulostuksia metodia käyttävästä ohjelmasta:
  </p>

  <% partial 'partials/sample_output' do %>
    Anna merkkijono: <font color="red">ti</font>
    Muoto on oikea.
  <% end %>

  <% partial 'partials/sample_output' do %>
    Anna merkkijono: <font color="red">abc</font>
    Muoto ei ole oikea.
  <% end %>


  <h2>Vokaalitarkistus</h2>

  <p>
    Tee metodi <code>public boolean kaikkiVokaaleja(String merkkijono)</code> joka tarkistaa säännöllisen lausekkeen avulla ovatko parametrina olevan merkkijonon kaikki merkit vokaaleja.
  </p>

  <p>
    Esimerkkitulostuksia metodia käyttävästä ohjelmasta:
  </p>

  <% partial 'partials/sample_output' do %>
    Anna merkkijono: <font color="red">aie</font>
    Muoto on oikea.
  <% end %>

  <% partial 'partials/sample_output' do %>
    Anna merkkijono: <font color="red">ane</font>
    Muoto ei ole oikea.
  <% end %>


  <h2>Kellonaika</h2>

  <p>
    Säännölliset lausekkeet sopivat tietynlaisiin tilanteisiin. Joissain tapaukseesa lausekkeista tulee liian monimutkaisia, ja merkkijonon "sopivuus" kannattaa tarkastaa muulla tyylillä tai voi olla tarkoituksenmukaista käyttää säännöllisiä lausekkeita vain osaan tarkastuksesta.
  </p>

  <p>
    Tee  metodi <code>public boolean kellonaika(String merkkijono)</code>  ohjelma, joka tarkistaa säännöllisen lausekkeen avulla onko parametrina oleva merkkijono muotoa <code>tt:mm:ss</code> oleva kellonaika (tunnit, minuutit ja sekunnit kaksinumeroisina).
  </p>

  <p>
    Esimerkkitulostuksia metodia käyttävästä ohjelmasta:
  </p>

  <% partial 'partials/sample_output' do %>
    Anna merkkijono: <font color="red">17:23:05</font>
    Muoto on oikea.
  <% end %>

  <% partial 'partials/sample_output' do %>
    Anna merkkijono: <font color="red">abc</font>
    Muoto ei ole oikea.
  <% end %>

  <% partial 'partials/sample_output' do %>
    Anna merkkijono: <font color="red">33:33:33</font>
    Muoto ei ole oikea.
  <% end %>

<% end %>

<p>
  Nykyään lähes kaikista ohjelmointikielistä löytyy tuki säännöllisille lausekkeille. Säännöllisten lausekkeiden teoriaa tarkastellaan muunmuassa kurssilla <em>Laskennan mallit</em>. Lisää säännöllisistä lausekkeista löydät esim. googlaamalla hakusanalla <em>regular expressions java</em> -- kannattaa myös lukea Codinghorror-blogin lyhyt artikkeli <a href="https://blog.codinghorror.com/regex-use-vs-regex-abuse/" target="_blank" rel="noopener">Regex use vs. Regex abuse</a>.
</p>


<% partial 'partials/material_sub_heading' do %>
  Lueteltu tyyppi eli Enum
<% end %>

<p>
  Jos tiedämme muuttujien mahdolliset arvot ennalta, voimme käyttää niiden esittämiseen <code>enum</code>-tyyppistä luokkaa eli <em>lueteltua tyyppiä</em>. Luetellut tyypit ovat oma luokkatyyppinsä rajapinnan ja normaalin luokan lisäksi. Lueteltu tyyppi määritellään avainsanalla <code>enum</code>. Esimerkiksi seuraava <code>Maa</code>-enumluokka määrittelee neljä vakioarvoa: <code>RUUTU</code>, <code>PATA</code>, <code>RISTI</code> ja <code>HERTTA</code>.
</p>

<% partial 'partials/code_highlight' do %>
  public enum Maa {
  RUUTU, PATA, RISTI, HERTTA
  }
<% end %>

<p>
  Yksinkertaisimmassa muodossaan <code>enum</code> luettelee pilkulla erotettuina määrittelemänsä vakioarvot. Lueteltujen tyyppien arvot eli vakiot on yleensä tapana kirjoittaa kokonaan isoin kirjaimin.
</p>

<p>
  Enum luodaan (yleensä) omaan tiedostoon, samaan tapaan kuin luokka tai rajapinta. NetBeansissa Enumin saa luotua valitsemalla projektin kohdalla <em>new/other/java/java enum</em>.
</p>

<p>
  Seuraavassa luokka <code>Kortti</code> jossa maa esitetään enumin avulla:
</p>

<% partial 'partials/code_highlight' do %>
  public class Kortti {

  private int arvo;
  private Maa maa;

  public Kortti(int arvo, Maa maa) {
  this.arvo = arvo;
  this.maa = maa;
  }

  @Override
  public String toString() {
  return maa + " " + arvo;
  }

  public Maa getMaa() {
  return maa;
  }

  public int getArvo() {
  return arvo;
  }
  }
<% end %>

<p>
  Korttia käytetään seuraavasti:
</p>

<% partial 'partials/code_highlight' do %>
  Kortti eka = new Kortti(10, Maa.HERTTA);

  System.out.println(eka);

  if (eka.getMaa() == Maa.PATA) {
  System.out.println("on pata");
  } else {
  System.out.println("ei ole pata");
  }
<% end %>

<p>Tulostuu:</p>

<% partial 'partials/sample_output' do %>
  HERTTA 10
  ei ole pata
<% end %>

<p>
  Huomaamme, että enumin tunnukset tulostuvat mukavasti! Koska kortin maat ovat nyt tyyppiä <code>Maa</code> ei ylemmän esimerkin "järjenvastaiset" kummallisuudet, esim. "maan korottaminen toiseen potenssiin" onnistu. Oraclella on <code>enum</code>-tyyppiin liittyvä sivusto osoitteessa <a href="http://docs.oracle.com/javase/tutorial/java/javaOO/enum.html" target="_blank" rel="noopener">http://docs.oracle.com/javase/tutorial/java/javaOO/enum.html</a>.
</p>



<% partial 'partials/hint', locals: { name: 'Enumien vertailu' } do %>

  <p>
    Ylläolevassa esimerkissä kahta enumia verrattiin yhtäsuuruusmerkkien avulla. Miksi tämä on ok?
  </p>

  <p>
    Jokainen lueteltu arvo saa oman uniikin numerotunnuksen, ja niiden vertailu keskenään yhtäsuuruusmerkillä on ok. Kuten muutkin Javan luokat, myös luetellut arvot perivät Object-luokan ja sen equals-metodin. Luetelluilla luokilla myös equals-metodi vertailee tätä numerotunnusta.
  </p>

  <p>
    Luetellun arvon numeraalisen tunnuksen saa selville metodille <code>ordinal()</code>. Metodi palauttaa käytännössä järjestysnumeron -- jos lueteltu arvo on esitelty ensimmäisenä, on sen järjestysnumero 0. Jos toisena, järjestysnumero on 1, jne.
  </p>

  
  <% partial 'partials/code_highlight' do %>
    public enum Maa {
    RUUTU, PATA, RISTI, HERTTA
    }
  <% end %>

  <% partial 'partials/code_highlight' do %>
    System.out.println(Maa.RUUTU.ordinal());
    System.out.println(Maa.HERTTA.ordinal());
  <% end %>

  <% partial 'partials/sample_output' do %>
    0
    3
  <% end %>
  
<% end %>


<% partial 'partials/material_sub_sub_heading' do %>
  Lueteltujen tyyppien oliomuuttujat
<% end %>

<p>
  Luetellut tyypit voivat sisältää oliomuuttujia. Oliomuuttujien arvot tulee asettaa luetellun tyypin määrittelevän luokan sisäisessä eli näkyvyysmääreen <code>private</code> omaavassa konstruktorissa. Enum-tyyppisillä luokilla ei saa olla <code>public</code>-konstruktoria.
</p>

<p>
  Seuraavassa lueteltu tyyppi <code>Vari</code>, joka sisältää vakioarvot PUNAINEN, VIHREA ja SININEN. Vakioille on määritelty <a href="https://www.w3schools.com/colors/colors_picker.asp" target="_blank" rel="noopener">värikoodin</a> kertova oliomuuttuja:
</p>

<% partial 'partials/code_highlight' do %>
  public enum Vari {
  // konstruktorin parametrit määritellään vakioarvoja lueteltaessa
  PUNAINEN("#FF0000"),
  VIHREA("#00FF00"),
  SININEN("#0000FF");

  private String koodi;        // oliomuuttuja

  private Vari(String koodi) { // konstruktori
  this.koodi = koodi;
  }

  public String getKoodi() {
  return this.koodi;
  }
  }
<% end %>

<p>
  Lueteltua tyyppiä <code>Vari</code> voidaan käyttää esimerkiksi seuraavasti:
</p>

<% partial 'partials/code_highlight' do %>
  System.out.println(Vari.VIHREA.getKoodi());
<% end %>

<% partial 'partials/sample_output' do %>
  #00FF00
<% end %>


<% partial 'partials/material_sub_heading' do %>
  Iteraattori
<% end %>

<p>
  Tarkastellaan seuraavaa luokkaa <code>Kasi</code>, joka mallintaa tietyssä korttipelissä pelaajan kädessä olevien korttien joukkoa:
</p>

<% partial 'partials/code_highlight' do %>
  public class Kasi {
  private List&lt;Kortti&gt; kortit;

  public Kasi() {
  this.kortit = new ArrayList&lt;&gt;();
  }

  public void lisaa(Kortti kortti) {
  this.kortit.add(kortti);
  }

  public void tulosta() {
  this.kortit.stream().forEach(kortti -&gt; {
  System.out.println(kortti);
  });
  }
  }
<% end %>

<p>
  Luokan metodi <code>tulosta</code> tulostaa jokaisen kädessä olevan kortin.
</p>

<p>
  ArrayList ja muut <em>Collection</em>-rajapinnan toteuttavat "oliosäiliöt" toteuttavat rajapinnan <em>Iterable</em>, ja ne voidaan käydä läpi myös käyttäen <em>iteraattoria</em>, eli olioa, joka on varta vasten tarkoitettu tietyn oliokokoelman läpikäyntiin. Seuraavassa on iteraattoria käyttävä versio korttien tulostamisesta:
</p>

<% partial 'partials/code_highlight' do %>
  public void tulosta() {
  Iterator&lt;Kortti&gt; iteraattori = kortit.iterator();

  while (iteraattori.hasNext()) {
  System.out.println(iteraattori.next());
  }
  }
<% end %>

<p>
  Iteraattori pyydetään kortteja sisältävältä listalta <code>kortit</code>. Iteraattori on ikäänkuin "sormi", joka osoittaa aina tiettyä listan sisällä olevaa olioa, ensin ensimmäistä ja sitten seuraavaa jne... kunnes "sormen" avulla on käyty jokainen olio läpi.
</p>

<p>
  Iteraattori tarjoaa muutaman metodin. Metodilla <code>hasNext()</code> kysytään onko läpikäytäviä olioita vielä jäljellä. Jos on, voidaan iteraattorilta pyytää seuraavana vuorossa oleva olio metodilla <code>next()</code>. Metodi siis palauttaa seuraavana läpikäyntivuorossa olevan olion ja laittaa iteraattorin eli "sormen" osoittamaan seuraavana vuorossa olevaa läpikäytävää olioa.
</p>

<p>
  Iteraattorin next-metodin palauttama olioviite voidaan ottaa toki talteen myös muuttujaan, eli metodi <code>tulosta</code> voitaisiin muotoilla myös seuraavasti.
</p>

<% partial 'partials/code_highlight' do %>
  public void tulosta(){
  Iterator&lt;Kortti&gt; iteraattori = kortit.iterator();

  while (iteraattori.hasNext()) {
  Kortti seuraavanaVuorossa = iteraattori.next();
  System.out.println(seuraavanaVuorossa);
  }
  }
<% end %>


<p>
  Tarkastellaan seuraavaksi yhtä iteraattorin käyttökohdetta. Motivoidaan käyttökohde ensin ongelmallisella lähestymistavalla. Yritämme tehdä virran avulla metodia, joka poistaa käsiteltävästä virrasta ne kortit, joiden arvo on annettua arvoa pienempi.
</p>

<% partial 'partials/code_highlight' do %>
  public class Kasi {
  // ...

  public void poistaHuonommat(int arvo) {
  this.kortit.stream().forEach(kortti -&gt; {
  if (kortti.getArvo() &lt; arvo) {
  kortit.remove(kortti);
  }
  });
  }
  }
<% end %>

<p>
  Metodin suoritus aiheuttaa ongelman.
</p>

<% partial 'partials/sample_output' do %>
  Exception in thread "main" java.util.ConcurrentModificationException
  at ...
  Java Result: 1
<% end %>

<p>
  Virheen syynä on se, että listan läpikäynti forEach-metodilla olettaa, ettei listaa muokata läpikäynnin yhteydessä. Listan muokkaaminen (eli tässä tapauksessa alkion poistaminen) aiheuttaa virheen -- voimme ajatella, että komento forEach menee tästä "sekaisin".
</p>

<p>
  Jos listalta halutaan poistaa osa olioista läpikäynnin aikana osa, tulee tämä tehdä iteraattoria käyttäen. Iteraattori-olion metodia <code>remove</code> kutsuttaessa listalta poistetaan siististi se alkio jonka iteraattori palautti edellisellä metodin <code>next</code> kutsulla. Toimiva versio metodista seuraavassa:
</p>

<% partial 'partials/code_highlight' do %>
  public class Kasi {
  // ...

  public void poistaHuonommat(int arvo) {
  Iterator&lt;Kortti&gt; iteraattori = kortit.iterator();

  while (iteraattori.hasNext()) {
  if (iteraattori.next().getArvo() &lt; arvo) {
  // poistetaan listalta olio jonka edellinen next-metodin kutsu palautti
  iteraattori.remove();
  }
  }
  }
  }
<% end %>


<% partial 'partials/exercise', locals: { name: 'Enum ja Iteraattori (4 osaa)' } do %>

  <p>
    Tehdään ohjelma pienen yrityksen henkilöstön hallintaan.
  </p>

  <h2>Koulutus</h2>

  <p>
    Tee pakkaukseen <code>henkilosto</code> lueteltu tyyppi eli enum <code>Koulutus</code> jolla on tunnukset <code>FT</code> (tohtori), <code>FM</code> (maisteri), <code>LuK</code> (kandidaatti), <code>FilYO</code> (ylioppilas).
  </p>

  <h2>Henkilo</h2>

  <p>
    Tee pakkaukseen <code>henkilosto</code> luokka Luokka <code>Henkilo</code>. Henkilölle annetaan konstruktorin parametrina annettava nimi ja koulutus. Henkilöllä on myös koulutuksen kertova metodi <code>public Koulutus getKoulutus()</code> sekä alla olevan esimerkin mukaista jälkeä tekevä <code>toString</code>-metodi.
  </p>

  <% partial 'partials/code_highlight' do %>
    Henkilo vilma = new Henkilo("Vilma", Koulutus.FT);
    System.out.println(vilma);
  <% end %>

  <% partial 'partials/sample_output' do %>
    Vilma, FT
  <% end %>


  <h2>Tyontekijat</h2>

  <p>
    Tee pakkaukseen <code>henkilosto</code> luokka Luokka <code>Tyontekijat</code>. Työntekijät-olio sisältää listan Henkilo-olioita. Luokalla on parametriton konstruktori ja seuraavat metodit:
  </p>

  <ul>
    <li><code>public void lisaa(Henkilo lisattava)</code> lisää parametrina olevan henkilön työntekijäksi</li>
    <li><code>public void lisaa(List&lt;Henkilo&gt; lisattavat)</code> lisää parametrina olevan listan henkilöitä työntekijöiksi</li>
    <li><code>public void tulosta()</code> tulostaa kaikki työntekijät</li>
    <li><code>public void tulosta(Koulutus koulutus)</code> tulostaa työntekijät joiden koulutus on sama kuin parametrissa määritelty koulutus</li>
  </ul>

  <p>
    <strong>HUOM:</strong> Luokan <code>Tyontekijat</code> <code>tulosta</code>-metodit on toteutettava iteraattoria käyttäen!
  </p>

  
  <h2>Irtisanominen</h2>

  <p>
    Tee luokalle  <code>Tyontekijat</code> metodi <code>public void irtisano(Koulutus koulutus)</code> joka poistaa Työntekijöiden joukosta kaikki henkilöt joiden koulutus on sama kuin metodin parametrina annettu.
  </p>

  <p>
    <strong>HUOM:</strong> toteuta metodi iteraattoria käyttäen!
  </p>

  <p>
    Seuraavassa esimerkki luokan käytöstä:
  </p>

  <% partial 'partials/code_highlight' do %>
    Tyontekijat yliopisto = new Tyontekijat();
    yliopisto.lisaa(new Henkilo("Petrus", Koulutus.FT));
    yliopisto.lisaa(new Henkilo("Arto", Koulutus.FilYO));
    yliopisto.lisaa(new Henkilo("Elina", Koulutus.FT));

    yliopisto.tulosta();

    yliopisto.irtisano(Koulutus.FilYO);

    System.out.println("==");

    yliopisto.tulosta();
  <% end %>

  <p>
    Tulostuu:
  </p>

  <% partial 'partials/sample_output' do %>
    Petrus, FT
    Arto, FilYO
    Elina, FT
    ==
    Petrus, FT
    Elina, FT
  <% end %>

<% end %>

<% partial 'partials/exercise', locals: { name: 'Kortit ojennukseen (6 osaa)' } do %>

  <p>
    Tehtäväpohjan mukana on luokka, jonka oliot kuvaavat pelikortteja. Kortilla on arvo ja maa. Kortin arvo on esitetään numerona <em>2, 3, ..., 14</em> ja maa <em>Risti, Ruutu, Hertta</em> tai <em>Pata</em>. Ässä on siis arvo 14. Arvo esitetään kokonaislukuna ja maa enum-tyyppisenä oliona. Kortilla on myös metodi toString, jota käyttäen kortin arvo ja maa tulostuvat "ihmisystävällisesti".
  </p>

  <p>
    Korttien luominen tapahtuu seuraavasti. 
  </p>

  <% partial 'partials/code_highlight' do %>
    Kortti eka = new Kortti(2, Maa.RUUTU);
    Kortti toka = new Kortti(14, Maa.PATA);
    Kortti kolmas = new Kortti(12, Maa.HERTTA);

    System.out.println(eka);
    System.out.println(toka);
    System.out.println(kolmas);
  <% end %>

  <p>
    Tulostuu:
  </p>

  <% partial 'partials/sample_output' do %>
    RUUTU 2
    PATA A
    HERTTA Q
  <% end %>

  
  <h2>Kortti-luokasta Comparable</h2>

  <p>
    Tee Kortti-luokasta Comparable. Toteuta <code>compareTo</code>-metodi niin, että korttien järjestys on arvon mukaan nouseva. Jos verrattavien Korttien arvot ovat samat, verrataan niitä maan perusteella nousevassa järjestyksessä: <em>risti ensin, ruutu toiseksi, hertta kolmanneksi, pata viimeiseksi.</em>
  </p>

  <p>
    Maiden järjestämisessä apua löytynee <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Enum.html#ordinal--"  target="_blank" norel>Enum-luokan ordinal-metodista</a>.
  </p>

  <p>
    Järjestyksessä pienin kortti siis olisi risti kakkonen ja suurin pataässä.
  </p>

  
  <h2>Käsi</h2>

  <p>
    Tee seuraavaksi luokka <code>Kasi</code> joka edustaa pelaajan kädessään pitämää korttien joukkoa. Tee kädelle seuraavat metodit:
  </p>

  <ul>
    <li><code>public void lisaa(Kortti kortti)</code> lisää käteen kortin</li>
    <li><code>public void tulosta()</code> tulostaa kädessä olevat kortit alla olevan esimerkin tyylillä</li>
  </ul>

  <% partial 'partials/code_highlight' do %>
    Kasi kasi = new Kasi();

    kasi.lisaa(new Kortti(2, Maa.RUUTU));
    kasi.lisaa(new Kortti(14, Maa.PATA));
    kasi.lisaa(new Kortti(12, Maa.HERTTA));
    kasi.lisaa(new Kortti(2, Maa.PATA));

    kasi.tulosta();
  <% end %>

  <p>
    Tulostuu:
  </p>

  <% partial 'partials/sample_output' do %>
    RUUTU 2
    PATA A
    HERTTA Q
    PATA 2
  <% end %>

  <p>
    Käytä ArrayListiä korttien tallentamiseen.
  </p>


  <h2>Käden järjestäminen</h2>

  <p>
    Tee kädelle metodi <code>public void jarjesta()</code> jota kutsumalla käden sisällä olevat kortit menevät suuruusjärjestykseen. Järjestämisen jälkeen kortit tulostuvat järjestyksessä:
  </p>

  <% partial 'partials/code_highlight' do %>
    Kasi kasi = new Kasi();

    kasi.lisaa(new Kortti(2, Maa.RUUTU));
    kasi.lisaa(new Kortti(14, Maa.PATA));
    kasi.lisaa(new Kortti(12, Maa.HERTTA));
    kasi.lisaa(new Kortti(2, Maa.PATA));

    kasi.jarjesta();

    kasi.tulosta();
  <% end %>

  <p>
    Tulostuu:
  </p>

  <% partial 'partials/sample_output' do %>
    RUUTU 2
    PATA 2
    HERTTA Q
    PATA A
  <% end %>

  
  <h2>Käsien vertailu</h2>

  <p>
    Eräässä korttipelissä kahdesta korttikädestä arvokkaampi on se, jonka sisältämien korttien arvon summa on suurempi. Tee luokasta <code>Kasi</code> vertailtava tämän kriteerin mukaan, eli laita luokka toteuttamaan rajapinta <code>Comparable&lt;Kasi&gt;</code>.
  </p>

  <p>
    Esimerkkiohjelma, jossa vertaillaan käsiä:
  </p>

  <% partial 'partials/code_highlight' do %>
    Kasi kasi1 = new Kasi();

    kasi1.lisaa(new Kortti(2, Maa.RUUTU));
    kasi1.lisaa(new Kortti(14, Maa.PATA));
    kasi1.lisaa(new Kortti(12, Maa.HERTTA));
    kasi1.lisaa(new Kortti(2, Maa.PATA));

    Kasi kasi2 = new Kasi();

    kasi2.lisaa(new Kortti(11, Maa.RUUTU));
    kasi2.lisaa(new Kortti(11, Maa.PATA));
    kasi2.lisaa(new Kortti(11, Maa.HERTTA));

    int vertailu = kasi1.compareTo(kasi2);

    if (vertailu &lt; 0) {
    System.out.println("arvokkaampi käsi sisältää kortit");
    kasi2.tulosta();
    } else if (vertailu &gt; 0){
    System.out.println("arvokkaampi käsi sisältää kortit");
    kasi1.tulosta();
    } else {
    System.out.println("kädet yhtä arvokkaat");
    }
  <% end %>

  <p>Tulostuu</p>

  <% partial 'partials/sample_output' do %>
    arvokkaampi käsi sisältää kortit
    RUUTU J
    PATA J
    HERTTA J
  <% end %>

  
  <h2>Korttien järjestäminen eri kriteerein</h2>

  <p>
    Entä jos haluaisimme välillä järjestää kortit hieman eri tavalla, esim. kaikki saman maan kortit peräkkäin? Luokalla voi olla vain yksi compareTo-metodi, joten joudumme muunlaisia järjestyksiä saadaksemme turvautumaan muihin keinoihin.
  </p>

  <p>
    Vaihtoehtoiset järjestämistavat toteutetaan erillisten vertailun suorittavien luokkien avulla. Korttien vaihtoehtoisten järjestyksen määräävän luokkien tulee toteuttaa <code>Comparator&lt;Kortti&gt;</code>-rajapinta. Järjestyksen määräävän luokan olio vertailee kahta parametrina saamaansa korttia. Metodeja on ainoastaan yksi compare(Kortti k1, Kortti k2), jonka tulee palauttaa negatiivinen arvo, jos kortti k1 on järjestyksessä ennen korttia k2, positiivinen arvo jos k2 on järjestyksessä ennen k1:stä ja 0 muuten.
  </p>

  <p>
    Periaatteena on luoda jokaista järjestämistapaa varten oma vertailuluokka, esim. saman maan kortit vierekkäin vievän järjestyksen määrittelevä luokka:
  </p>

  <% partial 'partials/code_highlight' do %>
    import java.util.Comparator;

    public class SamatMaatVierekkain implements Comparator&lt;Kortti&gt; {
    public int compare(Kortti k1, Kortti k2) {
    return k1.getMaa().ordinal() - k2.getMaa().ordinal();
    }
    }
  <% end %>

  <p>
    Maittainen järjestys on sama kuin kortin metodin <code>compareTo</code> maille määrittelemä järjestys eli <em>ristit ensin, ruudut toiseksi, hertat kolmanneksi, padat viimeiseksi.</em>
  </p>

  <p>
    Järjestäminen tapahtuu edelleen luokan Collections metodin sort avulla. Metodi saa nyt toiseksi parametrikseen järjestyksen määräävän luokan olion:
  </p>
  
  <% partial 'partials/code_highlight' do %>
    ArrayList&lt;Kortti&gt; kortit = new ArrayList&lt;&gt;();

    kortit.add(new Kortti(3, Maa.PATA));
    kortit.add(new Kortti(2, Maa.RUUTU));
    kortit.add(new Kortti(14, Maa.PATA));
    kortit.add(new Kortti(12, Maa.HERTTA));
    kortit.add(new Kortti(2, Maa.PATA));

    SamatMaatVierekkain samatMaatVierekkainJarjestaja = new SamatMaatVierekkain();
    Collections.sort(kortit, samatMaatVierekkainJarjestaja);

    kortit.stream().forEach(k -&gt; System.out.println(k));
  <% end %>

  <p>
    Tulostuu:
  </p>

  <% partial 'partials/sample_output' do %>
    RUUTU 2
    HERTTA Q
    PATA 3
    PATA A
    PATA 2
  <% end %>

  <p>
    Järjestyksen määrittelevä olio voidaan myös luoda suoraan sort-kutsun yhteydessä:
  </p>
  
  <% partial 'partials/code_highlight' do %>
    Collections.sort(kortit, new SamatMaatVierekkain());
  <% end %>


  <p>
    Tarkempia ohjeita vertailuluokkien tekemiseen <a href="http://leepoint.net/data/collections/comparators.html">täällä</a>
  </p>

  <p>
    Tee nyt luokka Comparator-rajapinnan toteuttava luokka <code>SamatMaatVierekkainArvojarjestykseen</code> jonka avulla saat kortit muuten samanlaiseen järjestykseen kuin edellisessä esimerkissä paitsi, että saman maan kortit järjestyvät arvon mukaisesti.
  </p>


  <h2>Käden järjestäminen maittain</h2>

  <p>
    Lisää luokalle <code>Kasi</code> metodi <code>public void jarjestaMaittain()</code> jota kutsumalla käden sisällä olevat kortit menevät edellisen tehtävän vertailijan määrittelemään järjestykseen. Järjestämisen jälkeen kortit tulostuvat järjestyksessä:
  </p>

  <% partial 'partials/code_highlight' do %>
    Kasi kasi = new Kasi();

    kasi.lisaa(new Kortti(12, Maa.HERTTA));
    kasi.lisaa(new Kortti(4, Maa.PATA));
    kasi.lisaa(new Kortti(2, Maa.RUUTU));
    kasi.lisaa(new Kortti(14, Maa.PATA));
    kasi.lisaa(new Kortti(7, Maa.HERTTA));
    kasi.lisaa(new Kortti(2, Maa.PATA));

    kasi.jarjestaMaittain();

    kasi.tulosta();
  <% end %>
  
  <p>
    Tulostuu:
  </p>

  <% partial 'partials/sample_output' do %>
    RUUTU 2
    HERTTA 7
    HERTTA Q
    PATA 2
    PATA 4
    PATA A
  <% end %>


<% end %>



<% partial 'partials/exercise', locals: { name: 'Elokuvien suosittelija (8 osaa)' } do %>

  <p>
    <a href="https://signup.netflix.com/" target="_blank" rel="noopener">Netflix</a> lupasi lokakuussa 2006 miljoona dollaria henkilölle tai ryhmälle, joka kehittäisi ohjelman, joka on 10% parempi elokuvien suosittelussa kuin heidän oma ohjelmansa. Kilpailu ratkesi syyskuussa 2009 (<a href="http://www.netflixprize.com/" target="_blank" rel="noopener">http://www.netflixprize.com/</a>).
  </p>

  <p>
    Rakennetaan tässä tehtävässä ohjelma elokuvien suositteluun. Alla on sen toimintaesimerkki:
  </p>

  <% partial 'partials/code_highlight' do %>
    ArvioRekisteri arviot = new ArvioRekisteri();

    Elokuva tuulenViemaa = new Elokuva("Tuulen viemää");
    Elokuva hiljaisetSillat = new Elokuva("Hiljaiset sillat");
    Elokuva eraserhead = new Elokuva("Eraserhead");

    Henkilo matti = new Henkilo("Matti");
    Henkilo pekka = new Henkilo("Pekka");
    Henkilo mikke = new Henkilo("Mikke");
    Henkilo thomas = new Henkilo("Thomas");

    arviot.lisaaArvio(matti, tuulenViemaa, Arvio.HUONO);
    arviot.lisaaArvio(matti, hiljaisetSillat, Arvio.HYVA);
    arviot.lisaaArvio(matti, eraserhead, Arvio.OK);

    arviot.lisaaArvio(pekka, tuulenViemaa, Arvio.OK);
    arviot.lisaaArvio(pekka, hiljaisetSillat, Arvio.HUONO);
    arviot.lisaaArvio(pekka, eraserhead, Arvio.VALTTAVA);

    arviot.lisaaArvio(mikke, eraserhead, Arvio.HUONO);


    Suosittelija suosittelija = new Suosittelija(arviot);
    System.out.println(thomas + " suositus: " + suosittelija.suositteleElokuva(thomas));
    System.out.println(mikke + " suositus: " + suosittelija.suositteleElokuva(mikke));
  <% end %>

  <% partial 'partials/sample_output' do %>
    Thomas suositus: Hiljaiset sillat
    Mikke suositus: Tuulen viemää
  <% end %>

  <p>
    Ohjelma osaa suositella elokuvia niiden yleisen arvion perusteella, sekä henkilökohtaisten henkilön antaminen arvioiden perusteella. Lähdetään rakentamaan ohjelmaa.
  </p>


  <h2>Henkilo ja Elokuva</h2>

  <p>
    Luo pakkaus <code>suosittelija.domain</code> ja lisää sinne luokat <code>Henkilo</code> ja <code>Elokuva</code>. Kummallakin luokalla on julkinen konstruktori <code>public <em>Luokka</em>(String nimi)</code>, sekä metodi <code>public String getNimi()</code>, joka palauttaa konstruktorissa saadun nimen.
  </p>

  <% partial 'partials/code_highlight' do %>
    Henkilo henkilo = new Henkilo("Pekka");
    Elokuva elokuva = new Elokuva("Eraserhead");

    System.out.println(henkilo.getNimi() + " ja " + elokuva.getNimi());
  <% end %>

  <% partial 'partials/sample_output' do %>
    Pekka ja Eraserhead
  <% end %>

  <p>
    Lisää luokille myös <code>public String toString()</code>-metodi, joka palauttaa konstruktorissa parametrina annetun nimen, sekä korvaa metodit <code>equals</code> ja <code>hashCode</code>.
  </p>

  <p>
    Korvaa <code>equals</code> siten että samuusvertailu tapahtuu oliomuuttujan <code>nimi</code> perusteella. Metodi hashCode kannattaa generoida automaattisesti seuraavan ohjeen mukaan:
  </p>

  <p>
    <em>
      NetBeans tarjoaa metodien equals ja hashCode automaattisen luonnin. Voit valita valikosta Source -> Insert Code, ja valita aukeavasta listasta equals() and hashCode(). Tämän jälkeen NetBeans kysyy oliomuuttujat joita metodeissa käytetään.
    </em>
  </p>


  <h2>Arvio</h2>

  <p>
    Luo pakkaukseen <code>suosittelija.domain</code> lueteltu tyyppi <code>Arvio</code>. Enum-luokalla <code>Arvio</code> on julkinen metodi <code>public int getArvo()</code>, joka palauttaa arvioon liittyvän arvon. Arviotunnusten ja niihin liittyvien arvosanojen tulee olla seuraavat:
  </p>

  <table class="table">
    <tr><th>Tunnus</th><th>Arvo</th></tr>
    <tr><td>HUONO</td><td>-5</td></tr>
    <tr><td>VALTTAVA</td><td>-3</td></tr>
    <tr><td>EI_NAHNYT</td><td>0</td></tr>
    <tr><td>NEUTRAALI</td><td>1</td></tr>
    <tr><td>OK</td><td>3</td></tr>
    <tr><td>HYVA</td><td>5</td></tr>
  </table>

  <p>
    Luokkaa voi käyttää seuraavasti:
  </p>

  <% partial 'partials/code_highlight' do %>
    Arvio annettu = Arvio.HYVA;
    System.out.println("Arvio " + annettu + ", arvo " + annettu.getArvo());
    annettu = Arvio.NEUTRAALI;
    System.out.println("Arvio " + annettu + ", arvo " + annettu.getArvo());
  <% end %>

  <% partial 'partials/sample_output' do %>
    Arvio HYVA, arvo 5
    Arvio NEUTRAALI, arvo 1
  <% end %>


  <h2>ArvioRekisteri, osa 1</h2>

  <p>
    Aloitetaan arvioiden varastointiin liittyvän palvelun toteutus.
  </p>

  <p>
    Luo pakkaukseen <code>suosittelija</code> luokka <code>ArvioRekisteri</code>, jolla on konstruktori <code>public ArvioRekisteri()</code> sekä seuraavat metodit:
  </p>

  <ul>
    <li><code>public void lisaaArvio(Elokuva elokuva, Arvio arvio)</code> lisää arviorekisteriin parametrina annetulle elokuvalle uuden arvion. Samalla elokuvalla voi olla useita samanlaisiakin arvioita.</li>
    <li><code>public List&lt;Arvio&gt; annaArviot(Elokuva elokuva)</code> palauttaa elokuvalle lisätyt arviot listana.</li>
    <li><code>public Map&lt;Elokuva, List&lt;Arvio&gt;&gt; elokuvienArviot()</code> palauttaa mapin, joka sisältää arvioidut elokuvat avaimina. Jokaiseen elokuvaan liittyy lista, joka sisältää elokuvaan lisatyt arviot.</li>
  </ul>

  <p>
    Testaa metodien toimintaa seuraavalla lähdekoodilla:
  </p>

  <% partial 'partials/code_highlight' do %>
    Elokuva hiljaisetSillat = new Elokuva("Hiljaiset sillat");
    Elokuva eraserhead = new Elokuva("Eraserhead");

    ArvioRekisteri rekisteri = new ArvioRekisteri();
    rekisteri.lisaaArvio(eraserhead, Arvio.HUONO);
    rekisteri.lisaaArvio(eraserhead, Arvio.HUONO);
    rekisteri.lisaaArvio(eraserhead, Arvio.HYVA);

    rekisteri.lisaaArvio(hiljaisetSillat, Arvio.HYVA);
    rekisteri.lisaaArvio(hiljaisetSillat, Arvio.OK);

    System.out.println("Kaikki arviot: " + rekisteri.elokuvienArviot());
    System.out.println("Arviot Eraserheadille: " + rekisteri.annaArviot(eraserhead));
  <% end %>

  <% partial 'partials/sample_output' do %>
    Kaikki arviot: {Hiljaiset sillat=[HYVA, OK], Eraserhead=[HUONO, HUONO, HYVA]}
    Arviot Eraserheadille: [HUONO, HUONO, HYVA]
  <% end %>


  <h2>ArvioRekisteri, osa 2</h2>

  <p>
    Lisätään seuraavaksi mahdollisuus henkilökohtaisten arvioiden lisäämiseen.
  </p>

  <p>
    Lisää luokkaan <code>ArvioRekisteri</code> seuraavat metodit:
  </p>

  <ul>
    <li><code>public void lisaaArvio(Henkilo henkilo, Elokuva elokuva, Arvio arvio)</code> lisää parametrina annetulle elokuvalle tietyn henkilön tekemän arvion. Sama henkilö voi arvioida tietyn elokuvan vain kertaalleen. Henkilön tekemä arvio tulee myös lisätä kaikkiin elokuviin liittyviin arvioihin.</li>
    <li><code>public Arvio haeArvio(Henkilo henkilo, Elokuva elokuva)</code> palauttaa parametrina annetun henkilön tekemän arvion parametrina annetulle elokuvalle. Jos henkilö ei ole arvioinut kyseistä elokuvaa, palauta arvio <code>Arvio.EI_NAHNYT</code>.</li>
    <li><code>public Map&lt;Elokuva, Arvio&gt; annaHenkilonArviot(Henkilo henkilo)</code> palauttaa hajautustaulun, joka sisältää henkilön tekemät arviot. Hajautustaulun avaimena on arvioidut elokuvat, arvoina arvioituihin elokuviin liittyvät arviot. Jos henkilö ei ole arvioinut yhtään elokuvaa, palautetaan tyhjä hajautustaulu.</li>
    <li><code>public List&lt;Henkilo&gt; arvioijat()</code> palauttaa listan henkilöistä jotka ovat arvioineet elokuvia.</li></ul>

  <p>
    Henkilöiden tekemät arviot kannattanee tallentaa hajautustauluun, jossa avaimena on henkilö. Arvona hajautustaulussa on toinen hajautustaulu, jossa avaimena on elokuva ja arvona arvio.
  </p>

  <p>
    Testaa paranneltua <code>ArvioRekisteri</code>-luokkaa seuraavalla lähdekoodipätkällä:
  </p>

  <% partial 'partials/code_highlight' do %>
    ArvioRekisteri arviot = new ArvioRekisteri();

    Elokuva tuulenViemaa = new Elokuva("Tuulen viemää");
    Elokuva eraserhead = new Elokuva("Eraserhead");

    Henkilo matti = new Henkilo("Matti");
    Henkilo pekka = new Henkilo("Pekka");

    arviot.lisaaArvio(matti, tuulenViemaa, Arvio.HUONO);
    arviot.lisaaArvio(matti, eraserhead, Arvio.OK);

    arviot.lisaaArvio(pekka, tuulenViemaa, Arvio.OK);
    arviot.lisaaArvio(pekka, eraserhead, Arvio.OK);

    System.out.println("Arviot Eraserheadille: " + arviot.annaArviot(eraserhead));
    System.out.println("Matin arviot: " + arviot.annaHenkilonArviot(matti));
    System.out.println("Arvioijat: " + arviot.arvioijat());
  <% end %>

  <% partial 'partials/sample_output' do %>
    Arviot Eraserheadille: [OK, OK]
    Matin arviot: {Tuulen viemää=HUONO, Eraserhead=OK}
    Arvioijat: [Pekka, Matti]
  <% end %>

  <p>
    Luodaan seuraavaksi muutama apuluokka arviointien helpottamiseksi.
  </p>


  <h2>HenkiloComparator</h2>

  <p>
    Luo pakkaukseen <code>suosittelija.comparator</code> luokka <code>HenkiloComparator</code>. Luokan <code>HenkiloComparator</code> tulee toteuttaa rajapinta <code>Comparator&lt;Henkilo&gt;</code>, ja sillä pitää olla konstruktori <code>public HenkiloComparator(Map&lt;Henkilo, Integer&gt; henkiloidenSamuudet)</code>. Luokkaa <code>HenkiloComparator</code> käytetään myöhemmin henkilöiden järjestämiseen henkilöön liittyvän luvun perusteella.
  </p>

  <p>
    HenkiloComparator-luokan tulee mahdollistaa henkilöiden järjestäminen henkilöön liittyvän luvun perusteella.
  </p>

  <p>
    Testaa luokan toimintaa seuraavalla lähdekoodilla:
  </p>

  <% partial 'partials/code_highlight' do %>
    Henkilo matti = new Henkilo("Matti");
    Henkilo pekka = new Henkilo("Pekka");
    Henkilo mikke = new Henkilo("Mikke");
    Henkilo thomas = new Henkilo("Thomas");

    Map&lt;Henkilo, Integer&gt; henkiloidenSamuudet = new HashMap&lt;&gt;();
    henkiloidenSamuudet.put(matti, 42);
    henkiloidenSamuudet.put(pekka, 134);
    henkiloidenSamuudet.put(mikke, 8);
    henkiloidenSamuudet.put(thomas, 82);

    List&lt;Henkilo&gt; henkilot = Arrays.asList(matti, pekka, mikke, thomas);
    System.out.println("Henkilöt ennen järjestämistä: " + henkilot);

    Collections.sort(henkilot, new HenkiloComparator(henkiloidenSamuudet));
    System.out.println("Henkilöt järjestämisen jälkeen: " + henkilot);
  <% end %>

  <% partial 'partials/sample_output' do %>
    Henkilöt ennen järjestämistä: [Matti, Pekka, Mikke, Thomas]
    Henkilöt järjestämisen jälkeen: [Pekka, Thomas, Matti, Mikke]
  <% end %>


  <h2>ElokuvaComparator</h2>

  <p>
    Luo pakkaukseen <code>suosittelija.comparator</code> luokka <code>ElokuvaComparator</code>. Luokan <code>ElokuvaComparator</code> tulee toteuttaa rajapinta <code>Comparator&lt;Elokuva&gt;</code>, ja sillä pitää olla konstruktori <code>public ElokuvaComparator(Map&lt;Elokuva, List&lt;Arvio&gt;&gt; arviot)</code>. Luokkaa <code>ElokuvaComparator</code> käytetään myöhemmin elokuvien järjestämiseen niiden arvioiden perusteella.
  </p>

  <p>
    ElokuvaComparator-luokan tulee tarjota mahdollisuus elokuvien järjestäminen niiden saamien arvosanojen keskiarvon perusteella. Korkeimman keskiarvon saanut elokuva tulee ensimmäisenä, matalimman keskiarvon saanut viimeisenä.
  </p>

  <p>
    Testaa luokan toimintaa seuraavalla lähdekoodilla:
  </p>

  <% partial 'partials/code_highlight' do %>
    ArvioRekisteri arviot = new ArvioRekisteri();

    Elokuva tuulenViemaa = new Elokuva("Tuulen viemää");
    Elokuva hiljaisetSillat = new Elokuva("Hiljaiset sillat");
    Elokuva eraserhead = new Elokuva("Eraserhead");

    Henkilo matti = new Henkilo("Matti");
    Henkilo pekka = new Henkilo("Pekka");
    Henkilo mikke = new Henkilo("Mikke");

    arviot.lisaaArvio(matti, tuulenViemaa, Arvio.HUONO);
    arviot.lisaaArvio(matti, hiljaisetSillat, Arvio.HYVA);
    arviot.lisaaArvio(matti, eraserhead, Arvio.OK);

    arviot.lisaaArvio(pekka, tuulenViemaa, Arvio.OK);
    arviot.lisaaArvio(pekka, hiljaisetSillat, Arvio.HUONO);
    arviot.lisaaArvio(pekka, eraserhead, Arvio.VALTTAVA);

    arviot.lisaaArvio(mikke, eraserhead, Arvio.HUONO);

    Map&lt;Elokuva, List&lt;Arvio&gt;&gt; elokuvienArviot = arviot.elokuvienArviot();

    List&lt;Elokuva&gt; elokuvat = Arrays.asList(tuulenViemaa, hiljaisetSillat, eraserhead);
    System.out.println("Elokuvat ennen järjestämistä: " + elokuvat);

    Collections.sort(elokuvat, new ElokuvaComparator(elokuvienArviot));
    System.out.println("Elokuvat järjestämisen jälkeen: " + elokuvat);
  <% end %>

  <% partial 'partials/sample_output' do %>
    Elokuvat ennen järjestämistä: [Tuulen viemää, Hiljaiset sillat, Eraserhead]
    Elokuvat järjestämisen jälkeen: [Hiljaiset sillat, Tuulen viemää, Eraserhead]
  <% end %>


  <h2>Suosittelija, osa 1</h2>

  <p>
    Toteuta pakkaukseen <code>suosittelija</code> luokka <code>Suosittelija</code>. Luokan <code>Suosittelija</code> konstruktori saa parametrinaan <code>ArvioRekisteri</code>-tyyppisen olion. Suosittelija käyttää arviorekisterissä olevia arvioita suositusten tekemiseen.
  </p>

  <p>
    Toteuta luokalle metodi <code>public Elokuva suositteleElokuva(Henkilo henkilo)</code>, joka suosittelee henkilölle elokuvia.
  </p>

  <p>
    Toteuta metodi ensin siten, että se suosittelee aina elokuvaa, jonka arvioiden arvosanojen keskiarvo on suurin. Vinkki: Tarvitset parhaan elokuvan selvittämiseen ainakin aiemmin luotua <code>ElokuvaComparator</code>-luokkaa, luokan <code>ArvioRekisteri</code> metodia <code>public Map&lt;Elokuva, List&lt;Arvio&gt;&gt; elokuvienArviot()</code>, sekä listaa olemassaolevista elokuvista.
  </p>

  <p>
    Testaa ohjelman toimimista seuraavalla lähdekoodilla:
  </p>

  <% partial 'partials/code_highlight' do %>
    ArvioRekisteri arviot = new ArvioRekisteri();

    Elokuva tuulenViemaa = new Elokuva("Tuulen viemää");
    Elokuva hiljaisetSillat = new Elokuva("Hiljaiset sillat");
    Elokuva eraserhead = new Elokuva("Eraserhead");

    Henkilo matti = new Henkilo("Matti");
    Henkilo pekka = new Henkilo("Pekka");
    Henkilo mikke = new Henkilo("Mikael");

    arviot.lisaaArvio(matti, tuulenViemaa, Arvio.HUONO);
    arviot.lisaaArvio(matti, hiljaisetSillat, Arvio.HYVA);
    arviot.lisaaArvio(matti, eraserhead, Arvio.OK);

    arviot.lisaaArvio(pekka, tuulenViemaa, Arvio.OK);
    arviot.lisaaArvio(pekka, hiljaisetSillat, Arvio.VALTTAVA);
    arviot.lisaaArvio(pekka, eraserhead, Arvio.VALTTAVA);

    Suosittelija suosittelija = new Suosittelija(arviot);
    Elokuva suositeltu = suosittelija.suositteleElokuva(mikke);
    System.out.println("Mikaelille suositeltu elokuva oli: " + suositeltu);
  <% end %>

  <% partial 'partials/sample_output' do %>
    Mikaelille suositeltu elokuva oli: Hiljaiset sillat
  <% end %>

  <p>
    Nyt tekemämme ensimmäinen vaihe toimii oikein ainoastaan henkilöille, jotka eivät ole vielä arvostelleet yhtään elokuvaa. Heidän elokuvamaustaanhan on mahdoton sanoa mitään ja paras arvaus on suositella heille keskimäärin parhaan arvosanan saanutta elokuvaa.
  </p>


  <h2>Suosittelija, osa 2</h2>

  <p>
    <em>
      Huom! Tehtävä on haastava. Kannattaa tehdä ensin muut tehtävät ja palata tähän myöhemmin. Voit palauttaa tehtäväsarjan TMC:hen vaikket saakaan tätä tehtävää tehdyksi, aivan kuten lähes kaikkien muidenkin tehtävien kohdalla.
    </em>
  </p>

  <p>
    Valitettavasti tämän osan virhediagnostiikkakaan ei ole samaa luokkaa kuin edellisissä kohdissa.
  </p>

  <p>
    Jos henkilöt ovat lisänneet omia suosituksia suosituspalveluun, tiedämme jotain heidän elokuvamaustaan. Laajennetaan suosittelijan toiminnallisuutta siten, että se luo henkilökohtaisen suosituksen jos henkilö on jo arvioinut elokuvia. Edellisessä osassa toteutettu toiminnallisuus tulee säilyttää: Jos henkilö ei ole arvioinut yhtäkään elokuvaa, hänelle suositellaan elokuva arvosanojen perusteella.
  </p>

  <p>
    Henkilökohtaiset suositukset perustuvat henkilön tekemien arvioiden samuuteen muiden henkilöiden tekemien arvioiden kanssa. Pohditaan seuraavaa taulukkoa, missä ylärivillä on elokuvat, ja vasemmalla on arvioita tehneet henkilöt. Taulukon solut kuvaavat annettuja arvioita.
  </p>

  <table class="table">
    <tr><th>Henkilo \ Elokuva</th><td>Tuulen viemää</td><td>Hiljaiset sillat</td><td>Eraserhead</td><td>Blues Brothers</td></tr>
    <tr><td>Matti</td><td>HUONO (-5)</td><td>HYVA (5)</td><td>OK (3)</td><td>-</td></tr>
    <tr><td>Pekka</td><td>OK (3)</td><td>-</td><td>HUONO (-5)</td><td>VALTTAVA (-3)</td></tr>
    <tr><td>Mikael</td><td>-</td><td>-</td><td>HUONO (-5)</td><td>-</td></tr>
    <tr><td>Thomas</td><td>-</td><td>HYVA (5)</td><td>-</td><td>HYVA (5)</td></tr>
  </table>

  <p>
    Kun haluamme hakea Mikaelille sopivaa elokuvaa, tutkimme Mikaelin samuutta kaikkien muiden arvioijien kesken. Samuus lasketaan arvioiden perusteella: samuus on kummankin katsomien elokuvien arvioiden tulojen summa. Esimerkiksi Mikaelin ja Thomasin samuus on 0, koska Mikael ja Thomas eivät ole katsoneet yhtäkään samaa elokuvaa.
  </p>

  <p>
    Mikaelin ja Pekan samuutta laskettaessa yhteisten elokuvien tulojen summa olisi 25. Mikael ja Pekka ovat katsoneet vain yhden yhteisen elokuvan, ja kumpikin antaneet sille arvosanan huono (-5).
  </p>

  <% partial 'partials/sample_output' do %>
    -5 * -5 = 25
  <% end %>

  <p>
    Mikaelin ja Matin samuus on -15. Mikael ja Matti ovat myös katsoneet vain yhden yhteisen elokuvan. Mikael antoi elokuvalle arvosanan huono (-5), Matti antoi sille arvosanan ok (3).
  </p>

  <% partial 'partials/sample_output' do %>
    -5 * 3 = -15
  <% end %>

  <p>
    Näiden perusteella Mikaelille suositellaan elokuvia Pekan elokuvamaun mukaan: suosituksena on elokuva Tuulen viemää.
  </p>

  <p>
    Kun taas haluamme hakea Matille sopivaa elokuvaa, tutkimme Matin samuutta kaikkien muiden arvioijien kesken. Matti ja Pekka ovat katsoneet kaksi yhteistä elokuvaa. Matti antoi Tuulen viemälle arvosanan huono (-5), Pekka arvosanan OK (3). Elokuvalle Eraserhead Matti antoi arvosanan OK (3), Pekka arvosanan huono (-5). Matin ja Pekan samuus on siis -30.
  </p>

  <% partial 'partials/sample_output' do %>
    -5 * 3 + 3 * -5 = -30
  <% end %>

  <p>
    Matin ja Mikaelin samuus on edellisestä laskusta tiedetty -15. Samuudet ovat symmetrisia.
  </p>

  <p>
    Matti ja Thomas ovat katsoneet Tuulen viemää, ja kumpikin antoi sille arvosanan hyvä (5). Matin ja Thomaksen samuus on siis 25.
  </p>

  <% partial 'partials/sample_output' do %>
    5 * 5 = 25
  <% end %>

  <p>
    Matille tulee siis suositella elokuvia Thomaksen elokuvamaun mukaan: suosituksena olisi Blues Brothers.
  </p>

  <p>
    Toteuta yllä kuvattu suosittelumekanismi. Jos henkilölle ei löydy yhtään suositeltavaa elokuvaa, tai henkilö, kenen elokuvamaun mukaan elokuvia suositellaan on arvioinut elokuvat joita henkilö ei ole vielä katsonut huonoiksi, välttäviksi tai neutraaleiksi, palauta metodista <code>suositteleElokuva</code> arvo <code>null</code>. Edellisessä tehtävässä määritellyn lähestymistavan tulee toimia jos henkilö ei ole lisännyt yhtäkään arviota.
  </p>

  <p>
    Älä suosittele elokuvia, jotka henkilö on jo nähnyt.
  </p>

  <p>
    Voit testata ohjelmasi toimintaa seuraavalla lähdekoodilla:
  </p>

  <% partial 'partials/code_highlight' do %>
    ArvioRekisteri arviot = new ArvioRekisteri();

    Elokuva tuulenViemaa = new Elokuva("Tuulen viemää");
    Elokuva hiljaisetSillat = new Elokuva("Hiljaiset sillat");
    Elokuva eraserhead = new Elokuva("Eraserhead");
    Elokuva bluesBrothers = new Elokuva("Blues Brothers");

    Henkilo matti = new Henkilo("Matti");
    Henkilo pekka = new Henkilo("Pekka");
    Henkilo mikke = new Henkilo("Mikael");
    Henkilo thomas = new Henkilo("Thomas");
    Henkilo arto = new Henkilo("Arto");

    arviot.lisaaArvio(matti, tuulenViemaa, Arvio.HUONO);
    arviot.lisaaArvio(matti, hiljaisetSillat, Arvio.HYVA);
    arviot.lisaaArvio(matti, eraserhead, Arvio.OK);

    arviot.lisaaArvio(pekka, tuulenViemaa, Arvio.OK);
    arviot.lisaaArvio(pekka, eraserhead, Arvio.HUONO);
    arviot.lisaaArvio(pekka, bluesBrothers, Arvio.VALTTAVA);

    arviot.lisaaArvio(mikke, eraserhead, Arvio.HUONO);

    arviot.lisaaArvio(thomas, bluesBrothers, Arvio.HYVA);
    arviot.lisaaArvio(thomas, hiljaisetSillat, Arvio.HYVA);

    Suosittelija suosittelija = new Suosittelija(arviot);
    System.out.println(thomas + " suositus: " + suosittelija.suositteleElokuva(thomas));
    System.out.println(mikke + " suositus: " + suosittelija.suositteleElokuva(mikke));
    System.out.println(matti + " suositus: " + suosittelija.suositteleElokuva(matti));
    System.out.println(arto + " suositus: " + suosittelija.suositteleElokuva(arto));
  <% end %>

  <% partial 'partials/sample_output' do %>
    Thomas suositus: Eraserhead
    Mikael suositus: Tuulen viemää
    Matti suositus: Blues Brothers
    Arto suositus: Hiljaiset sillat
  <% end %>

  <p>
    Miljoona käsissä? Ei ehkä vielä. Tietojenkäsittelytieteen tekoäly- ja koneoppimiskursseilla opitaan lisää tekniikoita oppivien järjestelmien rakentamiseen.
  </p>

<% end %>


















<% partial 'partials/material_heading' do %>
  Lisää rajapinnoista
<% end %>

<p>
  Rajapinta määrittelee yhden tai useamman metodin, jotka rajapinnan toteuttavan luokan on pakko toteuttaa. Rajapintoja, kuten kaikkia luokkia voi asettaa pakkauksiin. Esimerkiksi seuraava <code>Tunnistettava</code>-rajapinta sijaitsee pakkauksessa <code>sovellus.domain</code>. Rajapinta määrää, että <code>Tunnistettava</code>-rajapinnan toteuttavien luokkien tulee toteuttaa metodi <code>public String getTunnus()</code>.</p>

<% partial 'partials/code_highlight' do %>
  package sovellus.domain;

  public interface Tunnistettava {
  String getTunnus();
  }
<% end %>

<p>
  Luokka toteuttaa rajapinnan <code>implements</code>-avainsanalla. Alla on esimerkkinä luokka <code>Henkilo</code>, joka toteuttaa rajapinnan tunnistettava. Rajapinnan Tunnistettava vaatima metodi <code>getTunnus</code> palauttaa aina henkilön henkilötunnuksen.
</p>

<% partial 'partials/code_highlight' do %>
  package sovellus.domain;

  public class Henkilo implements Tunnistettava {
  private String nimi;
  private String henkilotunnus;

  public Henkilo(String nimi, String henkilotunnus) {
  this.nimi = nimi;
  this.henkilotunnus = henkilotunnus;
  }

  public String getNimi() {
  return this.nimi;
  }

  public String getHenkilotunnus() {
  return this.henkilotunnus;
  }

  @Override
  public String getTunnus() {
  return getHenkilotunnus();
  }

  @Override
  public String toString() {
  return this.nimi + " hetu: " + this.henkilotunnus;
  }
  }
<% end %>


<p>
  Rajapintojen vahvuus on se, että rajapintaa voidaan käyttää muuttujan tyyppinä. Tämä mahdollistaa yleiskäyttöisempien luokkien tekemisen.
</p>

<p>
  Tehdään luokka <code>Rekisteri</code>, jota käytetään Tunnistettava-tyyppisten olioiden säilömiseen. Rekisteriin voidaan lisätä sekä henkilöitä että mitä tahansa muita olioita, jotka toteuttavat rajapinnan Tunnistettava. Yksittäisten henkilöiden hakemisen lisäksi <code>Rekisteri</code> tarjoaa metodin kaikkien henkilöiden hakemiseen listana.
</p>

<% partial 'partials/code_highlight' do %>
  public class Rekisteri {
  private Map&lt;String, Tunnistettava&gt; rekisteroidyt;

  public Rekisteri() {
  this.rekisteroidyt = new HashMap&lt;&gt;();
  }

  public void lisaa(Tunnistettava lisattava) {
  this.rekisteroidyt.put(lisattava.getTunnus(), lisattava);
  }

  public Tunnistettava hae(String tunnus) {
  return this.rekisteroidyt.get(tunnus);
  }

  public List&lt;Tunnistettava&gt; haeKaikki() {
  return new ArrayList&lt;Tunnistettava&gt;(rekisteroidyt.values());
  }
  }<% end %>

<p>
  Rekisterin käyttö onnistuu seuraavasti.
</p>

<% partial 'partials/code_highlight' do %>
  Rekisteri henkilokunta = new Rekisteri();
  henkilokunta.lisaa(new Henkilo("Pekka", "221078-123X"));
  henkilokunta.lisaa(new Henkilo("Jukka", "110956-326B"));

  System.out.println(henkilokunta.hae("280283-111A"));

  Henkilo loydetty = (Henkilo) henkilokunta.hae("110956-326B");
  System.out.println(loydetty.getNimi());
<% end %>

<p>
  Koska henkilöt on lisätty rekisteriin <code>Tunnistettava</code>-tyyppisinä, ne löytyvät sieltä myös Tunnistettava-tyyppisinä. Jos haluamme käsitellä henkilöitä sellaisten metodien kautta, joita rajapinnassa ei ole määritelty, joudumme muuntamaan ne takaisin Henkilo-olioiksi. Tämä tapahtuu eksplisiittisella tyyppimuunnoksella, jota demonstroidaan edellisen esimerkin kahdella viimeisellä rivillä.
</p>

<p>
  Entä jos haluaisimme rekisteriin lisäksi metodin, joka palauttaa rekisteriin talletetut henkilöt tunnisteen mukaan järjestettynä? Yksi vaihtoehto olisi käyttää aiemmin tutuksi tullutta virran järjestämistä. Tutustutaan kuitenkin myös Javan valmiiseen järjestämisessä käytettävään rajapintaan.
</p>



<% partial 'partials/material_sub_heading' do %>
  Useamman rajapinnan toteuttaminen
<% end %>

<p>
  Kokeillaan lisätä aiemmin luomallemme Rekisteri-luokalle metodi haeKaikkiJarjestyksessa.
</p>

<% partial 'partials/code_highlight' do %>
  public List&lt;Tunnistettava&gt; haeKaikkiJarjestyksessa() {
  // ei toimi!
  return rekisteroidyt.values()
  .stream().sorted().collect(Collectors.toCollection(ArrayList::new));
  }
<% end %>

<p>
  Metodi ei kuitenkaan toimi. Koska henkilöt on talletettu rekisteriin <code>Tunnistettava</code>-tyyppisinä, on Henkilön toteutettava rajapinta <code>Comparable&lt;Tunnistettava&gt;</code>, jotta rekisteri osaisi järjestää henkilöt tunnistettavina. Joudumme joko muuttamaan henkilön toteuttamaa rajapintaa, tai lisäämään <code>sorted</code>-metodille järjestämiseen käytettävät tiedot. Muutetaan tässä henkilön toteuttamaa rajapintaa:
</p>

<% partial 'partials/code_highlight' do %>
  public class Henkilo implements Tunnistettava, Comparable&lt;Tunnistettava&gt; {
  // ...

  @Override
  public int compareTo(Tunnistettava toinen) {
  return this.getTunnus().compareTo(toinen.getTunnus());
  }
  }<% end %>

<p>
  Nyt ratkaisu toimii!
</p>

<p>
  Rekisteri on täysin tietämätön sinne lisättyjen olioiden todellisesta tyypistä. Voimme käyttää luokkaa rekisteri myös muuntyyppisten olioiden kuin henkilöiden rekisteröintiin, kunhan olioiden luokka vaan toteuttaa rajapinnan <code>Tunnistettava</code>. Esim. seuraavassa käytetään rekisteriä kaupassa myytävien tuotteiden hallintaan:
</p>

<% partial 'partials/code_highlight' do %>
  public class Tuote implements Tunnistettava {

  private String nimi;
  private String viivakoodi;
  private int varastosaldo;
  private int hinta;

  public Tuote(String nimi, String viivakoodi) {
  this.nimi = nimi;
  this.viivakoodi = viivakoodi;
  }

  public String getTunnus() {
  return viivakoodi;
  }

  // ...
  }
<% end %>


<% partial 'partials/code_highlight' do %>
  Rekisteri tuotteet = new Rekisteri();
  tuotteet.lisaa(new Tuote("maito", "11111111"));
  tuotteet.lisaa(new Tuote("piimä", "11111112"));
  tuotteet.lisaa(new Tuote("juusto", "11111113"));

  System.out.println(tuotteet.hae("99999999"));

  Tuote tuote = (Tuote) tuotteet.hae("11111112");
  tuote.kasvataSaldoa(100);
  tuote.muutaHinta(23);
<% end %>

<p>
  Teimme luokasta <code>Rekisteri</code> melko yleiskäyttöisen pitämällä sen riippumattomana konkreettisista luokista. Mikä tähänsa luokka, joka toteuttaa rajapinnan <code>Tunnistettava</code>, on rekisterin kanssa käyttökelpoinen. Metodin <code>haeKaikkiJarjestyksessä</code> toimiminen tosin edellyttää luokalta myös vertailtavuuden eli Comparable&lt;Tunnistettava&gt;-rajapinnan toteuttamisen.
</p>


<% partial 'partials/hint', locals: { name: 'Muutama NetBeans-vihje' } do %>

  <ul>
    <li> <strong>Implement all abstract methods</strong>

      <p>
	Voit pyytää NetBeansia täydentämään metodirungot automaattisesti rajapinnan toteuttavalle luokalle. Kun olet määritellyt luokan toteuttavan rajapinnan, eli kirjoittanut
      </p>

      <% partial 'partials/code_highlight' do %>
	public class Luokka implements Rajapinta {
	}
      <% end %>

      <p>
	NetBeans värjää luokan nimen punaisella. Mene rivin vasemmassa reunassa olevan lamppusymbolin kohdalle, klikkaa ja valitse <em>Implement all abstract methods</em> ja metodirungot ilmestyvät koodiin!
      </p>

    </li>

    <li> <strong>Clean and Build</strong>

      <p>
	Tietyissä tilanteissa NetBeans saattaa mennä sekaisin ja yrittää ajaa koodista versiota johon ei ole huomioitu kaikkia koodiin kirjoitettuja muutoksia. Yleensä huomaat tilanteen siten, että jotain "outoa" vaikuttaa tapahtuvan. Ongelman korjaa usein <em>Clean and build</em> -operaation suorittaminen. Operaatio löytyy Run-valikosta ja sen voi suorittaa myös painamalla <em>harja ja vasara</em> -symbolia. Clean and build poistaa koodista olemassa olevat käännetyt versiot ja tekee uuden käännöksen.
      </p>

    </li>

  </ul>

<% end %>


<% partial 'partials/material_sub_heading' do %>
  Oletusmetodit rajapinnoissa
<% end %>

<p>
  Rajapintoihin voi määritellä oletusmetodeja, joiden mukana annetaan myös toteutus. Oletusmetodien määrittely alkaa avainsanalla <code>default</code>, jota seuraa metodin määrittely. Kuten rajapintojen metodeissa yleensä, myös tässäkään näkyvyyttä ei tarvitse määritellä erikseen. Rajapinnoissa määriteltyjen metodien näkyvyys on aina <code>public</code>.
</p>

<p>
  Alla olevassa esimerkissä rajapintaan <code>Luettava</code> on lisätty oletusmetodi <code>lueTulostaen</code>, joka tulostaa <code>lue</code>-metodin palauttaman arvon.
</p>

<% partial 'partials/code_highlight' do %>
  public interface Luettava {
  String lue();

  default void lueTulostaen() {
  System.out.println(lue());
  }
  }
<% end %>

<p>
  Yksi oletusmetodien suurimmista hyödyistä ilmenee tilanteissa, missä rajapinta on määritelty aiemmin, ja useampi luokka toteuttaa sen jo valmiiksi. Jos rajapintaan lisätään uusi metodi, tulee sille ohjelmoida toteutus kaikkiin rajapinnan toteuttamiin luokkiin, jos uusi metodi ei tarjoa oletustoteutusta.
</p>

<p>
  Toisaalta, jos oletustoteutus lisätään uuden metodin lisäämisen yhteydessä, ei aiemmin rajapinnan toteuttaneille luokille tarvitse tehdä minkäänlaisia muutoksia. Edellisestä osasta tutut luokat Tekstiviesti ja Sahkoposti toimisivat nyt myös seuraavasti.
</p>

<% partial 'partials/code_highlight' do %>
  Tekstiviesti viesti = new Tekstiviesti("G. Hopper", "COBOL kicks ass");
  viesti.lueTulostaen();

  Sahkoposti posti = new Sahkoposti("D. Knuth", "If you optimize everything, you will always be unhappy.");
  posti.lueTulostaen();
<% end %>

<% partial 'partials/sample_output' do %>
  COBOL kicks ass
  If you optimize everything, you will always be unhappy.
<% end %>





<% partial 'partials/material_sub_heading' do %>
  Lukeminen verkkoyhteyden yli
<% end %>

<p>
  Lähes kaikki verkkosivut, kuten tämäkin oppimateriaali, voidaan lukea tekstimuodossa ohjelmallista käsittelyä varten. Scanner-oliolle voi antaa konstruktorin parametrina lähes minkälaisen syötevirran tahansa. Alla olevassa esimerkissä luodaan URL-olio annetusta web-osoitteesta, pyydetään siihen liittyvää tietovirtaa, ja annetaan se uudelle Scanner-oliolle luettavaksi.
</p>


<% partial 'partials/code_highlight' do %>
ArrayList&lt;String&gt; rivit = new ArrayList&lt;&gt;();

// luodaan lukija web-osoitteen lukemista varten
try (Scanner lukija = new Scanner(new URL("http://www.cs.helsinki.fi/home/").openStream())) {

    // luetaan osoitteesta http://www.cs.helsinki.fi/home/
    // saatava vastaus
    while (lukija.hasNextLine()) {
        rivit.add(lukija.nextLine());
    }
} catch (Exception e) {
    System.out.println("Virhe: " + e.getMessage());
}

// tehdään jotain vastauksella
<% end %>

<p>
  Web-selain on oikeastaan ohjelma siinä missä muutkin ohjelmat. Toisin kuin yllä toteutettu sivun sisällön lataaja, web-selaimeen on toteutettu toiminnallisuus vastauksena tulevan HTML-muotoisen lähdekoodin tulkisemiseen ja graafisessa käyttöliittymässä näyttämiseen.
</p>


<% partial 'partials/exercise', locals: { name: 'Chuck Norris -vitsit' } do %>

  <p>
    Osoitteessa <a href="http://www.icndb.com/api/" target="_blank" rel="noopener">http://www.icndb.com/api/</a> sijaitsee web-sovellus, joka tarjoaa Chuck Norris -vitsejä kaikkien vapaaseen käyttöön.
  </p>

  <p>
    Sovellus tarjoaa muunmuassa mahdollisuuden satunnaisten vitsien hakemiseen (osoite <code>http://api.icndb.com/jokes/random</code>) sekä vitsien hakemiseen niihin liittyvillä numeerisilla tunnuksilla (osoite <code>http://api.icndb.com/jokes/<em>tunnus</em></code>, missä <em>tunnus</em> on kokonaisluku).
  </p>

  <p>
    Toteuta sovellus, joka tarjoaa kolme toimintoa. Jos käyttäjä kirjoittaa "lopeta", ohjelman suoritus lopetetaan. Jos käyttäjä kirjoittaa "satunnainen", ohjelma tulostaa icndb-palvelusta noudetun satunnaisen chuck norris vitsin. Jos käyttäjä kirjoittaa "vitsi <em>numero</em>", missä numero on kokonaisluku, ohjelma tulostaa icndb-palvelusta noudetun tietyn vitsin.
  </p>

  <p>
    Huom! Tässä tehtävässä riittää tulostaa palvelun palauttama merkkijono kokonaisuudessaan. Merkkijono voi olla esimerkiksi muotoa <code>{ "type": "success", "value": { "id": 341, "joke": "Chuck Norris sleeps with a pillow under his gun.", "categories": [] } }</code>.
  </p>

  <p>
    Ohjelmassa ei ole testejä, eli testit eivät ota kantaa sovelluksen rakenteeseen tai tulostuksen ulkoasuun. Palauta sovellus kun se toimii koneellasi toivotulla tavalla.
  </p>

<% end %>



<% partial 'partials/material_heading' do %>
  Merkkijonojen käsittely
<% end %>

- charat
- indexOf
- substring

- split -> taulukko


--- 



<% partial 'partials/material_sub_heading' do %>
  Merkkijonon... metodit?
<% end %>

<p>
  Merkkijonot poikkeavat luonteeltaan hieman esimerkiksi kokonaisluvuista. Kokonaisluvut ovat "pelkkiä arvoja" -- niiden avulla voi tehdä laskutoimituksia ja niiden arvon voi tulostaa:
</p>

<% partial 'partials/code_highlight' do %>
int x = 1;
int y = 3;

y = 3 * x + 2;

System.out.println("y:n arvo nyt: " + y);
<% end %>

<% partial 'partials/sample_output' do %>
y:n arvo nyt: 5
<% end %>

<p>
  Merkkijonot taas ovat hieman "älykkäämpiä" ja tietävät esimerkiksi pituutensa:
</p>

<% partial 'partials/code_highlight' do %>
String sana1 = "Ohjelmointi";
String sana2 = "Java";

System.out.println("merkkijonon " + sana1 + " pituus: " + sana1.length());
System.out.println("merkkijonon " + sana2 + " pituus: " + sana2.length());
<% end %>

<p>
  Tulostuu:
</p>

<% partial 'partials/sample_output' do %>
merkkijonon Ohjelmointi pituus on 11
merkkijonon Java pituus on 4
<% end %>

<p>
  Pituus saadaan selville kutsumalla merkkijonon metodia <code>length()</code>. Merkkijonoilla on joukko muitakin metodeja. Kokonaisluvuilla eli <code>int</code>:eillä ei ole metodeja ollenkaan, ne eivät itsessään "osaa" mitään. Mistä tässä oikein on kyse?
</p>


<% partial 'partials/material_sub_heading' do %>
  Olioihin liittyy sekä metodeja että arvoja
<% end %>

<p>
  Merkkijonot ovat olioita, joihin liittyy sekä merkkijonon teksti että metodeja, joilla tekstiä voi käsitellä. Termi <strong>olio</strong> tarkoittaa tietynlaista muuttujaa. Jatkossa tulemme näkemään hyvin paljon muitakin olioita kuin merkkijonoja.
</p>

<p>
  Olion metodia kutsutaan lisäämällä muuttujan nimen perään piste ja metodin nimi. Näiden lisäksi tulee sulut sekä mahdolliset parametrit:
</p>

<% partial 'partials/code_highlight' do %>
  String sana1 = "Ohjelmointi";
  String sana2 = "Java";

  sana1.length();    // kutsutaan merkkijono-olion sana1 metodia length()
  sana2.length();    // kutsutaan merkkijono-olion sana2 metodia length()
<% end %>

<p>
  Metodikutsu kohdistuu nimenomaan siihen olioon, mille metodia kutsutaan. Yllä kutsumme ensin <code>sana1</code>-nimisen merkkijonon <code>length()</code>-metodia, sitten merkkijonon <code>sana2</code> metodia <code>length()</code>.</p>

<p>
  Vanha tuttumme <code>lukija</code> on myös olio:
</p>

<% partial 'partials/code_highlight' do %>
Scanner lukija = new Scanner(System.in);
<% end %>

<p>
  Lukijat ja merkkijonot ovat molemmat oliota, mutta ne ovat kuitenkin varsin erilaisia. Lukijoilla on mm. metodi <code>nextLine()</code> jota merkkijonoilla ei ole. Javassa oliot "synnytetään" eli luodaan melkein aina komennolla <code>new</code>, merkkijonot muodostavat tässä suhteessa poikkeuksen! -- Merkkijonoja voi luoda kahdella tavalla:
</p>

<% partial 'partials/code_highlight' do %>
String banaani = new String("Banaani");
String porkkana = "porkkana";
<% end %>

<p>
  Kumpikin ylläolevista riveistä luo uuden merkkijono-olion. Merkkijonojen luonnissa <code>new</code>-komentoa käytetään kuitenkin hyvin harvoin, sillä Java-ohjelmointikielen toteuttajat ovat tehneet merkkijonojen luomiseen lyhyemmän (ei new-komentoa tarvitsevan) tavan.
</p>

<p>
  Olion "tyypistä" puhuttaessa puhutaan usein <em>luokista</em>. Merkkijonojen luokka on <code>String</code>, lukijoiden luokka taas on <code>Scanner</code>. Opimme jatkossa luokista ja olioista paljon lisää.
</p>



<% partial 'partials/material_sub_heading' do %>
  Monimutkaisemman tiedon lukeminen
<% end %>

<p>
  Edellisessä esimerkissä sekä sitä seuranneissa tehtävissä tiedoston sisältö käsiteltiin riveittäin lukuina tai merkkijonoina. Mikäli tiedosto noudattaa jonkinlaista ennalta määrättyä rakennetta ja sen sisältämä tieto liittyy konkreettiseen käsitteeseen, voidaan luetut rivit muuttaa myös olioiksi.
</p>

<p>
  Oletetaan, että käytössämme on seuraavaa muotoa noudattava reseptejä sisältävä tiedosto. Tiedosto sisältää aina ensin reseptin nimen, jota seuraa reseptiin liittyvät raaka-aineet. Raaka-aineita seuraa tyhjä rivi, jonka jälkeen alkaa uusi resepti. Tiedoston muoto on siis seuraava
</p>

<% partial 'partials/sample_output' do %>
  Reseptin 1 nimi
  reseptin 1 raaka-aine 1
  reseptin 1 raaka-aine 2

  Reseptin 2 nimi
  reseptin 2 raaka-aine 1
  reseptin 2 raaka-aine 2
  reseptin 2 raaka-aine 3
  reseptin 2 raaka-aine 4

  Reseptin 3 nimi
  reseptin 3 raaka-aine 1
  reseptin 3 raaka-aine 2
  reseptin 3 raaka-aine 3
  reseptin 3 raaka-aine 4
<% end %>

<p>
  Käsitettä <code>Resepti</code> voidaan luoda kuvaamaan seuraavanlainen luokka, joka sisältää sekä nimen että listan raaka-aineita.
</p>

<% partial 'partials/code_highlight' do %>
  import java.util.ArrayList;

  public class Resepti {
      private String nimi;
      private ArrayList&lt;String&gt; raakaAineet;

      public Resepti(String nimi) {
          this.nimi = nimi;
          this.raakaAineet = new ArrayList&lt;&gt;();
      }

      public void lisaaRaakaAine(String raakaAine) {
          this.raakaAineet.add(raakaAine);
      }

      public String toString() {
          String palautettava = this.nimi;
          for (String raakaAine: this.raakaAineet) {
              palautettava += "\n  " + raakaAine;
          }
          return palautettava;
      }
  }
<% end %>

<% partial 'partials/code_highlight' do %>
  Resepti resepti = new Resepti("Lettutaikina");
  resepti.lisaaRaakaAine("0.5 litraa maitoa");
  resepti.lisaaRaakaAine("2 munaa");
  resepti.lisaaRaakaAine("sopivasti jauhoa");
  resepti.lisaaRaakaAine("0.5 tl suolaa");
  resepti.lisaaRaakaAine("2 rkl sokeria");
  resepti.lisaaRaakaAine("voita paistamiseen");

  System.out.println(resepti);
<% end %>

<% partial 'partials/sample_output' do %>
  Lettutaikina
    0.5 litraa maitoa
    2 munaa
    sopivasti jauhoa
    0.5 tl suolaa
    2 rkl sokeria
    voita paistamiseen
<% end %>

<p>
  Nyt tiedoston lukeminen onnistuu seuraavasti.
</p>


<% partial 'partials/code_highlight' do %>
  ArrayList&lt;Resepti&gt; reseptit = new ArrayList&lt;&gt;();
  Scanner lukija = new Scanner(System.in);
  System.out.println("Mistä tiedostosta luetaan?");
  String tiedosto = lukija.nextLine();

  try (Scanner tiedostonLukija = new Scanner(new File(tiedosto))) {

      // luetaan reseptit ja raaka-aineet
      while (tiedostonLukija.hasNextLine()) {
          // luetaan resepti ja luodaan sitä vastaava olio
          String reseptinNimi = tiedostonLukija.nextLine();
          Resepti resepti = new Resepti(reseptinNimi);

          // lisätään resepti listalle
          reseptit.add(resepti);

          // lisätään reseptiin raaka-aineet
          while (tiedostonLukija.hasNextLine()) {
              String raakaAine = tiedostonLukija.nextLine();

              // reseptin raaka-aineet lopetetaan tyhjällä rivillä
              if(raakaAine.isEmpty()) {
                  // poistutaan tästä while-toistolauseesta
                  // (ulompi jatkaa)
                  break;
              }

              resepti.lisaaRaakaAine(raakaAine);
          }

      }
  } catch (Exception e) {
      System.out.println("Virhe: " + e.getMessage());
  }

  // tee jotain luetuilla resepteillä
<% end %>


<%= partial 'partials/quiz', locals: { id: '5a874484c1b9900004293f60' } %>

<%= partial 'partials/quiz', locals: { id: '5a87457fc1b9900004293f62' } %>

<%= partial 'partials/quiz', locals: { id: '5a8745e7c1b9900004293f63' } %>






https://medium.com/@_marcos_otero/the-real-10-algorithms-that-dominate-our-world-e95fa9f16c04


<% partial 'partials/exercise', locals: { name: 'Round-robin' } do %>

  <p>
    Tietokoneella voi olla samaan aikaan käynnissä useita ohjelmia, mutta todellisuudessa kaikkien käynnissä olevien ohjelmien lähdekoodia ei suoriteta samaan aikaan. Tietokoneen käyttöjärjestelmä vaihtaa suoritettavaa ohjelmaa jatkuvasti, minkä kautta käyttäjälle tulee illuusio siitä, että ohjelmat olisivat samaan aikaan käynnissä.
  </p>

  <p>
    <a href="https://en.wikipedia.org/wiki/Round-robin_scheduling" target="_blank" rel="noopener">Round-robin -algoritmia</a> käytetään tietokoneen ohjelmien aikatauluttamiseen.
  </p>

  <p>
    Algoritmin toimintaperiaate on yksinkertainen. Ohjelmista luodaan jono, ja ensimmäisenä jonossa olevaa ohjelmaa suoritetaan hetki, jonka jälkeen suoritettavana ollut ohjelma siirretään jonon perälle. Tämän jälkeen seuraava jonossa ollut ohjelma -- nyt jonon ensimmäinen -- päätyy suoritettavaksi, jonka jälkeen se siirretään jonon perälle jne.
  </p>

  <p>
    Tehtäväpohjassa on viisi lukua sisältävä taulukko sekä ohjelmarunko niiden käsittelyyn. Ohjelmarunko tuntee tällä hetkellä kaksi komentoa: "lopeta" lopettaa ohjelman suorituksen ja "tulosta" tulostaa taulukon arvot.
  </p>

  <p>
    Lisää ohjelmaan komento "siirra", joka siirtää ensimmäisenä taulukossa olevan arvon taulukon perälle sekä kaikkia muita taulukon arvoja yhden paikan eteenpäin.
  </p>

  <% partial 'partials/sample_output' do %>
    <font color="red">tulosta</font>
    1 3 5 7 9
    <font color="red">siirra</font>
    <font color="red">tulosta</font>
    3 5 7 9 1
    <font color="red">siirra</font>
    <font color="red">siirra</font>
    <font color="red">tulosta</font>
    7 9 1 3 5
    <font color="red">lopeta</font>
  <% end %>

<% end %>




<% partial 'partials/material_heading' do %>
  Alkeis- ja viittaustyyppiset muuttujat tietokoneen näkökulmasta
<% end %>

<p>
   Sanoessamme "muuttujaan asetetaan arvo.." tai "muuttujan arvoksi kopioidaan.." käytämme ohjelmoijien käyttämää kieltä. 
   
   Ohjelmoijien kieli on kuitenkin abstraktio tietokoneen sisäisestä toiminnasta. Tarkastellaan tässä lyhyesti mitä 
</p>

<p>
Ohjelmointikieli on abstraktio mikä mahdollistaa ohjelmointiin liittyvistä asioista puhumisen abstraktioiden avulla.
</p>

<p>
  Aiheeseen syvennytään tarkemmin kurssilla tietokoneen toiminta.
</p>

<p>
  Tänne bittijutut sekä muisti jne. 
</p>

this vs super

extends vai implements


<% partial 'partials/hint', locals: { name: 'Bitit ja binääriluvut' } do %>

  <p>
    Tietokoneen muisti on käytännössä taulukko, missä jokainen taulukon lokero sisältää joko luvun 0 tai 1. Näitä yksittäisiä lukuja kutsutaan biteiksi (lyhenne sanasta binary digit). Koneen käyttämät luvut kuvataan bittien avulla binäärilukuina. Esimerkiksi <code>short</code>-tyyppinen muuttuja sisältää 16 bittiä ja <code>int</code>-tyyppinen muuttuja 32 bittiä. TODO: miten string-muodostuu
  </p>

  <p>
    Tarkastellaan miten binääriluvut toimivat. Alla on kuvattuna 8 bittiä pitkä alue tietokoneen muistista, missä jokainen bitin arvo on 0. 
  </p>

  <table border="1">
    <tr>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
  </table>

  <br/>
  
  <p>
    Binäärilukukujen avulla jokainen luku voidaan esittää luvun 2 potensseina. Esimerkiksi yllä olevan kahdeksan bitin luvun arvo kymmenjärjestelmässä on: 0 * 2<sup>0</sup> + 0 * 2<sup>1</sup> + ... + 0 * 2<sup>7</sup> = 0. Laskeminen aloitetaan tyypillisesti luvun oikeasta laidasta. Alla on kuvattuna toinen esimerkki.
  </p>
  
  <table border="1">
    <tr>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
    </tr>
  </table>

  <br/>
  
  <p>
    Yllä kuvattu binääriluku on kymmenjärjestelmässä: 1 * 2<sup>0</sup> + 0 * 2<sup>1</sup> + 1 * 2<sup>2</sup> + 0 * 2<sup>3</sup> + ... + 0 * 2<sup>7</sup> = 5. 
  </p>

  <p>
    Vastaavasti kymmenjärjestelmän luku 3 voidaan ilmaista binäärilukuna "11", ja esimerkiksi luku 256 binäärilukuna "100000000". Binäärilukujen avulla kuvataan lukujen lisäksi käytännössä kaikki tietokoneen tallentama tieto. Tähän teemaan tutustutaan tarkemmin kurssilla Tietokoneen toiminta (TKT-10005). 
  </p>

  <p>
    TODO: tieto muistissa -- muuttuja on osoite paikkaan; int-muuttujan arvon saa selville lukemalla 32 bittiä int-muuttujan arvon kuvaamasta paikasta lähtien.
  </p>

<% end %>


<p>
  TODO: jatkokurssille moniulotteiset taulukot
</p>


<% partial 'partials/material_sub_heading' do %>
  Kaksiulotteinen taulukko
<% end %>

<p>
  Aiemmat taulukkoesimerkkimme ovat käsitelleet yksiulotteisia taulukoita, missä indeksi kertoo sijainnin yhdessä ulottuvuudessa. Taulukon voi luoda myös useampiulotteisena, jolloin taulukossa olevaa tietoa voi tarkastella useamman indeksin avulla. Tämä on kätevää esimerkiksi silloin, jos tieto on useampiulotteista kuten esimerkiksi koordinaatistossa.
</p>

<p>
  Kaksiulotteinen taulukko, jossa on kaksi riviä ja kolme saraketta, luodaan seuraavasti:
</p>

<% partial 'partials/code_highlight' do %>
  int rivit = 2;
  int sarakkeet = 3;
  int[][] kaksiulotteinenTaulukko = new int[rivit][sarakkeet];
<% end %>

<p>
  Yllä luomme taulukon, jonka jokainen rivi viittaa taulukkoon, jossa on tietty määrä sarakkeita. Kaksiulotteisen taulukon läpikäynti onnistuu kahden sisäkkäisen while-toistolauseen avulla seuraavasti:
</p>

<% partial 'partials/code_highlight' do %>
  int rivit = 2;
  int sarakkeet = 3;
  int[][] kaksiulotteinenTaulukko = new int[rivit][sarakkeet];

  int y = 0;
  while (y &lt; kaksiulotteinenTaulukko.length) {

      int x = 0;
      while (x &lt; kaksiulotteinenTaulukko[y].length) {
          int arvo = kaksiulotteinenTaulukko[y][x];
          System.out.println("arvo kohdassa (" + x + ", " + y + "): " + arvo);
          x++;
      }

      y++;
  }
<% end %>

<p>
  Ylläolevan ohjelman tulostus on seuraava.
</p>

<% partial 'partials/sample_output' do %>
  arvo kohdassa (0, 0): 0
  arvo kohdassa (1, 0): 0
  arvo kohdassa (2, 0): 0
  arvo kohdassa (0, 1): 0
  arvo kohdassa (1, 1): 0
  arvo kohdassa (2, 1): 0
<% end %>

<p>
  Saatoit yllättyä. Selityksenä tulostukselle on se, että int-tyyppisten muuttujien oletusarvo on 0.
</p>

<p>
  Voimme muuttaa taulukon arvoja kuten ennenkin. Alla asetamme kahteen kohtaan uudet arvot.
</p>

<% partial 'partials/code_highlight' do %>
  int rivit = 2;
  int sarakkeet = 3;
  int[][] kaksiulotteinenTaulukko = new int[rivit][sarakkeet];

  kaksiulotteinenTaulukko[0][1] = 4;
  kaksiulotteinenTaulukko[1][1] = 1;
  kaksiulotteinenTaulukko[1][0] = 8;


  int y = 0;
  while (y &lt; kaksiulotteinenTaulukko.length) {

      int x = 0;
      while (x &lt; kaksiulotteinenTaulukko[y].length) {
          int arvo = kaksiulotteinenTaulukko[y][x];
          System.out.println("arvo kohdassa (" + x + ", " + y + "): " + arvo);
          x++;
      }

      y++;
  }
<% end %>

<p>
  Nyt tulostus näyttää seuraavalta:
</p>

<% partial 'partials/sample_output' do %>
  arvo kohdassa (0, 0): 0
  arvo kohdassa (1, 0): 4
  arvo kohdassa (2, 0): 0
  arvo kohdassa (0, 1): 8
  arvo kohdassa (1, 1): 1
  arvo kohdassa (2, 1): 0
<% end %>

<p>
  Kaksiulotteinen taulukko on oikeastaan <a href="https://fi.wikipedia.org/wiki/Matriisi" target="_blank" rel="noopener">matriisi</a>.  Matriiseja käytetään muunmuassa tietokonegrafiikassa, missä yksittäiset pikselit esitetään matriisin avulla.</p>


<% partial 'partials/exercise', locals: { name: 'Piirto-ohjelma' } do %>

  <p>
    Tehtäväpohjaan on toteutettu graafinen sovellus, mikä sisältää kaksiulotteisen taulukon. Tehtävänäsi on muuttaa sovelluksen toimintaa siten, että kun käyttäjä painaa hiirtä sovelluksessa tai liikuttaa hiirtä kun nappi on pohjassa, ikkunaan piirretään.
  </p>

  <p>
    Tee tätä varten kaksi asiaa: (1) muuta sovelluksessa olevan taulukon "piirrettava" arvoja sopivasti kun käyttäjä käyttää hiirtä, ja (2) piirrä komentoa <code>piirturi(x, y, 2, 2)</code> käyttäen ne alkiot, joiden arvo on 1. Käytä koordinaatteina x, y taulukon indeksejä.
  </p>

  <p>
    Kun sovellus toimii, voit käyttää sitä vaikkapa seuraavanlaisen taideteoksen tekemiseen. Tehtävässä ei ole testejä.
  </p>

  <img src="/img/exercises/06-14-piirturi-ok.png" />


<% end %>


<% partial 'partials/exercise', locals: { name: 'Game of Life (2 osaa)' } do %>

  <p>
    Toteutimme aiemmin Game of Life -pelin logiikan sisäkkäisiä hajautustauluja käyttäen. Tarkastellaan nyt samaa kaksiulotteisten taulukkojen avulla.
  </p>
  
  <p>
    <a href="https://en.wikipedia.org/wiki/Conway's_Game_of_Life" target="_blank">Game of Life</a> on neljää yksinkertaista sääntöä seuraava soluautomaatti:
  </p>

  <ol>
    <li>Jos elävän solun naapureina on alle kaksi elävää solua, se kuolee alikansoituksen takia.</li>
    <li>Jos elävän solun naapureina on kaksi tai kolme elävää solua, se jää henkiin.</li>
    <li>Jos elävän solun naapureina on yli kolme elävää solua, se kuolee ylikansoituksen takia.</li>
    <li>Jos kuolleen solun naapureina on tasan kolme elävää solua, se syntyy eli muuttuu eläväksi.</li>
  </ol>

  <p>
    Peli ei sisällä minkäänlaisia liikkumissääntöjä, mutta se silti luo tilanteita, missä erilaiset hahmot liikkuvat ruudulla. Katso pelin keksineen <a href="https://youtu.be/E8kUJL04ELA" target="_blank">John Conwayn mietteitä pelistä sekä sääntöjen selitys</a>.
  </p>

  <p>
    Tässä tehtävässä toteutetaan oleellisilta osin Game of Life-pelin säännöt. Toteutusta varten tehtäväpohjassa on luokka GameOfLife, joka sisältää kaksiulotteisen taulukon, sekä luokka GameOfLifeSovellus, jota voidaan käyttää pelin visualisointiin.
  </p>

  <h2>Elossa olevien naapurien lukumäärä</h2>

  <p>
    Täydennä luokassa GameOfLife olevaa metodia <code>public int elossaOleviaNaapureita(int[][] taulukko, int x, int y)</code> siten, että se laskee annetun x, y -koordinaatin elossa olevien naapureiden lukumäärän. Naapuri on elossa jos sen arvo on 1.
  </p>

  <p>
    Naapureita ovat kaikki ne alkiot, jotka ovat kulman tai sivun kautta yhteydessä alkioon.
  </p>

  <p>
    Huomaa, että metodin tulee varoa ArrayIndexOutOfBounds-virhettä. Indeksissä -1 ei esimerkiksi voi olla ketään. Vastaavasti taulukon leveyden tai korkeuden yli ei voi mennä (esim. <code>taulukko[taulukko.length][0]</code> tai <code>taulukko[0][taulukko[0].length]</code>).
  </p>

  <p>
    Voit kokeilla metodiasi muunmuassa seuraavilla esimerkeillä.
  </p>

  <% partial 'partials/code_highlight' do %>
    GameOfLife gol = new GameOfLife(3, 3);

    int[][] taulukko = new int[3][3];
    taulukko[0][0] = 1;
    taulukko[0][1] = 1;
    taulukko[1][1] = 1;
    taulukko[2][2] = 1;

    System.out.println(gol.elossaOleviaNaapureita(taulukko, 0, 0));
    System.out.println(gol.elossaOleviaNaapureita(taulukko, 1, 0));
    System.out.println(gol.elossaOleviaNaapureita(taulukko, 1, 1));
    System.out.println(gol.elossaOleviaNaapureita(taulukko, 2, 2));
  <% end %>

  <% partial 'partials/sample_output' do %>
    2
    3
    3
    1
  <% end %>

  <% partial 'partials/code_highlight' do %>
    GameOfLife gol = new GameOfLife(4, 4);

    int[][] taulukko = {{1, 1, 1, 1}, {1, 1, 1, 1}, {1, 0, 1, 0}, {0, 1, 0, 1}};

    System.out.println(gol.elossaOleviaNaapureita(taulukko, 0, 0));
    System.out.println(gol.elossaOleviaNaapureita(taulukko, 1, 1));
    System.out.println(gol.elossaOleviaNaapureita(taulukko, 2, 2));
    System.out.println(gol.elossaOleviaNaapureita(taulukko, 3, 3));
  <% end %>

  <% partial 'partials/sample_output' do %>
    3
    7
    5
    1
  <% end %>


  <h2>Kehittyminen</h2>


  <p>
    Täydennä seuraavaksi GameOfLife-luokan metodia <code>public void kehity()</code> siten, että se käy yhden Game of Life -pelin askeleen.
  </p>

  <p>
    Toteuta toiminnallisuus niin, että luot toisen taulukon, jonka koko on sama kuin alkuperäisen taulukon. Käy tämän jälkeen alkuperäistä taulukkoa läpi alkio alkiolta siten, että seuraat seuraavia sääntöjä:
  </p>

  <ol>
    <li>Jos alkuperäisen taulukon alkion arvo on 1 ja sillä on alle kaksi elävää naapuria, kopioon asetetaan alkion arvoksi 0.</li>
    <li>Jos alkuperäisen taulukon alkion arvo on 1 ja sillä on kaksi tai kolme elävää naapuria, kopioon asetetaan alkion arvoksi 1.</li>
    <li>Jos alkuperäisen taulukon alkion arvo on 1 ja sillä on yli kolme elävää naapuria, kopioon asetetaan alkion arvoksi 0.</li>
    <li>Jos alkuperäisen taulukon alkion arvo on 0 ja sillä on tasan kolme elävää naapuria, kopioon asetetaan alkion arvoksi 1.</li>
  </ol>

  <p>
    Käytä naapureiden lukumäärän selvittämisessä edellisessä osassa tehtyä metodia. Kun olet käynyt koko taulukon läpi, vaihda kopio taulukon paikalle.
  </p>


  <p>
    Kokeile tämän jälkeen sovelluksen toimintaa graafisen käyttöliittymän kautta. Sovelluksen pitäisi käynnistyä -- yksi mahdollinen hetkellinen tila on seuraavanlainen.
  </p>

  <img src="/img/exercises/06-15-gameoflife.png" width="600"/>
  
<% end %>


<% partial 'partials/material_heading' do %>
  Olio-ohjelmoinnin periaatteet
<% end %>

<p>
  Olio-ohjelmointiin kuuluu oleellisesti kolme periaatetta: abstrahointi, kapselointi ja perintä. Käsittelemme periaatteet tässä lyhyesti; perintään tutustutaan tarkemmin ohjelmoinnin jatkokurssille.
</p>


<% partial 'partials/material_sub_sub_heading' do %>
  Abstrahointi
<% end %>

<p>
  Abstrahoinnin tavoitteena on ongelma-alueen käsitteellistäminen. Ohjelmoija pyrkii nimeämään ongelma-alueen käsitteitä kuvaavat luokat, oliot, metodit ja muuttujat mahdollisimman hyvin, jolloin muut näitä käyttävät ohjelmoijat ymmärtävät mistä kussakin on kyse. 
</p>

<p>
  Käytännössä kyse on siis prosessista, missä ongelma-alueesta tunnistetaan ja eristetään oleellisimmat piirteet, joiden perusteella niistä luodaan ohjelmaan toiminnallisuutta. Samalla pyritään tilanteeseen, missä ongelma-alueesta on poimittu vain ne käsitteet, jotka ovat oleellisia käsiteltävän ongelman ratkaisun kannalta.
</p>

<p>
  <em>
    Otetaan analogia tosielämästä ja puhutaan käsitteestä auto. Jokainen tietää mistä autossa on kyse ja mihin sitä käytetään. Moni pystyisi myös piirtämään auton pyydettäessä. Käsite auto kuitenkin piilottaa paljon pienempiä osia: autossa on esimerkiksi renkaat, runko, moottori, istuimia, ... Kukin näistä käsitteistä on myös oma abstraktionsa. Esimerkiksi rengas piilottaa myös pienempiä osia -- renkaalla on vanne, ulkokumi, sisäkumi, jnejne.
  </em>
</p>

<p>
  Abstrahoinnista on ohjelmoijalle useita etuja. Se helpottaa asioista puhumista ja sitä kautta niiden käsittelyä. Se helpottaa ohjelmointia -- esimerkiksi käyttämämme apukirjastot kuten Scanner ovat toisten tekemiä valmiita abstraktioita ohjelmointiin liittyvistä tyypillisistä ongelmista. Se myös helpottaa omaa ohjelmointiamme: aivan kuten auto koostuu useammasta pienemmästä osasta, voimme koostaa ohjelmamme useammasta abstraktiosta ja luoda tätä kautta uusia abstraktioita.
</p>


<% partial 'partials/material_sub_sub_heading' do %>
  Kapselointi
<% end %>

<p>
  Kapseloinissa on kyse toteutuksen piilottamisesta julkisen rajapinnan taakse. Käytännössä olio-ohjelmoinissa kyse on muuttujien ja metodien konkreettisen toiminnallisuuden piilottamisesta olion "sisään". Olion käyttöön tarvittavat metodit (ml. konstruktorit) -- eli rajapinta -- ovat käyttäjän nähtävissä, mutta käyttäjä ei pääse käsiksi olion sisäiseen toteutukseen.
</p>

<p>
  Tällöin toiset oliot voivat kutsua olion metodeja ilman, että niiden tarvitsee tietää kutsuttavan olion sisäisestä tilasta tai metodien konkreettisesta toteutuksesta. Tällöin kukin olio on myös itsenäinen, eikä niiden sisäinen tila ole riippuvainen toisten olioiden sisäisestä tilasta.
</p>


<% partial 'partials/material_sub_sub_heading' do %>
  Perintä
<% end %>

<p>
  Olio-ohjelmoinnissa on mahdollista luoda luokkia, jotka perivät toisen luokan ominaisuuksia (eli oliomuuttujat ja metodit). Tällöin luokasta tehdyt oliot ovat samalla myös perityn luokan ilmentymiä, jolloin oliot voivat esiintyä useampina erilaisina olioina käyttötarpeesta riippuen.
</p>

<p>
  <em>
    Palaamme perintään ohjelmoinnin jatkokurssilla...
  </em>
</p>


<% partial 'partials/exercise', locals: { name: 'Maatilasimulaattori (5 osaa)' } do %>

  <p>
    Maatiloilla on lypsäviä eläimiä, jotka tuottavat maitoa.  Maatilat eivät itse käsittele maitoa, vaan se kuljetetaan Maitoautoilla meijereille.  Meijerit ovat yleisiä maitotuotteita tuottavia rakennuksia.  Jokainen meijeri erikoistuu yhteen tuotetyyppiin, esimerkiksi Juustomeijeri tuottaa Juustoa, Voimeijeri tuottaa voita ja Maitomeijeri tuottaa maitoa.
  </p>

  <p>
    Rakennetaan maidon elämää kuvaava simulaattori.
  </p>


  <h2>Maitosäiliö</h2>

  <p>
    Jotta maito pysyisi tuoreena, täytyy se säilöä sille tarkoitettuun säiliöön. Säiliöitä valmistetaan sekä oletustilavuudella 2000 litraa, että asiakkaalle räätälöidyllä tilavuudella.  Toteuta luokka Maitosailio jolla on seuraavat konstruktorit ja metodit.
  </p>

  <ul>
    <li><strong>public Maitosailio()</strong></li>
    <li><strong>public Maitosailio(double tilavuus)</strong></li>
    <li><strong>public double getTilavuus()</strong></li>
    <li><strong>public double getSaldo()</strong></li>
    <li><strong>public double paljonkoTilaaJaljella()</strong></li>
    <li><strong>public void lisaaSailioon(double maara)</strong>
      lisää säiliöön vain niin paljon maitoa kuin sinne mahtuu,
      ylimääräiset jäävät lisäämättä, maitosäiliön ei siis tarvitse huolehtia tilanteesta jossa maitoa valuu yli</li>
    <li><strong>public double otaSailiosta(double maara)</strong>
      ottaa säiliöstä pyydetyn määrän, tai niin paljon kuin siellä on jäljellä
    </li>
  </ul>

  <p>
    Huomaa, että teet <em>kaksi konstruktoria</em>. Kutsuttava konstruktori määräytyy sille annettujen parametrien perusteella. Jos kutsut <code>new Maitosailio()</code>, suoritetaan ensimmäisen konstruktorin lähdekoodi. Toista konstruktoria taas kutsutaan antamalla konstruktorille parametrina tilavuus, esim. <code>new Maitosailio(300.0)</code>.
  </p>

  <p>
    Toteuta <code>Maitosailio</code>-luokalle myös <code>toString()</code>-metodi, jolla kuvaat sen tilaa. Ilmaistessasi säiliön tilaa <code>toString()</code>-metodissa, pyöristä litramäärät ylöspäin käyttäen <code>Math</code>-luokan tarjoamaa <code>ceil()</code>-metodia.
  </p>

  <p>
    Testaa maitosailiötä seuraavalla ohjelmapätkällä:
  </p>

  <% partial 'partials/code_highlight' do %>
Maitosailio sailio = new Maitosailio();
sailio.otaSailiosta(100);
sailio.lisaaSailioon(25);
sailio.otaSailiosta(5);
System.out.println(sailio);

sailio = new Maitosailio(50);
sailio.lisaaSailioon(100);
System.out.println(sailio);
  <% end %>

  <% partial 'partials/sample_output' do %>
20.0/2000.0
50.0/50.0
  <% end %>


  <h2>Lehmä</h2>

  <p>
    Saadaksemme maitoa tarvitsemme myös lehmiä. Lehmällä on nimi ja utareet. Utareiden tilavuus on satunnainen luku väliltä 15 ja 40, luokkaa <code>Random</code> voi käyttäää satunnaislukujen arpomiseen, esimerkiksi  <code>int luku = 15 + new Random().nextInt(26);</code>. Luokalla <code>Lehma</code> on seuraavat toiminnot:
  </p>

  <ul>
    <li><strong>public Lehma()</strong> luo uuden lehmän satunnaisesti valitulla nimellä</li>
    <li><strong>public Lehma(String nimi)</strong> luo uuden lehmän annetulla nimellä</li>
    <li><strong>public String getNimi()</strong> palauttaa lehmän nimen</li>
    <li><strong>public double getTilavuus()</strong> palauttaa utareiden tilavuuden</li>
    <li><strong>public double getMaara()</strong> palauttaa utareissa olevan maidon määrän</li>
    <li><strong>public String toString()</strong> palauttaa lehmää kuvaavan merkkijonon (ks. esimerkki alla)</li>
  </ul>

  <p>
    <code>Lehma</code> toteuttaa myös rajapinnat: <code>Lypsava</code>, joka kuvaa lypsämiskäyttäytymistä, ja <code>Eleleva</code>, joka kuvaa elelemiskäyttäytymistä.
  </p>

  <% partial 'partials/code_highlight' do %>
public interface Lypsava {
    public double lypsa();
}

public interface Eleleva {
    public void eleleTunti();
}
  <% end %>


  <p>
    Lehmää lypsettäessä sen koko maitovarasto tyhjennetään jatkokäsittelyä varten. Lehmän elellessä sen maitovarasto täyttyy hiljalleen. Suomessa maidontuotannossa käytetyt lehmät tuottavat keskimäärin noin 25-30 litraa maitoa päivässä. Simuloidaan tätä tuotantoa tuottamalla noin 0.7 - 2 litraa tunnissa.
  </p>

  <p>
    Simuloi tuotantoa tuottamalla noin 0.7 - 2 litraa tunnissa. Random-luokan metodista <code>nextDouble</code>, joka palauttaa satunnaisluvun 0 ja 1 välillä lienee tässä hyötyä.
  </p>

  <p>
    Lisäksi, jos lehmälle ei anneta nimeä, valitse sille nimi satunnaisesti seuraavasta taulukosta. Tässä on hyötyä Random-luokan metodista <code>nextInt</code>, jolle annetaan parametrina yläraja. Kannattaa tutustua Random-luokan toimintaan erikseen ennen kuin lisää sen osaksi tätä ohjelmaa.
  </p>

  <% partial 'partials/code_highlight' do %>
private static final String[] NIMIA = new String[]{
    "Anu", "Arpa", "Essi", "Heluna", "Hely",
    "Hento", "Hilke", "Hilsu", "Hymy", "Matti", "Ilme", "Ilo",
    "Jaana", "Jami", "Jatta", "Laku", "Liekki",
    "Mainikki", "Mella", "Mimmi", "Naatti",
    "Nina", "Nyytti", "Papu", "Pullukka", "Pulu",
    "Rima", "Soma", "Sylkki", "Valpu", "Virpi"};
  <% end %>

  <p>
    Toteuta luokka Lehma ja testaa sen toimintaa seuraavan ohjelmapätkän avulla.
  </p>

  <% partial 'partials/code_highlight' do %>
Lehma lehma = new Lehma();
System.out.println(lehma);


Eleleva elelevaLehma = lehma;
elelevaLehma.eleleTunti();
elelevaLehma.eleleTunti();
elelevaLehma.eleleTunti();
elelevaLehma.eleleTunti();

System.out.println(lehma);

Lypsava lypsavaLehma = lehma;
lypsavaLehma.lypsa();

System.out.println(lehma);
System.out.println("");

lehma = new Lehma("Ammu");
System.out.println(lehma);
lehma.eleleTunti();
lehma.eleleTunti();
System.out.println(lehma);
lehma.lypsa();
System.out.println(lehma);
  <% end %>

  <p>
    Ohjelman tulostus on erimerkiksi seuraavanlainen.
  </p>

  <% partial 'partials/sample_output' do %>
Liekki 0.0/23.0
Liekki 7.0/23.0
Liekki 0.0/23.0
Ammu 0.0/35.0
Ammu 9.0/35.0
Ammu 0.0/35.0
  <% end %>


  <h2>Lypsyrobotti</h2>

  <p>
    Nykyaikaisilla maatiloilla lypsyrobotit hoitavat lypsämisen. Jotta lypsyrobotti voi lypsää lypsävää otusta, tulee lypsyrobotin olla kiinnitetty maitosäiliöön:
  </p>

  <ul>
    <li><strong>public Lypsyrobotti()</strong> luo uuden lypsyrobotin</li>
    <li><strong>public Maitosailio getMaitosailio()</strong> palauttaa kiinnitetyn maitosäiliö tai <code>null</code>-viitteen, jos säiliötä ei ole vielä kiinnitetty</li>
    <li><strong>public void setMaitosailio(Maitosailio maitosailio)</strong> kiinnittää annetun säiliön lypsyrobottiin</li>
    <li><strong>public void lypsa(Lypsava lypsava)</strong> lypsää lehmän robottiin kiinnitettyyn maitosäiliöön. Jos robottiin ei ole kiinnitetty maitosäiliötä, ohjelma ilmoittaa että maito menee hukkaan.</li>
  </ul>

  <p>
    Toteuta luokka Lypsyrobotti ja testaa sitä seuraavien ohjelmanpätkien avulla. Varmista että lypsyrobotti voi lypsää kaikkia Lypsava-rajapinnan toteuttavia olioita!
  </p>

  <% partial 'partials/code_highlight' do %>
Lypsyrobotti lypsyrobotti = new Lypsyrobotti();
Lehma lehma = new Lehma();
lypsyrobotti.lypsa(lehma);
  <% end %>

  <% partial 'partials/sample_output' do %>
Maidot menevät hukkaan!
  <% end %>

  <% partial 'partials/code_highlight' do %>
Lypsyrobotti lypsyrobotti = new Lypsyrobotti();
Lehma lehma = new Lehma();
System.out.println("");

Maitosailio sailio = new Maitosailio();
lypsyrobotti.setMaitosailio(sailio);
System.out.println("Säiliö: " + sailio);

for (int i = 0; i &lt; 2; i++) {
    System.out.println(lehma);
    System.out.println("Elellään..");
    for (int j = 0; j &lt; 5; j++) {
        lehma.eleleTunti();
    }
    System.out.println(lehma);

    System.out.println("Lypsetään...");
    lypsyrobotti.lypsa(lehma);
    System.out.println("Säiliö: " + sailio);
    System.out.println("");
}<% end %>

  <p>
    Ohjelman tulostus on esimerkiksi seuraavanlainen.
  </p>

  <% partial 'partials/sample_output' do %>
Säiliö: 0.0/2000.0
Mella 0.0/23.0
Elellään..
Mella 6.2/23.0
Lypsetään...
Säiliö: 6.2/2000.0

Mella 0.0/23.0
Elellään..
Mella 7.8/23.0
Lypsetään...
Säiliö: 14.0/2000.0
  <% end %>


  <h2>Navetta</h2>

  <p>
    Lehmät hoidetaan (eli tässä tapauksessa lypsetään) navetassa. Alkukantaisissa navetoissa on maitosäiliö ja tilaa yhdelle lypsyrobotille. Huomaa että lypsyrobottia asennettaessa se kytketään juuri kyseisen navetan maitosäiliöön.  Jos navetassa ei ole lypsyrobottia, ei siellä voida myöskään hoitaa lehmiä. Toteuta luokka <code>Navetta</code> jolla on seuraavat konstruktorit ja metodit:
  </p>

  <ul>
    <li><strong>public Navetta(Maitosailio maitosailio)</strong></li>
    <li><strong>public Maitosailio getMaitosailio()</strong> palauttaa navetan maitosailion</li>
    <li><strong>public void asennaLypsyrobotti(Lypsyrobotti lypsyrobotti)</strong> asentaa lypsyrobotin ja kiinnittää sen navetan maitosäiliöön</li>
    <li><strong>public void hoida(Lehma lehma)</strong> lypsää parametrina annetun lehmän lypsyrobotin avulla, metodi heittää poikkeuksen <code>IllegalStateException</code>, jos lypsyrobottia ei ole asennettu</li>
    <li><strong>public void hoida(Collection&lt;Lehma&gt; lehmat)</strong> lypsää parametrina annetut lehmät lypsyrobotin avulla, metodi heittää poikkeuksen <code>IllegalStateException</code>, jos lypsyrobottia ei ole asennettu</li>
    <li><strong>public String toString()</strong> palauttaa navetan sisältämän maitosäiliön tilan</li>
  </ul>

  <p>
    Testaa luokkaa <code>Navetta</code> seuraavan ohjelmapätkän avulla.
  </p>

  <% partial 'partials/code_highlight' do %>
Navetta navetta = new Navetta(new Maitosailio());
System.out.println("Navetta: " + navetta);

Lypsyrobotti robo = new Lypsyrobotti();
navetta.asennaLypsyrobotti(robo);

Lehma ammu = new Lehma();
ammu.eleleTunti();
ammu.eleleTunti();

navetta.hoida(ammu);
System.out.println("Navetta: " + navetta);

List&lt;Lehma&gt; lehmaLista = new ArrayList&lt;&gt;();
lehmaLista.add(ammu);
lehmaLista.add(new Lehma());

for (Lehma lehma: lehmaLista) {
    lehma.eleleTunti();
    lehma.eleleTunti();
};

navetta.hoida(lehmaLista);
System.out.println("Navetta: " + navetta);
  <% end %>

  <p>
    Tulostuksen tulee olla esimerkiksi seuraavanlainen:
  </p>

  <% partial 'partials/sample_output' do %>
Navetta: 0.0/2000.0
Navetta: 2.8/2000.0
Navetta: 9.6/2000.0
  <% end %>


  <h2>Maatila</h2>

  <p>
    Maatilalla on omistaja ja siihen kuuluu navetta sekä joukko lehmiä. Maatila toteuttaa myös aiemmin nähdyn rajapinnan <code>Eleleva</code>, jonka metodia <code>eleleTunti()</code>-kutsumalla kaikki maatilaan liittyvät lehmät elelevät tunnin.  Toteuta luokka maatila siten, että se toimii seuraavien esimerkkiohjelmien mukaisesti.
  </p>

  <% partial 'partials/code_highlight' do %>
Maitosailio sailio = new Maitosailio();
Navetta navetta = new Navetta(sailio);

Maatila maatila = new Maatila("Esko", navetta);
System.out.println(maatila);

System.out.println(maatila.getOmistaja() + " on ahkera mies!");
  <% end %>

  <p>
    Odotettu tulostus:
  </p>

  <% partial 'partials/sample_output' do %>
Maatilan omistaja: Esko
Navetan maitosäiliö: 0.0/2000.0
Ei lehmiä.
Esko on ahkera mies!
  <% end %>

  <% partial 'partials/code_highlight' do %>
Maatila maatila = new Maatila("Esko", new Navetta(new Maitosailio()));
maatila.lisaaLehma(new Lehma());
maatila.lisaaLehma(new Lehma());
maatila.lisaaLehma(new Lehma());
System.out.println(maatila);
  <% end %>

  <p>
    Odotettu tulostus:
  </p>

  <% partial 'partials/sample_output' do %>
Maatilan omistaja: Esko
Navetan maitosäiliö: 0.0/2000.0
Lehmät:
    Naatti 0.0/19.0
    Hilke 0.0/30.0
    Sylkki 0.0/29.0
  <% end %>

  <% partial 'partials/code_highlight' do %>
Maatila maatila = new Maatila("Esko", new Navetta(new Maitosailio()));

maatila.lisaaLehma(new Lehma());
maatila.lisaaLehma(new Lehma());
maatila.lisaaLehma(new Lehma());

maatila.eleleTunti();
maatila.eleleTunti();

System.out.println(maatila);
  <% end %>

  <p>
    Odotettu tulostus:
  </p>

  <% partial 'partials/sample_output' do %>
Maatilan omistaja: Esko
Navetan maitosäiliö: 0.0/2000.0
Lehmät:
    Heluna 2.0/17.0
    Rima 3.0/32.0
    Ilo 3.0/25.0
  <% end %>

  <% partial 'partials/code_highlight' do %>
Maatila maatila = new Maatila("Esko", new Navetta(new Maitosailio()));
Lypsyrobotti robo = new Lypsyrobotti();
maatila.asennaNavettaanLypsyrobotti(robo);

maatila.lisaaLehma(new Lehma());
maatila.lisaaLehma(new Lehma());
maatila.lisaaLehma(new Lehma());

maatila.eleleTunti();
maatila.eleleTunti();

maatila.hoidaLehmat();

System.out.println(maatila);
  <% end %>

  <p>
    Odotettu tulostus:
  </p>

  <% partial 'partials/sample_output' do %>
Maatilan omistaja: Esko
Navetan maitosäiliö: 18.0/2000.0
Lehmät:
    Hilke 0.0/30.0
    Sylkki 0.0/35.0
    Hento 0.0/34.0
  <% end %>

  <p>
    Edellä otettiin ensiaskeleet simulaattorin tekemiseen. Ohjelmaa voisi jatkaa vaikkapa lisäämällä maitoauton sekä luomalla useampia navettoja. Maitoautot voisivat kulkea tehtaalle, jossa tehtäisiin juustoa, jnejne..
  </p>

<% end %>




<% partial 'partials/exercise', locals: { name: 'Autorekisterikeskus (3 osaa)' } do %>

  <p>
    TODO: låinkki hashmap-kertaukseen
  </p>


  <h2>Rekisterinumeron equals ja hashCode</h2>

  <p>
    Eurooppalaiset rekisteritunnukset koostuvat kahdesta osasta: yksi tai kaksikirjaimisesta maatunnuksesta ja maakohtaisesti määrittyvästä rekisterinumerosta, joka taas koostuu numeroista ja merkeistä. Rekisterinumeroita esitetään seuraavanlaisen luokan avulla:
  </p>

  <% partial 'partials/code_highlight' do %>
public class Rekisterinumero {
    // tässä määre final tarkoittaa sitä, että arvoa ei voi muuttaa asetuksen jälkeen
    private final String rekNro;
    private final String maa;

    public Rekisterinumero(String rekNro, String maa) {
       this.rekNro = rekNro;
       this.maa = maa;
    }

    public String toString(){
        return maa+ " "+rekNro;
    }
}
  <% end %>

  <p>
    Rekisterinumeroja halutaan tallettaa esim. ArrayList:eille ja käyttää HashMap:in avaimina, eli kuten yllä mainittu, tulee niille toteuttaa metodit <code>equals</code> ja <code>hashCode</code>, muuten ne eivät toimi halutulla tavalla. Toteuta luokalle rekisterinumero metodit <code>equals</code> ja <code>hashCode</code>.
  </p>

  <p>Esimerkkiohjelma:</p>

  <% partial 'partials/code_highlight' do %>
public static void main(String[] args) {
    Rekisterinumero rek1 = new Rekisterinumero("FI", "ABC-123");
    Rekisterinumero rek2 = new Rekisterinumero("FI", "UXE-465");
    Rekisterinumero rek3 = new Rekisterinumero("D", "B WQ-431");

    ArrayList&lt;Rekisterinumero&gt; suomalaiset = new ArrayList&lt;&gt;();
    suomalaiset.add(rek1);
    suomalaiset.add(rek2);

    Rekisterinumero uusi = new Rekisterinumero("FI", "ABC-123");
    if (!suomalaiset.contains(uusi)) {
        suomalaiset.add(uusi);
    }
    System.out.println("suomalaiset: " + suomalaiset);
    // jos equals-metodia ei ole ylikirjoitettu, menee sama rekisterinumero toistamiseen listalle

    HashMap&lt;Rekisterinumero, String&gt; omistajat = new HashMap&lt;&gt;();
    omistajat.put(rek1, "Arto");
    omistajat.put(rek3, "Jürgen");

    System.out.println("omistajat:");
    System.out.println(omistajat.get(new Rekisterinumero("FI", "ABC-123")));
    System.out.println(omistajat.get(new Rekisterinumero("D", "B WQ-431")));
    // jos hashCode ei ole ylikirjoitettu, eivät omistajat löydy
}
  <% end %>

  <p>
    Jos equals ja hashCode on toteutettu oikein, tulostus on seuraavanlainen.
  </p>

  <% partial 'partials/sample_output' do %>
suomalaiset: [FI ABC-123, FI UXE-465]
omistajat:
Arto
Jürgen
  <% end %>


  <h2>Omistaja rekisterinumeron perusteella</h2>

  <p>
    Toteuta luokka <code>Ajoneuvorekisteri</code> jolla on seuraavat metodit:
  </p>

  <ul>
    <li><code>public boolean lisaa(Rekisterinumero rekkari, String omistaja)</code> lisää parametrina olevaa rekisterinumeroa vastaavalle autolle parametrina olevan omistajan, metodi palauttaa true jos omistajaa ei ollut ennestään, jos rekisterinumeroa vastaavalla autolla oli jo omistaja, metodi palauttaa false ja ei tee mitään</li>

    <li><code>public String hae(Rekisterinumero rekkari)</code> palauttaa parametrina olevaa rekisterinumeroa vastaavan auton omistajan. Jos auto ei ole rekisterissä, palautetaan <code>null</code></li>

    <li><code>public boolean poista(Rekisterinumero rekkari)</code> poistaa parametrina olevaa rekisterinumeroa vastaavat tiedot, metodi palauttaa true jos tiedot poistetiin, ja false jos parametria vastaavia tietoja ei ollut rekisterissä</li>
  </ul>

  <p>
    <strong>Huom:</strong> Ajoneuvorekisterin täytyy tallettaa omistajatiedot <code>HashMap&lt;Rekisterinumero, String&gt; omistajat</code> -tyyppiseen oliomuuttujaan!
  </p>


  <h2>Ajoneuvorekisteri laajenee</h2>

  <p>
    Lisää Ajoneuvorekisteriin vielä seuraavat metodit:
  </p>

  <ul>

    <li>
      <code>public void tulostaRekisterinumerot()</code> tulostaa rekisterissä olevat rekisterinumerot.
    </li>
    
    <li>
      <code>public void tulostaOmistajat()</code> tulostaa rekisterissä olevien autojen omistajat. Kukin nimi tulee tulostaa vain kertaalleen vaikka omistajalla olisikin useampi auto.
    </li>
  </ul>

<% end %>


---



<% partial 'partials/hint', locals: { name: 'Miten toimikaan for (int i = 0; ...?' } do %>

  <p>
    Yllä olevassa esimerkissä käytettiin for-toistolausetta alkioiden läpikäyntiin. Toistolausetta käytetään listojen läpikäyntiin indeksien perusteella -- saman voisi toteuttaa myös while-toistolauseella. 
  </p>

  <% partial 'partials/code_highlight' do %>
    ArrayList&lt;String&gt; sivut = new ArrayList&lt;&gt;();
    sivut.add("Pilko metodisi lyhyiksi luettaviksi kokonaisuuksiksi.");
    sivut.add("Erota käyttöliittymälogiikka sovelluksen logiikasta.");
    sivut.add("Ohjelmoi aina ensin pieni osa, jolla ratkaiset osan ongelmasta.");
    sivut.add("Harjoittelu tekee mestarin. Keksi ja tee omia kokeiluja ja projekteja.");

    Sahkokirja kirja = new Sahkokirja("Vinkkejä ohjelmointiin.", sivut);

    int sivu = 0;
    while (sivu &lt; kirja.sivuja()) {
        System.out.println(kirja.lue());
        sivu++;
    }
  <% end %>

  <p>
    Saman voi kirjoittaa myös for-toistolauseella seuraavasti.
  </p>

  <% partial 'partials/code_highlight' do %>
    ArrayList&lt;String&gt; sivut = new ArrayList&lt;&gt;();
    sivut.add("Pilko metodisi lyhyiksi luettaviksi kokonaisuuksiksi.");
    sivut.add("Erota käyttöliittymälogiikka sovelluksen logiikasta.");
    sivut.add("Ohjelmoi aina ensin pieni osa, jolla ratkaiset osan ongelmasta.");
    sivut.add("Harjoittelu tekee mestarin. Keksi ja tee omia kokeiluja ja projekteja.");

    Sahkokirja kirja = new Sahkokirja("Vinkkejä ohjelmointiin.", sivut);
    for (int sivu = 0; sivu &lt; kirja.sivuja(); sivu++) {
        System.out.println(kirja.lue());
    }
  <% end %>

  
  
<% end %>


<% partial 'partials/exercise', locals: { name: 'Sukunimet Espanjassa (2 osaa)' } do %>

  <p>
    Espanjassa ihmisillä on kaksi sukunimeä. Ennen vuoden 1999 lakimuutosta lapsen ensimmäinen sukunimi tuli isän ensimmäisestä sukunimestä ja toinen äidin ensimmäisestä sukunimestä. Vuonna 1999 lainsäädäntöä muutettiin niin, että vanhempien yhteisestä päätöksestä ensimmäiseksi sukunimeksi voidaan valita myös äidin ensimmäinen sukunimi.
  </p>

  <p>
    Tee tämän tehtävän luokat pakkaukseen <code>sukunimet</code>.
  </p>

  <h2>Henkilo</h2>
  
  <p>
    Tarkastellaan olioiden monimuotoisuutta luomalla vuotta 1999 edeltävää Espanjalaista nimentää kuvaava luokka Henkilo. 
  </p>

  <p>
    Luo luokka Henkilo, jolla on kaksi konstruktoria:
  </p>

  <ul>
    <li>
      public Henkilo(String etunimi, String ensimmainenSukunimi, String toinenSukunimi)
    </li>
    <li>
      public Henkilo(String etunimi, Henkilo isa, Henkilo aiti)
    </li>
  </ul>

  <p>
    Luo luokalle lisäksi toString-metodi, joka tulostaa henkilöä kuvaavan merkkijonoesityksen.
  </p>

  <p>
    Luokan tulee toimia seuraavasti. Huomaa myös viimeinen rivi, missä luokasta tehtyä oliota käsitellään Object-tyyppisenä. 
  </p>

  <% partial 'partials/code_highlight' do %>
    Henkilo dolores = new Henkilo("Dolores", "D.", "Parto");
    System.out.println(dolores);

    Henkilo hay = new Henkilo("Hay", "Alen", "Gualarga");
    System.out.println(hay);

    Henkilo nacho = new Henkilo("Nacho", "Cuesta", "Parto");
    System.out.println(nacho);

    Henkilo valeria = new Henkilo("Valeria", "Mogollon", "Gualarga");
    System.out.println(valeria);

    Henkilo enrico = new Henkilo("Enrico", dolores, hay);
    System.out.println(enrico);

    Henkilo luz = new Henkilo("Luz", nacho, valeria);
    System.out.println(luz);

    Henkilo valentina = new Henkilo("Valentina", enrico, luz);
    System.out.println(valentina);

    Object valObject = valentina;
    System.out.println(valObject);
  <% end %>


  <% partial 'partials/sample_output' do %>
    Dolores D. Parto
    Hay Alen Gualarga
    Nacho Cuesta Parto
    Valeria Mogollon Gualarga
    Enrico D. Alen
    Luz Cuesta Mogollon
    Valentina D. Cuesta
    Valentina D. Cuesta
  <% end %>

  
  <h2>Perhe</h2>

  <p>
    Toteuta tämän jälkeen luokka <code>Perhe</code>. Luokan tulee toimia seuraavasti.
  </p>

  
  <% partial 'partials/code_highlight' do %>
    Henkilo hay = new Henkilo("Hay", "Alen", "Gualarga");
    Henkilo nacho = new Henkilo("Nacho", "Cuesta", "Parto");
    Henkilo dolores = new Henkilo("Dolores", "D.", "Parto");
    Henkilo enrico = new Henkilo("Enrico", dolores, hay);
    Henkilo luz = new Henkilo("Luz", nacho, valeria);
    Henkilo valentina = new Henkilo("Valentina", enrico, luz);

    Perhe perhe = new Perhe();
    perhe.lisaa(dolores);
    perhe.lisaa(luz);
    perhe.lisaa(valentina);
    System.out.println(perhe);

    System.out.println();

    perhe.poista(luz);
    System.out.println(perhe);

    System.out.println();
    
    Object perheObj = perhe;
    System.out.println(perheObj);

    System.out.println();
    
    perhe.lisaa(enrico);
    System.out.println(perheObj);
  <% end %>

  <% partial 'partials/sample_output' do %>
    Dolores D. Parto
    Luz Cuesta Mogollon
    Valentina D. Cuesta

    Dolores D. Parto
    Valentina D. Cuesta

    Dolores D. Parto
    Valentina D. Cuesta
    Enrico D. Alen
  <% end %>

  <p>
    Tee sekä metodista <code>lisaa</code> että metodista <code>poista</code> sellaiset, että ne eivät palauta mitään arvoa. 
  </p>

  <p>
    Mikä tässä oikein oli monimuotoisuutta? Kaikki luokat ovat Object-tyyppisiä. Vaikka henkilöä tarkastellaan Object-oliona, suoritetaan <code>toString</code>-metodin lähdekoodi olion "oikeaan" tyyppiin liittyvästä luokasta.
  </p>
  

<% end %>

