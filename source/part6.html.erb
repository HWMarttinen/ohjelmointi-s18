---
  title: Osa 6
  exercise_page: true
  quiz_page: true
  published: false
---

<p>
  tänne tietomallin abstrahoinnista (metodeille ei annetakaan henkilöä vaan..)
</p>


<% partial 'partials/exercise', locals: { name: 'Puhelinmuistio (3 osaa)' } do %>

  <p>
    Tehtävässä tehdään puhelinmuistio.
  </p>

  <h2>Henkilö</h2>

  <p>
    Tee ensin luokka <code>Henkilo</code>. Luokan tulee toimia seuraavan esimerkin osoittamalla tavalla:
  </p>

  <% partial 'partials/code_highlight' do %>
    Henkilo pekka = new Henkilo("Pekka Mikkola", "040-123123");

    System.out.println(pekka.getNimi());
    System.out.println(pekka.getNumero());

    System.out.println(pekka);

    pekka.vaihdaNumeroa("050-333444");
    System.out.println(pekka);
  <% end %>

  <p>
    Tulostuu:
  </p>

  <% partial 'partials/sample_output' do %>
    Pekka Mikkola
    040-123123
    Pekka Mikkola  puh: 040-123123
    Pekka Mikkola  puh: 050-333444
  <% end %>

  <p>
    Tee siis luokalle
  </p>

  <ul>
    <li> metodi <code>public String toString()</code>, joka palauttaa henkilön merkkijonoesityksen (yo. esimerkin tapaan muotoiltuna)</li>
    <li> konstruktori, jolla asetetaan henkilölle nimi ja puhelinnumero</li>
    <li> <code>public String getNimi()</code>, joka palauttaa nimen</li>
    <li> <code>public String getNumero()</code>, joka palauttaa puhelinnumeron</li>
    <li> metodi <code>public void vaihdaNumeroa(String uusiNumero)</code>, joka muuttaa henkilön puhelinnumeroa</li>
  </ul>

  
  <h2>Henkilöiden lisäys puhelinmuistioon</h2>

  <p>
    Tee luokka <code>Puhelinmuistio</code> joka tallettaa sisällään olevaan ArrayListiin <code>Henkilo</code>-olioita. Tässä vaiheessa luokalle tehdään seuraavat metodit:
  </p>

  <p>
    TODO: pitäisikö lisaa olla henkilo-olion lisääminen? Myöhemmäksi lisääminen merkkijonon perusteella (eli sisäisen toteutuksen piilottaminen)
  </p>

  <ul>
    <li> <code>public void lisaa(String nimi, String numero)</code> luo <code>Henkilo</code>-olion ja lisää sen puhelinmuistion ArrayListiin.</li>
    <li><code>public void tulostaKaikki()</code>, tulostaa puhelinmuistion sisällön</li>
  </ul>

  <p>
    Esimerkki muistion toiminnasta:
  </p>

  <% partial 'partials/code_highlight' do %>
    Puhelinmuistio muistio = new Puhelinmuistio();

    muistio.lisaa("Pekka Mikkola", "040-123123");
    muistio.lisaa("Antti Laaksonen", "045-456123");
    muistio.lisaa("Juhana Laurinharju", "050-222333");

    muistio.tulostaKaikki();
  <% end %>

  <p>
    Ohjelman tulostus oikein toteutetuilla luokilla on:
  </p>

  <% partial 'partials/sample_output' do %>
    Pekka Mikkola  puh: 040-123123
    Antti Laaksonen  puh: 045-456123
    Juhana Laurinharju  puh: 050-222333
  <% end %>

  
  <h2>Numerojen haku muistiosta</h2>

  <p>
    Tehdään puhelinmuistiolle metodi <code>public String haeNumero(String nimi)</code>, joka  palauttaa parametrina annetun henkilön numeron. Jos henkilö ei ole muistiossa, palautetaan merkkijono "numero ei tiedossa". Esimerkki metodin toiminnasta:
  </p>

  <% partial 'partials/code_highlight' do %>
    Puhelinmuistio muistio = new Puhelinmuistio();
    muistio.lisaa("Pekka Mikkola", "040-123123");
    muistio.lisaa("Antti Laaksonen", "045-456123");
    muistio.lisaa("Juhana Laurinharju", "050-222333");

    String numero = muistio.haeNumero("Pekka Mikkola");
    System.out.println(numero);

    numero = muistio.haeNumero("Martti Tienari");
    System.out.println(numero);
  <% end %>

  <p>
    Tulostuu:
  </p>

  <% partial 'partials/sample_output' do %>
    040-123123
    numero ei tiedossa
  <% end %>
  
<% end %>



<% partial 'partials/material_heading' do %>
  Luokka- ja oliometodit: määre static
<% end %>


<p>
  esitellään static tapana pilkkoa ohjelman toiminnallisuutta pienmpiin osiin: käyttöliitttymä?
</p>

<p>
  Kurssin alussa kaikissa metodeissa esiintyi määre <code>static</code>, mutta aloittaessamme olioiden käytön, tuon määreen käyttö jopa kiellettiin. Mistä on kysymys?
</p>

<p>
  Seuraavassa esimerkissä on metodi <code>nollaaLista</code> joka toimii nimensä mukaisesti eli asettaa nollan parametrina saamansa listan kaikkien lukujen arvoksi.
</p>

<% partial 'partials/code_highlight' do %>
import java.util.ArrayList;

public class Ohjelma {

    public static void nollaaLista(ArrayList&lt;Integer&gt; lista) {
        for (int i = 0; i &lt; lista.size(); i++) {
            lista.set(i, 0);
        }
    }

    public static void main(String[] args) {
        ArrayList&lt;Integer&gt; luvut = new ArrayList&lt;&gt;();
        luvut.add(1);
        luvut.add(2);
        luvut.add(3);
        luvut.add(4);
        luvut.add(5);

        for (int luku : luvut) {
            System.out.print(luku + " ");  // tulostuu 1 2 3 4 5
        }

        System.out.println();

        nollaaLista(luvut);

        for (int luku : luvut) {
            System.out.print(luku + " ");  // tulostuu 0 0 0 0 0
        }
    }
}
<% end %>

<p>
  Yllä olevassa esimerkissä metodilla <code>nollaaLista</code> on määre <code>static</code> ja sen kutsuminen tapahtuu ilman alussa olevaa olioviitettä.
</p>

<p>
  <em>Staattiset metodit</em> eivät liity olioon vaan luokkaan. Staattisia metodeja kutsutaan usein myös <em>luokkametodeiksi</em>. Toisin kuin olioiden metodit (joilla ei ole määrettä static), staattiseen metodiin ei liity olioa, eikä niillä voi muokata oliomuuttujia.
</p>

<p>
  Staattiselle metodille voi toki antaa olion parametrina. Staattinen metodi ei kuitenkaan voi käsitellä mitään muita lukuja, merkkijonoja, tai olioita kuin niitä, jotka annetaan sille parametrina, tai jotka se luo itse.
</p>

<p>
  Toisin sanoen, staattista metodia käyttävän koodin tulee antaa staattiselle metodille ne arvot ja oliot, joita staattisessa metodissa käsitellään.
</p>

<p>
  Koska staattinen metodi ei liity mihinkään olioon, ei sitä kutsuta oliometodien tapaan <code>olionNimi.metodinNimi()</code>, vaan ylläolevan esimerkin tapaan käytetään pelkkää staattisen metodin nimeä.
</p>

<p>
  Jos staattisen metodin koodi on eri luokan sisällä kuin sitä kutsuva metodi, voi staattista metodia kutsua muodossa <code>LuokanNimi.staattisenMetodinNimi()</code>. Edellinen esimerkki alla muutettuna siten, että pääohjelma ja metodi ovat omissa luokissaan (eli eri tiedostoissa):
</p>

<% partial 'partials/code_highlight' do %>
import java.util.ArrayList;

public class Ohjelma {
    public static void main(String[] args) {
        ArrayList&lt;Integer&gt; luvut = new ArrayList&lt;&gt;();
        luvut.add(1);
        luvut.add(2);
        luvut.add(3);
        luvut.add(4);
        luvut.add(5);

        for (int luku : luvut) {
            System.out.print(luku + " ");  // tulostuu 1 2 3 4 5
        }

        System.out.println();

        ListaApurit.nollaaLista(luvut);

        for (int luku : luvut) {
            System.out.print(luku + " ");  // tulostuu 0 0 0 0 0
        }
    }
}
<% end %>

<% partial 'partials/code_highlight' do %>
import java.util.ArrayList;

public class ListaApurit {

    public static void nollaaLista(ArrayList&lt;Integer&gt; lista) {
        for (int i = 0; i &lt; lista.size(); i++) {
            lista.set(i, 0);
        }
    }
}
<% end %>

<p>Toisen luokan sisällä -- tässä tämän toisen luokan nimi on <code>ListaApurit</code> -- määriteltyä staattista metodia kutsutaan yllä muodossa <code>ListaApurit.nollaaLista(<em>parametri</em>);</code>.
</p>


<% partial 'partials/material_sub_heading' do %>
  Milloin staattisia metodeja tulisi käyttää
<% end %>

<p>
  Kaikki olion tilaa käsittelevät metodit tulee määritellä oliometodeina, joilla ei ole static-määrettä. Esimerkiksi edellisissä osissa määrittelemiemme luokkien kuten <code>Henkilo, Paivays, Soittolista, ...</code> kaikki metodit tulee määritellä ilman static-määrettä.
</p>

<p>
  Palataan vielä luokkaan <code>Henkilo</code>. Seuraavassa on osa luokan määritelmästä. Kaikkiin oliomuuttujiin viitataan <code>this</code>-määreen avulla sillä korostamme, että metodeissa käsitellään olion "sisällä" olevia oliomuuttujia.
</p>

<% partial 'partials/code_highlight' do %>
public class Henkilo {
    private String nimi;
    private int ika;

    public Henkilo(String nimi) {
        this.ika = 0;
        this.nimi = nimi;
    }

    public boolean taysiIkainen() {
        if (this.ika &lt; 18) {
            return false;
        }

        return true;
    }

    public void vanhene() {
        this.ika++;
    }

    public String getNimi() {
        return this.nimi;
    }
}
<% end %>

<p>
  Koska metodit käsittelevät oliota, ei niitä voi määrittää static:eiksi eli "olioista riippumattomiksi". Jos näin yritetään tehdä, ei metodi toimi. Esimerkiksi allaoleva <code>Henkilo</code>-olion iän muokkausta yrittävä metodi <code>vanhene</code> ei toimi:
</p>

<% partial 'partials/code_highlight' do %>
public class Henkilo {
    //...

    public static void vanhene() {
        this.ika++;
    }
}
<% end %>

<p>
  Seurauksena on virheilmoitus <em>non static variable ika can not be referenced from static context</em>, joka tarkoittaa että <em>oliomuuttujaan ei voida viitata luokkametodista</em>; staattinen metodi ei siis pysty käsittelemään oliomuuttujaa.
</p>

<p>
  Eli milloin staattista metodia sitten kannattaa käyttää? Tarkastellaan aiemmin materiaalissa nähtyä henkilöolioita käsittelevää esimerkkiä:
</p>

<% partial 'partials/code_highlight' do %>
public class Main {
    public static void main(String[] args) {
        Henkilo ada = new Henkilo("Ada");
        Henkilo antti = new Henkilo("Antti");
        Henkilo juhana = new Henkilo("Juhana");

        for (int i = 0; i &lt; 30; i++) {
            ada.vanhene();
            juhana.vanhene();
        }

        antti.vanhene();

        if (ada.taysiIkainen()) {
            System.out.println(ada.getNimi() + " on täysi-ikäinen");
        } else {
            System.out.println(ada.getNimi() + " on alaikäinen ");
        }

        if (antti.taysiIkainen()) {
            System.out.println(antti.getNimi() + " on täysi-ikäinen");
        } else {
            System.out.println(antti.getNimi() + " on alaikäinen");
        }

        if (juhana.taysiIkainen()) {
            System.out.println(juhana.getNimi() + " on täysi-ikäinen");
        } else {
            System.out.println(juhana.getNimi() + " on alaikäinen ");
        }
    }
}
<% end %>

<p>
  Huomaamme, että henkilöiden täysi-ikäisyyden ilmottamiseen liittyvä koodinpätkä on copy-pastettu kolme kertaa peräkkäin. Todella rumaa!
</p>

<p>
  Henkilön täysi-ikäisyyden ilmoittaminen on mainio kohde staattiselle metodille. Kirjoitetaan ohjelma uudelleen metodia hyödyntäen:
</p>

<% partial 'partials/code_highlight' do %>
public class Main {

    public static void main(String[] args) {
        Henkilo ada = new Henkilo("Ada");
        Henkilo antti = new Henkilo("Antti");
        Henkilo juhana = new Henkilo("Juhana");

        for (int i = 0; i &lt; 30; i++) {
            ada.vanhene();
            juhana.vanhene();
        }

        antti.vanhene();

        ilmoitaTaysiIkaisyys(ada);

        ilmoitaTaysiIkaisyys(antti);

        ilmoitaTaysiIkaisyys(juhana);
    }

    private static void ilmoitaTaysiIkaisyys(Henkilo henkilo) {
        if (henkilo.taysiIkainen()) {
            System.out.println(henkilo.getNimi() + " on täysi-ikäinen");
        } else {
            System.out.println(henkilo.getNimi() + " on alaikäinen");
        }
    }
}
<% end %>

<p>
  Metodi <code>ilmoitaTaysiIkaisyys</code> on määritelty staattiseksi, eli se ei liity mihinkään olioon, <strong>mutta</strong> metodi saa parametrikseen henkilöolion. Metodia ei ole määritelty Henkilö-luokan sisälle sillä vaikka se käsittelee parametrinaan saamaan henkilöolioa, se on juuri kirjoitetun pääohjelman apumetodi, jonka avulla pääohjelma on saatu kirjoitettua selkeämmin.
</p>


<% partial 'partials/exercise', locals: { name: 'Kirjaston tietojärjestelmä (4 osaa)' } do %>

  <p>
    Tässä tehtävässä kerrataan olio-ohjelmoinnin perusteita sekä listojen käsittelyä virran avulla.
  </p>

  <p>
    <em>
      Kumpulan tiedekirjasto tarvitsee uuden järjestelmän kirjojen hallintaan. Tässä tehtävässä hahmotellaan ongelma-alueen tietosisältöä ja toteutetaan prototyyppi, joka mahdollistaa kirjan haun nimen, julkaisijan tai julkaisuvuoden perusteella.
    </em>
  </p>

  <p>
    Rakennetaan järjestelmä osista, ensin toteutetaan oleelliset luokat eli <code>Kirja</code> ja <code>Kirjasto</code>. Luokka <code>Kirja</code> sisältää kirjaan liittyvät tiedot, luokka <code>Kirjasto</code> tarjoaa erilaisia hakutoiminnallisuuksia kirjoihin liittyen.
  </p>


  <h2>Kirja</h2>

  <p>
    Luodaan ensiksi luokka Kirja. Kirjalla on oliomuuttujina <code>nimeke</code>, eli kirjan nimi, <code>julkaisija</code>, eli kirjan julkaisija, ja <code>julkaisuvuosi</code> eli vuosi jolloin kirja on julkaistu. Kaksi ensimmäistä muuttujaa on merkkijonotyyppisiä, viimeisin on kokonaisluku. Oletamme tässä että kirjalla on aina vain yksi kirjoittaja.
  </p>

  <p>
    Toteuta luokka <code>Kirja</code>. Kirjalla tulee olla myös konstruktori <code>public Kirja(String niemeke, String julkaisija, int julkaisuvuosi)</code> sekä metodit <code>public String nimeke()</code>, <code>public String julkaisija()</code>, <code>public int julkaisuvuosi()</code> ja <code>public String toString()</code>. Arvannet mitä metodien tulee tehdä, alla esimerkki.
  </p>

  <p>
    Testaa luokan toimintaa:
  </p>

  <% partial 'partials/code_highlight' do %>
    Kirja cheese = new Kirja("Cheese Problems Solved", "Woodhead Publishing", 2007);
    System.out.println(cheese.nimeke());
    System.out.println(cheese.julkaisija());
    System.out.println(cheese.julkaisuvuosi());

    System.out.println(cheese);
  <% end %>

  <% partial 'partials/sample_output' do %>
    Cheese Problems Solved
    Woodhead Publishing
    2007
    Cheese Problems Solved, Woodhead Publishing, 2007
  <% end %>


  <h2>Kirjasto</h2>

  <p>
    Kirjaston tehtävä on antaa käyttäjälle mahdollisuus kirjojen lisäämiseen ja niiden hakemiseen. Luo luokka <code>Kirjasto</code>, jolla on konstruktori <code>public Kirjasto()</code> ja metodit <code>public void lisaaKirja(Kirja uusiKirja)</code> ja <code>public void tulostaKirjat()</code>
  </p>

  <% partial 'partials/code_highlight' do %>
    Kirjasto kirjasto = new Kirjasto();

    Kirja cheese = new Kirja("Cheese Problems Solved", "Woodhead Publishing", 2007);
    kirjasto.lisaaKirja(cheese);

    Kirja nhl = new Kirja("NHL Hockey", "Stanley Kupp", 1952);
    kirjasto.lisaaKirja(nhl);

    kirjasto.lisaaKirja(new Kirja("Battle Axes", "Tom A. Hawk", 1851));

    kirjasto.tulostaKirjat();
  <% end %>

  <% partial 'partials/sample_output' do %>
    Cheese Problems Solved, Woodhead Publishing, 2007
    NHL Hockey, Stanley Kupp, 1952
    Battle Axes, Tom A. Hawk, 1851
  <% end %>


  <h2>Hakutoiminnallisuus</h2>

  <p>
    Kirjastosta tulee pystyä etsimään kirjoja nimekkeiden ja julkaisijoiden perusteella. Lisää kirjastolle metodit <code>public ArrayList&lt;Kirja&gt; haeKirjaNimekkeella(String nimeke)</code>, <code>public ArrayList&lt;Kirja&gt; haeKirjaJulkaisijalla(String julkaisija)</code> ja <code>public ArrayList&lt;Kirja&gt; haeKirjaJulkaisuvuodella(int julkaisuvuosi)</code>. Metodit palauttavat listan kirjoista, joissa on haluttu nimeke, julkaisija tai julkaisuvuosi.
  </p>

  <p>
    Voit halutessasi hyödyntää seuraavaa runkoa metodin tekemiseen.
  </p>

  <% partial 'partials/code_highlight' do %>
    public class Kirjasto {
        // ...

        public ArrayList&lt;Kirja&gt; haeKirjaNimekkeella(String nimeke) {
            ArrayList&lt;Kirja&gt; loydetyt = new ArrayList&lt;&gt;();

            // käy läpi kaikki kirjat ja lisää ne joilla haetun kaltainen nimeke listalle loydetyt

            return loydetyt;
        }
    }
  <% end %>

  <p>
    Huom! Kun haet teet hakua merkkijonon avulla, älä tee tarkkaa hakua (metodi <code>equals</code>) vaan käytä <code>String</code>-luokan metodia <code>contains</code>. Huomaat todennäköisesti myös että sinulla on ns. copy-paste -koodia <code>Kirjasto</code>-luokan koodissa. Keksitkö tavan päästä siitä eroon?
  </p>

  <% partial 'partials/code_highlight' do %>
    Kirjasto kirjasto = new Kirjasto();

    kirjasto.lisaaKirja(new Kirja("Cheese Problems Solved", "Woodhead Publishing", 2007));
    kirjasto.lisaaKirja(new Kirja("The Stinky Cheese Man and Other Fairly Stupid Tales", "Penguin Group", 1992));
    kirjasto.lisaaKirja(new Kirja("NHL Hockey", "Stanley Kupp", 1952));
    kirjasto.lisaaKirja(new Kirja("Battle Axes", "Tom A. Hawk", 1851));

    for (Kirja kirja: kirjasto.haeKirjaNimekkeella("Cheese")) {
        System.out.println(kirja);
    }

    System.out.println("---");

    for (Kirja kirja: kirjasto.haeKirjaJulkaisijalla("Pong Group")) {
        System.out.println(kirja);
    }

    System.out.println("---");

    for (Kirja kirja: kirjasto.haeKirjaJulkaisuvuodella(1851)) {
        System.out.println(kirja);
    }
  <% end %>

  <% partial 'partials/sample_output' do %>
    Cheese Problems Solved, Woodhead Publishing, 2007
    The Stinky Cheese Man and Other Fairly Stupid Tales, Penguin Group, 1992
    ---
    ---
    Battle Axes, Tom A. Hawk, 1851
  <% end %>


  <h2>Paranneltu hakutoiminnallisuus</h2>

  <p>
    Hakutoiminnallisuutemme on jo hyvä, mutta se ei ymmärrä isojen ja pienten kirjainten eroa. Yllä olleessa esimerkissä haku nimekkeellä <code>"cheese"</code> ei olisi tuottanut yhtäkään tulosta. Myös toinen esimerkki, jossa oli ylimääräisiä välilyöntejä, ei näyttänyt haluttua tulosta. Haluamme että nimekkeiden ja julkaisijoiden nimillä haettaessa ei välitetä merkkien koosta, ja että käyttäjä voi syöttää ylimääräisiä välilyöntejä kirjan nimen alkuun tai loppuun (meidän ei tarvitse välittää sanojen välillä olevista tyhjistä!). Toteutetaan pieni apukirjasto <code>StringUtils</code> merkkijonojen vertailuun.
  </p>

  <p>
    Luo luokka <code>StringUtils</code>, ja lisää sille staattinen metodi <code>public static boolean sisaltaa(String sana, String haettava)</code>, joka tarkistaa sisältääkö merkkijono <code>sana</code> merkkijonon <code>haettava</code>. Jos jommankumman merkkijonon arvo on <em>null</em>, metodin tulee palauttaa arvo <code>false</code>. Metodin tarjoaman vertailun tulee olla välittämättä merkin koosta.
  </p>

  <p>
    Lisää metodille <code>sisaltaa</code> myös toiminnallisuus, joka poistaa merkkijonojen <code>sana</code> ja <code>haettava</code> alusta ja lopusta ylimääräiset välilyönnit. Käytä tähän <code>String</code>-luokan metodia <code>trim</code>, esim. <code>trimmattu = trimmattava.trim()</code>.
  </p>

  <p>
    Vinkki! <code>String</code>-luokan metodista <code>toUpperCase()</code> on hyötyä kun haluat verrata ovatko kaksi merkkijonoa samat -- riippumatta niiden alkuperäisestä merkkikoosta.
  </p>

  <p>
    Kun olet saanut metodin valmiiksi, käytä sitä <code>Kirjasto</code>-luokassa. Alla esimerkki:
  </p>

  <% partial 'partials/code_highlight' do %>
  if (StringUtils.sisaltaa(kirja.nimeke(), nimeke)) {
      // kirja löytyi!
  }
  <% end %>

  <% partial 'partials/code_highlight' do %>
  Kirjasto kirjasto = new Kirjasto();

  kirjasto.lisaaKirja(new Kirja("Cheese Problems Solved", "Woodhead Publishing", 2007));
  kirjasto.lisaaKirja(new Kirja("The Stinky Cheese Man and Other Fairly Stupid Tales", "Penguin Group", 1992));
  kirjasto.lisaaKirja(new Kirja("NHL Hockey", "Stanley Kupp", 1952));
  kirjasto.lisaaKirja(new Kirja("Battle Axes", "Tom A. Hawk", 1851));

  for (Kirja kirja: kirjasto.haeKirjaNimekkeella("CHEESE")) {
      System.out.println(kirja);
  }

  System.out.println("---");
  for (Kirja kirja: kirjasto.haeKirjaJulkaisijalla("PENGUIN  ")) {
      System.out.println(kirja);
  }
  <% end %>

  <% partial 'partials/sample_output' do %>
  Cheese Problems Solved, Woodhead Publishing, 2007
  The Stinky Cheese Man and Other Fairly Stupid Tales, Penguin Group, 1992
  ---
  The Stinky Cheese Man and Other Fairly Stupid Tales, Penguin Group, 1992
  <% end %>

<% end %>




<% partial 'partials/material_heading' do %>
  Hajautustaulu
<% end %>



<p>
  <a href="http://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html">Hajautustaulu</a> on eräs ohjelmoinnissa paljon käytetyistä tietorakenteista. Hajautustaulua käytetään kun halutaan käsitellä tietoa avain-arvo -pareina, missä avaimen perusteella voidaan lisätä, hakea ja poistaa avaimeen liittyvä arvo.
</p>

<p>
  Alla olevassa esimerkissä on luotu HashMap-olio kaupunkien hakemiseen postinumeron perusteella, jonka jälkeen HashMap-olioon on lisätty neljä postinumero-kaupunki -paria. Sekä postinumero että kaupunki on esitetty merkkijonona.
</p>

<% partial 'partials/code_highlight' do %>
  HashMap&lt;String, String&gt; postinumerot = new HashMap&lt;&gt;();
  postinumerot.put("00710", "Helsinki");
  postinumerot.put("90014", "Oulu");
  postinumerot.put("33720", "Tampere");
  postinumerot.put("33014", "Tampere");
<% end %>

<img src="/img/drawings/hashmap.png" alt="Hashmapissa avaimen perusteella saadaan selville arvo."/>

<p>
  Hajautustaulua luodessa tarvitaan kaksi tyyppiparametria, avainmuuttujan tyyppi ja lisättävän arvon tyyppi. Kuten yllä, myös seuraavassa esimerkissä sekä avainmuuttujan että lisättävän arvon tyyppi on String.
</p>

<% partial 'partials/code_highlight' do %>
  HashMap&lt;String, String&gt; numerot = new HashMap&lt;&gt;();
  numerot.put("Yksi", "Uno");
  numerot.put("Kaksi", "Dos");

  String kaannos = numerot.get("Yksi");
  System.out.println(kaannos);

  System.out.println(numerot.get("Kaksi"));
  System.out.println(numerot.get("Kolme"));
  System.out.println(numerot.get("Uno"));
<% end %>

<% partial 'partials/sample_output' do %>
  Uno
  Dos
  null
  null
<% end %>


<p>
  Yllä olevassa esimerkissä luodaan hajatustaulu, jonka avaimena ja tallennettavana oliona on merkkijono. Hajautustauluun lisätään tietoa kaksiparametrisella metodilla <code>put</code>, jolle annetaan parametrina sekä avain- että arvomuuttuja.
</p>

<p>
  Yksiparametrinen metodi <code>get</code> palauttaa parametrina annettuun avaimeen liittyvän viitteen tai <code>null</code>-viitteen jos avaimella ei löydy viitettä.
</p>


<%= partial 'partials/quiz', locals: { id: '59da5a594538e90004e0f0e7' } %>


<p>
  Hajautustaulussa on jokaista avainta kohden korkeintaan yksi arvo. Jos hajautustauluun lisätään uusi avain-arvo -pari, missä avain on jo aiemmin liittynyt toiseen hajautustauluun tallennettuun arvoon, vanha arvo katoaa hajautustaulusta.
</p>

<% partial 'partials/code_highlight' do %>
  HashMap&lt;String, String&gt; numerot = new HashMap&lt;&gt;();
  numerot.put("Uno", "Yksi");
  numerot.put("Dos", "Zwei");
  numerot.put("Uno", "Ein");

  String kaannos = numerot.get("Uno");
  System.out.println(kaannos);

  System.out.println(numerot.get("Dos"));
  System.out.println(numerot.get("Tres"));
  System.out.println(numerot.get("Uno"));
<% end %>

<% partial 'partials/sample_output' do %>
  Ein
  Zwei
  null
  Ein
<% end %>


<% partial 'partials/exercise', locals: { name: 'Lempinimet' } do %>

  <p>
    Luo <code>main</code>-metodissa uusi <code>HashMap&lt;String,String&gt;</code>-olio. Tallenna luomaasi olioon seuraavien henkilöiden nimet ja lempinimet niin, että nimi on avain ja lempinimi on arvo. Käytä pelkkiä pieniä kirjaimia.
  </p>

  <ul>
    <li>matin lempinimi on mage</li>
    <li>mikaelin lempinimi on mixu</li>
    <li>arton lempinimi on arppa</li>
  </ul>

  <p>
    Tämän jälkeen hae HashMapistä mikaelin lempinimi ja tulosta se.
  </p>

  <p>
    Testit edellyttävät että kirjoitat nimet pienellä alkukirjaimella.
  </p>

<% end %>


<% partial 'partials/material_sub_heading' do %>
  Viittaustyyppinen muuttuja hajautustaulussa
<% end %>

<p>
  Tutkitaan hajautustaulun toimintaa kirjastoesimerkin avulla. Kirjastosta voi hakea kirjoja kirjan nimen perusteella. Jos haetulla nimellä löytyy kirja, palauttaa kirjasto kirjan viitteen. Luodaan ensin esimerkkiluokka <code>Kirja</code>, jolla on oliomuuttujina nimi, kirjaan liittyvä sisältö sekä kirjan julkaisuvuosi.
</p>

<% partial 'partials/code_highlight' do %>
  public class Kirja {
      private String nimi;
      private String sisalto;
      private int julkaisuvuosi;

      public Kirja(String nimi, int julkaisuvuosi, String sisalto) {
          this.nimi = nimi;
          this.julkaisuvuosi = julkaisuvuosi;
          this.sisalto = sisalto;
      }

      public String getNimi() {
          return this.nimi;
      }

      public void setNimi(String nimi) {
          this.nimi = nimi;
      }

      public int getJulkaisuvuosi() {
          return this.julkaisuvuosi;
      }

      public void setJulkaisuvuosi(int julkaisuvuosi) {
          this.julkaisuvuosi = julkaisuvuosi;
      }

      public String getSisalto() {
          return this.sisalto;
      }

      public void setSisalto(String sisalto) {
          this.sisalto = sisalto;
      }

      public String toString() {
          return "Nimi: " + this.nimi + " (" + this.julkaisuvuosi + ")\n"
              + "Sisältö: " + this.sisalto;
      }
  }
<% end %>

<p>
  Luodaan seuraavaksi hajautustaulu, joka käyttää avaimena kirjan nimeä eli String-tyyppistä oliota, ja arvona edellä luomaamme kirjaa.
</p>

<% partial 'partials/code_highlight' do %>
  HashMap&lt;String, Kirja&gt; hakemisto = new HashMap&lt;&gt;();
<% end %>

<p>
  Yllä oleva hajautustaulu käyttää avaimena <code>String</code>-oliota. Laajennetaan esimerkkiä siten, että hakemistoon lisätään kaksi kirjaa, <code>"Järki ja tunteet"</code> ja <code>"Ylpeys ja ennakkoluulo"</code>.
</p>

<% partial 'partials/code_highlight' do %>
  Kirja jarkiJaTunteet = new Kirja("Järki ja tunteet", 1811, "...");
  Kirja ylpeysJaEnnakkoluulo = new Kirja("Ylpeys ja ennakkoluulo", 1813, "....");

  HashMap&lt;String, Kirja&gt; hakemisto = new HashMap&lt;&gt;();
  hakemisto.put(jarkiJaTunteet.getNimi(), jarkiJaTunteet);
  hakemisto.put(ylpeysJaEnnakkoluulo.getNimi(), ylpeysJaEnnakkoluulo);
<% end %>

<p>
  Hakemistosta voi hakea kirjoja kirjan nimellä. Haku kirjalla <code>"Viisasteleva sydän"</code> ei tuota osumaa, jolloin hajautustaulu palauttaa <code>null</code>-viitteen. Kirja "Ylpeys ja ennakkoluulo" kuitenkin löytyy.
</p>

<% partial 'partials/code_highlight' do %>
  Kirja kirja = hakemisto.get("Viisasteleva sydän");
  System.out.println(kirja);
  System.out.println();
  kirja = hakemisto.get("Ylpeys ja ennakkoluulo");
  System.out.println(kirja);
<% end %>

<% partial 'partials/sample_output' do %>
  null

  Nimi: Ylpeys ja ennakkoluulo (1813)
  Sisältö: ...
<% end %>

<p>
  Hajautustauluun lisättäessä avain-arvo -parin arvo voi olla käytännössä mitä tahansa. Arvo voi olla kokonaisluku, lista, tai vaikkapa toinen hajautustaulu.
</p>

<%= partial 'partials/quiz', locals: { id: '59da5b104538e90004e0f0e8' } %>


<% partial 'partials/material_sub_heading' do %>
  Hajautustaulu oliomuuttujana
<% end %>

<p>
  Edellä kuvatun esimerkin ongelma on se, että kirjan kirjoitusmuoto tulee muistaa täsmälleen oikein. Joku saattaa etsiä kirjaa pienellä alkukirjaimella ja joku toinen saattaa vaikkapa painaa välilyöntiä nimen kirjoituksen aluksi. Tarkastellaan seuraavaksi erästä tapaa hieman sallivampaan kirjan nimen perusteella tapahtuvaan hakemiseen.
</p>

<p>
  Hyödynnämme hakemisessa String-luokan tarjoamia välineitä merkkijonojen käsittelyyn. Metodi <code>toLowerCase()</code> luo merkkijonosta uuden merkkijonon, jonka kaikki kirjaimet on muunnettu pieniksi. Metodi <code>trim()</code> taas luo merkkijonosta uuden merkkijonon, jonka alusta ja lopusta on poistettu tyhjät merkit kuten välilyönnit.
</p>

<% partial 'partials/code_highlight' do %>
  String teksti = "Ylpeys ja ennakkoluulo ";
  teksti = teksti.toLowerCase(); // teksti nyt "ylpeys ja ennakkoluulo "
  teksti = teksti.trim(); // teksti nyt "ylpeys ja ennakkoluulo"
<% end %>

<p>
  Jos mietit "<em>kuka kirjoittaisi välilyöntejä ja miksi?</em>", etsi ja lue kirja <a href="https://en.wikipedia.org/wiki/Ender's_Game" target="_blank" rel="noopener">Ender's Game</a> (suom. Ender).
</p>

<p>
  Luodaan luokka <code>Kirjasto</code>, joka kapseloi kirjat sisältävän hajautustaulun ja mahdollistaa kirjoitusasusta riippumattoman kirjojen haun. Lisätään luokalle <code>Kirjasto</code> metodit lisäämiseen, hakemiseen ja poistamiseen. Jokainen näistä tapahtuu siistityn nimen perusteella -- siistiminen sisältää nimen muuntamisen pienellä kirjoitetuksi sekä ylimääräisten alussa ja lopussa olevien välilyöntien poistamisen.
</p>

<p>
  Huomaamme jo nyt että merkkijonon siistimiseen liittyvää koodia tarvitsisi jokaisessa kirjaa käsittelevässä metodissa, joten siitä on hyvä tehdä erillinen metodi.
</p>

<% partial 'partials/code_highlight' do %>
  public class Kirjasto {
      private HashMap&lt;String, Kirja&gt; hakemisto;

      public Kirjasto() {
          this.hakemisto = new HashMap&lt;&gt;();
      }

      public void lisaaKirja(Kirja kirja) {
          String nimi = siistiMerkkijono(kirja.getNimi());

          if (this.hakemisto.containsKey(nimi)) {
              System.out.println("Kirja on jo kirjastossa!");
          } else {
              hakemisto.put(nimi, kirja);
          }
      }

      public Kirja haeKirja(String kirjanNimi) {
          kirjanNimi = siistiMerkkijono(kirjanNimi);
          return this.hakemisto.get(kirjanNimi);
      }

      public void poistaKirja(String kirjanNimi) {
          kirjanNimi = siistiMerkkijono(kirjanNimi);

          if (this.hakemisto.containsKey(kirjanNimi)) {
              this.hakemisto.remove(kirjanNimi);
          } else {
              System.out.println("Kirjaa ei löydy, ei voida poistaa!");
          }
      }

      public String siistiMerkkijono(String merkkijono) {
          if (merkkijono == null) {
              return "";
          }

          merkkijono = merkkijono.toLowerCase();
          return merkkijono.trim();
      }
  }
<% end %>

<p>
  Yllä käytetään hajautustaulun tarjoamaa metodia <code>containsKey</code> avaimen olemassaolon tarkastamiseen. Metodi palauttaa arvon <code>true</code>, jos hajautustauluun on lisätty haetulla avaimella mikä tahansa arvo, muulloin metodi palauttaa arvon <code>false</code>.
</p>

<p>
  Edeltävässä esimerkissä noudatimme ns. DRY-periaatetta (Don't Repeat Yourself), jonka tarkoituksena on saman koodin toistumisen välttäminen. Merkkijonon siistiminen eli pienellä kirjoitetuksi muuttaminen sekä <em>trimmaus</em>, eli tyhjien merkkien poisto alusta ja lopusta, olisi toistunut useasti kirjastoluokassamme ilman metodia <code>siistiMerkkijono</code>. Toistuvaa koodia ei usein huomaa ennen kuin sitä on jo kirjoittanut, jolloin sitä päätyy koodiin lähes pakosti. Tässä ei ole mitään pahaa -- tärkeintä on että koodia siistitään sitä mukaa siistimistä vaativia tilanteita huomataan.
</p>

<% partial 'partials/material_sub_heading' do %>
  Hajautustaulun avainten läpikäynti
<% end %>

<p>
  Haluamme joskus etsiä kirjaa nimen osan perusteella. Hajautustaulun metodi <code>get</code> ei tähän sovellu, sillä sitä käytetään tietyllä avaimella etsimiseen. Kirjan nimen osan perusteella etsiminen ei sillä onnistu.
</p>

<p>
  Hajautustaulun arvojen läpikäynti hajautustaulun metodin <code>keySet()</code> palauttaman joukon avulla. Metodi <code>keySet()</code> palauttaa hajautustaulussa olevat avaimet tietokokoelmana, jonka voi käsitellä yksitellen for-each -lauseella.
</p>

<p>
  Tarkastellaan tätä kirjastoesimerkin kautta.
</p>

<p>
  Alla haetaan kaikki ne kirjat, joiden nimessä esiintyy annettu merkkijono.
</p>

<% partial 'partials/code_highlight' do %>
  public ArrayList&lt;Kirja&gt; haeKirjaNimenOsalla(String nimenOsa) {
      nimenOsa = siistiMerkkijono(nimenOsa);

      ArrayList&lt;Kirja&gt; kirjat = new ArrayList&lt;&gt;();

      for(String kirjanNimi : this.hakemisto.keySet()) {
          if(!kirjanNimi.contains(nimenOsa)) {
              continue;
          }

          // mikäli avain sisältää haetun merkkijonon, haetaan avaimeen
          // liittyvä arvo ja lisätään se palautettavien kirjojen joukkoon
          kirjat.add(this.hakemisto.get(kirjanNimi));
      }

      return kirjat;
  }
<% end %>

<p>
  Tällä tavalla etsiessä menetämme kuitenkin hajautustauluun liittyvän nopeusedun. Hajautustaulu on toteutettu siten, että yksittäisen avaimen perusteella hakeminen on erittäin nopeaa. Yllä olevassa esimerkissä käydään kaikkien kirjojen nimet läpi, kun tietyllä avaimella etsittäessä tarkasteltaisiin tasan yhden kirjan olemassaoloa.
</p>

<% partial 'partials/material_sub_heading' do %>
  Hajautustaulun arvojen läpikäynti
<% end %>

<p>
  Edellä kuvatun toiminnallisuuden voisi toteuttaa myös hajautustaulun arvojen läpikäynnillä. Hajautustaulu arvojoukon saa hajautustaulun metodilla <code>values()</code>. Myös tämän arvojoukon voi käydä läpi for-each -lauseella.
</p>


<% partial 'partials/code_highlight' do %>
  public ArrayList&lt;Kirja&gt; haeKirjaNimenOsalla(String nimenOsa) {
      nimenOsa = siistiMerkkijono(nimenOsa);

      ArrayList&lt;Kirja&gt; kirjat = new ArrayList&lt;&gt;();

      for(Kirja kirja : this.hakemisto.values()) {
          if(!kirja.getNimi().contains(nimenOsa)) {
              continue;
          }

          kirjat.add(kirja);
      }

      return kirjat;
  }
<% end %>

<p>
  Kuten edellisessä esimerkissä, myös tällä tavalla etsiessä menetetään hajautustauluun liittyvä nopeusedun.
</p>


<% partial 'partials/material_sub_heading' do %>
  Alkeistyyppiset muuttujat hajautustaulussa
<% end %>

<p>
  Hajautustaulu olettaa, että siihen lisätään viittaustyyppisiä muuttujia (samoin kuin ArrayList). Java muuntaa alkeistyyppiset muuttujat viittaustyyppisiksi käytännössä kaikkia Javan valmiita tietorakenteita (kuten ArrayList ja HashMap) käytettäessä. Vaikka luku <code>1</code> voidaan esittää alkeistyyppisen muuttujan <code>int</code> arvona, tulee sen tyypiksi määritellä <code>Integer</code> ArrayListissä ja HashMapissa.
</p>


<% partial 'partials/code_highlight' do %>
  HashMap&lt;Integer, String&gt; taulu = new HashMap&lt;&gt;(); // toimii
  taulu.put(1, "Ole!");
  HashMap&lt;int, String&gt; taulu2 = new HashMap&lt;&gt;(); // ei toimi
<% end %>

<p>
  Hajautustaulun avain ja tallennettava olio ovat aina viittaustyyppisiä muuttujia. Jos haluat käyttää alkeistyyppisiä muuttujia avaimena tai tallennettavana arvona, on niille olemassa viittaustyyppiset vastineet. Alla on esitelty muutama.
</p>

<table class="table">

  <tr>
    <th>Alkeistyyppi</th>
    <th>Viittaustyyppinen vastine</th>
  </tr>

  <tr>
    <td>int</td>
    <td><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html" target="_blank" rel="noopener">Integer</a>
    </td>
  </tr>

  <tr>
    <td>double</td>
    <td><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Double.html" target="_blank" rel="noopener">Double</a></td>
  </tr>

  <tr>
    <td>char</td>
    <td><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Character.html" target="_blank" rel="noopener">Character</a></td>
  </tr>
</table>


<p>
  Java muuntaa alkeistyyppiset muuttujat automaattisesti viittaustyyppisiksi kun niitä lisätään HashMapiin tai ArrayListiin. Tätä automaattista muunnosta viittaustyyppisiksi kutsutaan Javassa <em>auto-boxingiksi</em>, eli automaattiseksi "laatikkoon" asettamiseksi. Automaattinen muunnos onnistuu myös toiseen suuntaan.
</p>

<% partial 'partials/code_highlight' do %>
  int avain = 2;
  HashMap&lt;Integer, Integer&gt; taulu = new HashMap&lt;&gt;();
  taulu.put(avain, 10);
  int arvo = taulu.get(avain);
  System.out.println(arvo);
<% end %>

<% partial 'partials/sample_output' do %>
  10
<% end %>

<p>
  Seuraava esimerkki kuvaa rekisterinumeroiden bongausten laskemiseen käytettävää luokkaa. Metodeissa metodeissa <code>lisaaBongaus</code> ja <code>montakoKertaaBongattu</code> tapahtuu automaattinen tyyppimuunnos.
</p>


<% partial 'partials/code_highlight' do %>
  public class Rekisteribongauslaskuri {
      private HashMap&lt;String, Integer&gt; bongatut;

      public Rekisteribongauslaskuri() {
          this.bongatut = new HashMap&lt;&gt;();
      }

      public void lisaaBongaus(String bongattu) {
          if (!this.bongatut.containsKey(bongattu)) {
              this.bongatut.put(bongattu, 0);
          }

          int montakobongausta = this.bongatut.get(bongattu);
          montakobongausta++;
          this.bongatut.put(bongattu, montakobongausta);
      }

      public int montakoKertaaBongattu(String bongattu) {
          this.bongatut.get(bongattu);
      }
  }
<% end %>

<p>
  Tyyppimuunnoksissa piilee kuitenkin vaara. Jos yritämme muuntaa null-viitettä -- eli esimerkiksi bongausta, jota ei ole HashMapissa -- kokonaisluvuksi, näemme virheen <em>java.lang.reflect.InvocationTargetException</em>. Kun teemme automaattista muunnosta, tulee varmistaa että muunnettava arvo ei ole null. Yllä olevassa ohjelmassa oleva <code>montakoKertaaBongattu</code>-metodi tulee korjata esimerkiksi seuraavasti.
</p>


<% partial 'partials/code_highlight' do %>
  public int montakoKertaaBongattu(String bongattu) {
      return this.bongatut.getOrDefault(bongattu, 0);
  }
<% end %>

<p>
  HashMapin metodi <code>getOrDefault</code> hakee sille ensimmäisenä parametrina annettua avainta HashMapista. Jos avainta ei löydy, palauttaa se toisena parametrina annetun arvon. Metodin toiminta vastaa seuraavaa metodia.
</p>

<% partial 'partials/code_highlight' do %>
  public int montakoKertaaBongattu(String bongattu) {
      if (this.bongatut.containsKey(bongattu) {
          return this.bongatut.get(bongattu);
      }

      return 0;
  }
<% end %>

<p>
  Siistitään vielä lisaaBongaus-metodia hieman. Alkuperäisessä versiossa metodin alussa lisätään hajautustauluun bongausten lukumääräksi arvo 0, jos bongattua ei löydy. Tämän jälkeen bongausten määrä haetaan, sitä kasvatetaan yhdellä, ja vanha bongausten lukumäärä korvataan lisäämällä arvo uudestaan hajautustauluun. Osan tästäkin toiminnallisuudesta voi korvata metodilla getOrDefault.
</p>


<% partial 'partials/code_highlight' do %>
  public class Rekisteribongauslaskuri {
      private HashMap&lt;String, Integer&gt; bongatut;

      public Rekisteribongauslaskuri() {
          this.bongatut = new HashMap&lt;&gt;();
      }

      public void lisaaBongaus(String bongattu) {
          int montakobongausta = this.bongatut.getOrDefault(bongattu, 0);
          montakobongausta++;
          this.bongatut.put(bongattu, montakobongausta);
      }

      public int montakoKertaaBongattu(String bongattu) {
          return this.bongatut.getOrDefault(bongattu, 0);
      }
  }
<% end %>



<% partial 'partials/exercise', locals: { name: 'Velkakirja' } do %>

  <p>
    Luo luokka <code>Velkakirja</code>, jolla on seuraavat toiminnot:
  </p>

  <ul>
    <li>konstruktori <code>public Velkakirja()</code> luo uuden velkakirjan</li>
    <li>metodi <code>public void asetaLaina(String kenelle, double maara)</code> tallettaa velkakirjaan merkinnän lainasta tietylle henkilölle.</li>
    <li>metodi <code>public double paljonkoVelkaa(String kuka)</code> palauttaa velan määrän annetun henkilön nimen perusteella. Jos henkilöä ei löydy, palautetaan 0.</li>
  </ul>

  <p>Luokkaa käytetään seuraavalla tavalla:</p>

  <% partial 'partials/code_highlight' do %>
    Velkakirja matinVelkakirja = new Velkakirja();
    matinVelkakirja.asetaLaina("Arto", 51.5);
    matinVelkakirja.asetaLaina("Mikael", 30);

    System.out.println(matinVelkakirja.paljonkoVelkaa("Arto"));
    System.out.println(matinVelkakirja.paljonkoVelkaa("Joel"));
  <% end %>

  <p>Yllä oleva esimerkki tulostaisi:</p>

  <% partial 'partials/sample_output' do %>
    51.5
    0.0
  <% end %>

  <p>
    Ole tarkkana tilanteessa, jossa kysytään velattoman ihmisen velkaa.
  </p>

  <p>
    Huom! Velkakirjan ei tarvitse huomioida vanhoja lainoja. Kun asetat uuden velan henkilölle jolla on vanha velka, vanha velka unohtuu.
  </p>

  <% partial 'partials/code_highlight' do %>
    Velkakirja matinVelkakirja = new Velkakirja();
    matinVelkakirja.asetaLaina("Arto", 51.5);
    matinVelkakirja.asetaLaina("Arto", 10.5);

    System.out.println(matinVelkakirja.paljonkoVelkaa("Arto"));
  <% end %>

  <% partial 'partials/sample_output' do %>
    10.5
  <% end %>

<% end %>


<% partial 'partials/material_heading' do %>
  CrowdSorcerer ja HashMap
<% end %>

<p>
  Tässä kohtaa kertaat hajautustauluja ja pääset taas pohtimaan tehtävää tulevia sukupolvia varten. Jos et ole CrowdSorcereria aiemmin, käy katsomassa CrowdSorcererin opasvideo toisen osan materiaalista.
</p>


<% partial 'partials/general_callout', locals: { name: 'Suunnittele oma tehtävä: HashMap' } do %>

  <p>
    Keksi tehtävä, jossa käytetään HashMappia. Tehtäväpohjassa on valmiina komennon kysyminen ja toistolause, joka jatkuu kunnes ohjelman käyttäjä kirjoittaa komennon "lopeta".
  </p>

  <p>
    <b>Huom!</b> Tässä sinun täytyy syöttää jokaiselle testitapaukselle useampi syöte. Useamman syötteen saat annettua, kun laitat rivinvaihdon <code>\n</code> jokaisen syötteen väliin. Lisäksi lopeta jokainen testisyöte tekstillä <code>lopeta</code>, jotta testissä silmukan suoritus lakkaa.
  </p>

  <p>
    Esimerkiksi jos haluat antaa testisyötteeksi "kissa", "koira", "lopeta", syötä input-kenttään teksti <code>kissa\nkoira\nlopeta</code>.
  </p>

  <p>
    Muista merkitä malliratkaisurivit ohjelmaan -- näin ratkaisu ei tule suoraan käyttäjälle näkyvään.
  </p>

<% end %>


<div class='crowdsorcerer-widget' data-assignment='8'></div>




<% partial 'partials/material_heading' do %>
  Oliot olioiden sisällä
<% end %>


<% partial 'partials/material_heading' do %>
  Oliot ja viitteet
<% end %>


<p>
  Jatketaan nyt olioiden ja viitteiden parissa. Oletetaan, että käytössämme on alla oleva luokka.
</p>

<% partial 'partials/code_highlight' do %>
  public class Henkilo {

      private String nimi;
      private int ika;
      private int paino;
      private int pituus;

      public Henkilo(String nimi) {
          this.nimi = nimi;
          this.ika = 0;
          this.paino = 0;
          this.pituus = 0;
      }

      // muita konstruktoreja ja metodeja
  
      public String getNimi() {
          return this.nimi;
      }
  
      public int getIka() {
          return this.ika;
      }
  
      public void vanhene() {
          this.ika++;
      }
  
      public void setPituus(int uusiPituus) {
          this.pituus = uusiPituus;
      }
  
      public void setPaino(int uusiPaino) {
          this.paino = uusiPaino;
      }
  
      public double painoIndeksi() {
          double pituusPerSata = this.pituus / 100.0;
          return this.paino / (pituusPerSata * pituusPerSata);
      }
  
      @Override
      public String toString() {
          return this.nimi + ", ikä " + this.ika + " vuotta";
      }
  }
<% end %>

<p>
  Mitä oikein tapahtuu kun olio luodaan?
</p>


<% partial 'partials/code_highlight' do %>
  Henkilo joan = new Henkilo("Joan Ball");
<% end %>

<p>
  Konstruktorikutsun <code>new</code> yhteydessä tapahtuu monta asiaa. Ensin tietokoneen muistista varataan tila oliomuuttujille. Tämän jälkeen oliomuuttujiin asetetaan oletus- tai alkuarvot (esimerkiksi int-tyyppisten muuttujien arvoksi tulee 0). Lopulta suoritetaan konstruktorissa oleva lähdekoodi.
</p>

<p>
  Konstruktorikutsu palauttaa viitteen olioon. <strong>Viite</strong> on tieto olioon liittyvien tietojen paikasta.
</p>

<img src="/img/drawings/olio-joan.png"/>

<p>
  Muuttujan arvoksi asetetaan siis viite, eli tieto olioon liittyvien tietojen paikasta. Yllä oleva kuva paljastaa myös sen, että nimi -- tai tarkemmin merkkijonot -- ovat myös olioita.
</p>

<% partial 'partials/material_sub_heading' do %>
  Muuttujan arvon asettaminen kopioi viitteen
<% end %>


<p>
  Lisätään ohjelmaan <code>Henkilo</code>-tyyppinen muuttuja <code>ball</code> ja annetaan sille alkuarvoksi <code>joan</code>. Mitä nyt tapahtuu?
</p>

<% partial 'partials/code_highlight' do %>
  Henkilo joan = new Henkilo("Joan Ball");
  System.out.println(joan);

  Henkilo ball = joan;
<% end %>

<p>
  Lause <code>Henkilo ball = joan;</code> luo uuden henkilömuuttujan, jonka arvoksi kopioidaan muuttujan <code>joan</code> arvo. Tämä saa aikaan sen, että <code>ball</code> viittaa samaan olioon kuin <code>joan</code>.
</p>

<img src="/img/drawings/olio-joan-ja-ball.png"/>

<p>
  Tarkastellan samaa esimerkkiä hieman pidemmälle.
</p>

<% partial 'partials/code_highlight' do %>
  Henkilo joan = new Henkilo("Joan Ball");
  System.out.println(joan);

  Henkilo ball = joan;
  ball.vanhene();
  ball.vanhene();

  System.out.println(joan);
<% end %>

<% partial 'partials/sample_output' do %>
  Joan Ball, ikä 0 vuotta
  Joan Ball, ikä 2 vuotta
<% end %>


<p>
  Joan Ball -- eli henkilöolio, johon viite muuttujassa <code>joan</code> osoittaa -- on alussa 0-vuotias. Tämän jälkeen muuttujaan <code>ball</code> asetetaan (eli kopioidaan) muuttujan <code>joan</code> arvo. Henkilöoliota <code>ball</code> vanhennetaan kaksi vuotta ja sen seurauksena Joan Ball vanhenee!
</p>

<p>
  Olion sisäinen tila ei kopioidu muuttujan arvoa asetettaessa. Lauseessa <code>Henkilo ball = joan;</code> ei siis luoda henkilöä -- muuttujan ball arvoksi asetetaan kopio muuttujan joan arvosta, eli viite olioon.
</p>

<img src="/img/drawings/olio-joan-ja-ball-2.png"/>

<p>
  Seuraavassa esimerkkiä on jatkettu siten, että <code>joan</code>-muuttujaa varten luodaan uusi olio, jonka viite asetetaan muuttujan arvoksi. Muuttuja <code>ball</code> viittaa yhä aiemmin luotuun olioon.
</p>

<% partial 'partials/code_highlight' do %>
  Henkilo joan = new Henkilo("Joan Ball");
  System.out.println(joan);

  Henkilo ball = joan;
  ball.vanhene();
  ball.vanhene();

  System.out.println(joan);

  joan = new Henkilo("Joan B.");
  System.out.println(joan);
<% end %>

<p>
  Tulostuu:
</p>

<% partial 'partials/sample_output' do %>
  Joan Ball, ikä 0 vuotta
  Joan Ball, ikä 2 vuotta
  Joan B., ikä 0 vuotta
<% end %>

<p>
  Muuttujassa <code>joan</code> on siis alussa viite yhteen olioon, mutta lopussa sen arvoksi on kopioitu toisen muuttujan viite. Seuraavassa kuva tilanteesta viimeisen koodirivin jälkeen.
</p>

<img src="/img/drawings/olio-joan-ja-ball-3.png"/>


<% partial 'partials/material_sub_heading' do %>
  Muuttujan arvo <code>null</code>
<% end %>


<p>
  Jatketaan vielä esimerkkiä asettamalla muuttujan <code>ball</code> arvoksi <code>null</code>, eli viite "ei mihinkään".
</p>

<% partial 'partials/code_highlight' do %>
  Henkilo joan = new Henkilo("Joan Ball");
  System.out.println(joan);

  Henkilo ball = joan;
  ball.vanhene();
  ball.vanhene();

  System.out.println(joan);

  joan = new Henkilo("Joan B.");
  System.out.println(joan);

  ball = null;
<% end %>

<p>
  Viimeisen rivin jälkeen ohjelman tila on seuraavanlainen.
</p>

<img src="/img/drawings/olio-joan-ja-ball-null.png"/>

<p>
  Olioon, jonka nimi on Joan Ball, ei enää viittaa kukaan. Oliosta on siis tullut "roska". Java-ohjelmointikielessä ohjelmoijan ei tarvitse huolehtia ohjelman käyttämästä muistista. Javan automaattinen roskienkerääjä käy siivoamassa roskaksi joutuneet oliot aika ajoin. Jos automaattista roskien keruuta ei tapahtuisi, jäisivät roskaksi joutuneet oliot varaamaan muistia ohjelman suorituksen loppuun asti.
</p>

<p>
  Kokeillaan vielä mitä käy kun yritämme tulostaa muuttujaa, jonka arvona on viite "ei mihinkään" eli <code>null</code>.
</p>

<% partial 'partials/code_highlight' do %>
  Henkilo joan = new Henkilo("Joan Ball");
  System.out.println(joan);

  Henkilo ball = joan;
  ball.vanhene();
  ball.vanhene();

  System.out.println(joan);

  joan = new Henkilo("Joan B.");
  System.out.println(joan);

  ball = null;
  System.out.println(ball);
<% end %>


<% partial 'partials/sample_output' do %>
  Joan Ball, ikä 0 vuotta
  Joan Ball, ikä 2 vuotta
  Joan B., ikä 0 vuotta
  null
<% end %>

<p>
  Viitteen <code>null</code> tulostus tulostaa "null". Entäpä jos yritämme kutsua ei mihinkään viittaavan olion metodia, esimerkiksi metodia <code>vanhene</code>:
</p>

<% partial 'partials/code_highlight' do %>
  Henkilo joan = new Henkilo("Joan Ball");
  System.out.println(joan);

  joan = null;
  joan.vanhene();
<% end %>


<p>
  Tulos:
</p>

<% partial 'partials/sample_output' do %>
  Joan Ball, ikä 0 vuotta
  <font color="red">Exception in thread "main" java.lang.NullPointerException
    at Main.main(Main.java:(rivi))
    Java Result: 1</font>
<% end %>

<p>
  Käy huonosti. Tämä on ehkä ensimmäinen kerta kun näet tekstin <strong>NullPointerException</strong>. Ohjelmassa tapahtuu virhe, joka liittyy siihen, että olemme kutsuneet ei mihinkään viittaavan muuttujan metodia.
</p>

<p>
  Voimme luvata, että tulet näkemään edellisen virheen vielä uudelleen. Tällöin ensimmäinen askel on etsiä muuttujia, joiden arvona saattaisi olla <code>null</code>. Virheilmoitus on onneksi myös hyödyllinen: se kertoo millä rivillä virhe tapahtuu. Kokeile vaikka itse!
</p>


<% partial 'partials/exercise', locals: { name: 'NullPointerException' } do %>

  <p>
    Toteuta ohjelma, jonka suorittaminen aiheuttaa virheen NullPointerException. Virheen tulee tapahtua heti kun ohjelma suoritetaan -- älä siis esimerkiksi lue käyttäjältä syötettä.
  </p>

<% end %>

<p>&nbsp;</p>

<% partial 'partials/material_sub_heading' do %>
  Olio oliomuuttujana
<% end %>


<p>
  Oliot voivat sisältää viitteitä olioihin.
</p>

<p>
  Jatketaan <code>Henkilo</code>-luokan parissa ja lisätään henkilölle syntymäpäivä. Syntymäpäivä on luonnollista esittää <code>Paivays</code>-olion avulla:
</p>


<% partial 'partials/code_highlight' do %>
  public class Paivays {
      private int paiva;
      private int kuukausi;
      private int vuosi;

      public Paivays(int paiva, int kuukausi, int vuosi) {
          this.paiva = paiva;
          this.kuukausi = kuukausi;
          this.vuosi = vuosi;
      }

      public int getPaiva() {
          return this.paiva;
      }

      public int getKuukausi() {
          return this.kuukausi;
      }

      public int getVuosi() {
          return this.vuosi;
      }

      @Override
      public String toString() {
          return this.paiva + "." + this.kuukausi + "." + this.vuosi;
      }
  }
<% end %>

<p>
  Koska tiedämme syntymäpäivän, henkilön ikää ei enää tarvitse säilöä. Se on pääteltävissä syntymäpäivästä.
</p>

<% partial 'partials/code_highlight' do %>
  public class Henkilo {
      private String nimi;
      private Paivays syntymaPaiva;
      private int paino = 0;
      private int pituus = 0;

  // ...
<% end %>

<p>
  Tehdään henkilölle uusi konstruktori, joka mahdollistaa syntymäpäivän asettamisen:
</p>

<% partial 'partials/code_highlight' do %>
  public Henkilo(String nimi, int paiva, int kuukausi, int vuosi) {
      this.nimi = nimi;
      this.syntymaPaiva = new Paivays(paiva, kuukausi, vuosi);
      this.paino = 0;
      this.pituus = 0;
  }
<% end %>


<p>
  Konstruktorin parametrina annetaan erikseen päiväyksen osat (päivä, kuukausi, vuosi), niistä luodaan päiväysolio, ja lopulta päiväysolion viite kopioidaan oliomuuttujan <code>syntymaPaiva</code> arvoksi.
</p>

<p>
  Muokataan Henkilo-luokassa olevaa <code>toString</code>-metodia siten, että metodi palauttaa iän sijaan syntymäpäivän:
</p>

<% partial 'partials/code_highlight' do %>
  public String toString() {
      return this.nimi + ", syntynyt " + this.syntymaPaiva;
  }
<% end %>

<p>
  Kokeillaan miten uusittu Henkilöluokka toimii.
</p>

<% partial 'partials/code_highlight' do %>
  Henkilo muhammad = new Henkilo("Muhammad ibn Musa al-Khwarizmi", 1, 1, 780);
  Henkilo pascal = new Henkilo("Blaise Pascal", 19, 6, 1623);

  System.out.println(muhammad);
  System.out.println(pascal);
<% end %>


<% partial 'partials/sample_output' do %>
  Muhammad ibn Musa al-Khwarizmi, syntynyt 1.1.870
  Blaise Pascal, syntynyt 19.6.1623
<% end %>


<p>
  Henkilöoliolla on nyt oliomuuttujat <code>nimi</code> ja <code>syntymaPaiva</code>. Muuttuja <code>nimi</code> on merkkijono, joka sekin on siis olio, ja muuttuja <code>syntymaPaiva</code> on Päiväysolio.
</p>

<p>
  Molemmat muuttujat sisältävät arvon olioon. Henkilöolio sisältää siis kaksi viitettä.
</p>


<img src="/img/drawings/muhammad-ja-pascal.png"/>

<p>&nbsp;</p>

<p>
  Pääohjelmalla on nyt siis langan päässä kaksi Henkilö-olioa. Henkilöllä on nimi ja syntymäpäivä. Koska molemmat ovat olioita, ovat ne henkilöllä langan päässä.
</p>

<p>
  Syntymäpäivä vaikuttaa hyvältä laajennukselta Henkilö-luokkaan. Totesimme aiemmin, että oliomuuttuja <code>ika</code> voidaan laskea syntymäpäivästä, joten siitä hankkiuduttiin eroon.
</p>

<p>
  Javassa nykyinen päivä selviää seuraavasti:
</p>

<% partial 'partials/code_highlight' do %>
  import java.time.LocalDate;

  public class Esimerkki {

      public static void main(String[] args) {
  
          LocalDate nyt = LocalDate.now();
          int vuosi = nyt.getYear();
          int kuukausi = nyt.getMonthValue();
          int paiva = nyt.getDayOfMonth();
  
          System.out.println("tänään on " + paiva + "." + kuukausi + "." + vuosi);

      }
  }
<% end %>


<% partial 'partials/exercise', locals: { name: 'Ikä vuosina' } do %>

  <p>
    Tehtäväpohjassa tulee mukana edellä nähdyt luokat Henkilo ja Paivays. Täydennä luokan Henkilo metodia <code>public int ikaVuosina()</code> siten, että se laskee ja palauttaa henkilön tämän hetkisen iän vuosina.
  </p>

  <p>
    Voit olettaa, että jokaisessa vuodessa on tasan 360 päivää.
  </p>

  <p>
    <strong>Vinkki!</strong> Näppärä lähestymistapa on laskea päivien summa vuosien, kuukausien ja päivien perusteella. Erottamalla "nykypäivää" vastaavan päivien summan syntymäpäivän päivien summasta saat elettyjen päivien määrän. Eletyt päivät saa muunnettua takaisin vuosiksi jakolaskulla.
  </p>

<% end %>



<% partial 'partials/hint', locals: { name: 'Mikä ihmeen al-Khwarizmi -- tai algoritmi?' } do %>

  <p>
    Ensimmäiset korkeakulttuurit syntyivät (laajemman) lähi-idän alueelle, mikä nopeutti siellä myös henkistä kasvua. Lähi-idässä oltiin merkittävästi muuta maailmaa edellä muunmuassa matematiikassa ja tähtitieteessä -- esimerkiksi Euroopassa 1500-luvulla tapahtunut murros tähtitieteessä (maa kiertääkin aurinkoa eikä toisin päin), tapahtui laajemman lähi-idän vaikutuspiirissä olleessa kreikassa jo noin 300 vuotta ennen ajanlaskumme alkua.
  </p>

  <p>
    Nimi al-Khwarizmi viittaa oikeastaan alueeseen, tai hieman laajemmin, etuosa al- viittaa usein henkilön synty- tai kotipaikkaan. <a href="https://en.wikipedia.org/wiki/Muhammad_ibn_Musa_al-Khwarizmi" target="_blank" rel="noopener">Muhammad ibn Musa al-Khwarizmi</a> -- tai hänen isänsä tai esi-isänsä -- tulivat keskiaasiasta alueelta, joka tunnetaan nykyään suomen kielessä nimellä Harezm. Nykyään käytetty termi <strong>algoritmi</strong> onkin hatunnosto sekä Muhammad ibn Musa al-Khwarizmille että hänen syntyperälleen.
  </p>

  <p>
    Merkittävä osa al-Khwarizmin työstä tapahtui Baghdadissa sijaitsevassa Viisauden talossa, joka paikallisen hallinnon tukemana keräsi tiedemiehiä eri puolilta maailmaa yhteen. Tavoitteena oli "pienimuotoisesti" kerätä kaikki maailman tieto yhteen paikkaan ja kääntää se arabian kielelle, jota sitten jaettiin eteenpäin. Tätä kautta tietoa valui myös eurooppaan: esimerkiksi al-Khwarizmin kirja intialaisilla numeroilla laskemisesta (latinaksi "Algoritmi de numero Indorum") toi arabialaisten numeroiden käytön eurooppaan.
  </p>

  <p>
    Tämä terminologia näkyy yhä esimerkikiksi espanjan kielessä. Espanjankielinen sana guarismo -- eli suomeksi luku -- tulee ilmeisesti juurikin al-Khwarizmin nimestä.
  </p>

  <p>
    Vaikka Muhammad ibn Musa al-Khwarizmi kytketään nykyään -- ainakin tietojenkäsittelytieteilijöiden parissa -- ensisijaisesti algoritmeihin, on hän ennen kaikkea vaikuttanut merkittävästi algebran kehitykseen. Hänen työnsä tuolla alueella kontribuoi mm. ensimmäisen ja toisen asteen yhtälöiden ratkaisemiseen. Työn keskiössä olivat konkreettiset esimerkit sekä selkokieliset askeleittaiset ratkaisut  -- numeroita tuossa työssä ei esiintynyt.
  </p>


<% end %>



<% partial 'partials/material_sub_heading' do %>
  Olio metodin parametrina
<% end %>


<p>
  Olemme nähneet että metodien parametrina voi olla esimerkiksi <code>int</code> tai <code>String</code> tyyppisiä muuttujia. Kuten arvata saattaa, metodin parametriksi voi määritellä minkä tahansa tyyppisen olion. Demonstroidaan tätä esimerkillä.
</p>

<p>
  Painonvartijoihin hyväksytään jäseniksi henkilöitä, joiden painoindeksi ylittää annetun rajan. Kaikissa painonvartijayhdistyksissä raja ei ole sama. Tehdään painonvartijayhdistystä vastaava luokka. Olioa luotaessa konstruktorille annetaan parametriksi pienin painoindeksi, jolla yhdistyksen jäseneksi pääsee.
</p>

<% partial 'partials/code_highlight' do %>
  public class PainonvartijaYhdistys {
      private double alinPainoindeksi;

      public PainonvartijaYhdistys(double indeksiRaja) {
          this.alinPainoindeksi = indeksiRaja;
      }
  }
<% end %>

<p>
  Tehdään seuraavaksi metodi, jonka avulla voidaan tarkastaa hyväksytäänkö tietty henkilö yhdistyksen jäseneksi, eli onko henkilön painoindeksi tarpeeksi suuri. Metodi palauttaa <code>true</code> jos parametrina annettu henkilö hyväksytään, <code>false</code> jos ei.
</p>

<% partial 'partials/code_highlight' do %>
  public class PainonvartijaYhdistys {
      private double alinPainoindeksi;

      public PainonvartijaYhdistys(double indeksiRaja) {
          this.alinPainoindeksi = indeksiRaja;
      }

      public boolean hyvaksytaanJaseneksi(Henkilo henkilo) {
          if (henkilo.painoIndeksi() &lt; this.alinPainoindeksi) {
              return false;
          }

          return true;
      }
  }
<% end %>

<p>
  Painonvartijayhdistys-olion metodille <code>hyvaksytaanJaseneksi</code> annetaan siis parametrina <code>Henkilo</code>-olio. Kuten aiemmin, muuttujan arvo -- eli tässä viite -- kopioituu metodin käyttöön. Metodissa käsitellään kopioitua viitettä ja kutsutaan parametrina saadun henkilön metodia <code>painoIndeksi</code>.
</p>

<p>
  Seuraavassa testipääohjelma jossa painonvartijayhdistyksen metodille annetaan ensin parametriksi henkilöolio <code>matti</code> ja sen jälkeen henkilöolio <code>juhana</code>:
</p>

<% partial 'partials/code_highlight' do %>
  Henkilo matti = new Henkilo("Matti");
  matti.setPaino(86);
  matti.setPituus(180);

  Henkilo juhana = new Henkilo("Juhana");
  juhana.setPaino(64);
  juhana.setPituus(172);

  PainonvartijaYhdistys kumpulanPaino = new PainonvartijaYhdistys(25);

  if (kumpulanPaino.hyvaksytaanJaseneksi(matti)) {
      System.out.println(matti.getNimi() + " pääsee jäseneksi");
  } else {
      System.out.println(matti.getNimi() + " ei pääse jäseneksi");
  }

  if (kumpulanPaino.hyvaksytaanJaseneksi(juhana)) {
      System.out.println(juhana.getNimi() + " pääsee jäseneksi");
  } else {
      System.out.println(juhana.getNimi() + " ei pääse jäseneksi");
  }
<% end %>

<p> Ohjelma tulostaa: </p>

<% partial 'partials/sample_output' do %>
  Matti pääsee jäseneksi
  Juhana ei pääse jäseneksi
<% end %>



<% partial 'partials/hint', locals: { name: 'Konstruktorien, getterien ja setterien automaattinen generointi' } do %>

  <p>
    Ohjelmointiympäristöt osaavat auttaa ohjelmoijaa. Jos luokalle on määriteltynä oliomuuttujat, onnistuu konstruktorien, getterien ja setterien generointi automaattisesti.
  </p>

  <p>
    Mene luokan koodilohkon sisäpuolelle mutta kaikkien metodien ulkopuolelle ja paina yhtä aikaa ctrl ja välilyönti. Jos luokallasi on esim. oliomuuttuja <code>saldo</code>, tarjoaa NetBeans mahdollisuuden generoida oliomuuttujalle getteri- ja setterimetodit sekä konstruktorin joka asettaa oliomuuttujalle alkuarvon.
  </p>

  <p>
    Joillain Linux-koneilla, kuten Kumpulassa olevilla koneilla, tämä saadaan aikaan painamalla yhtä aikaa ctrl, alt ja välilyönti.
  </p>

<% end %>

<!-- CAST2 -->

<a href="http://www.youtube.com/watch?feature=player_embedded&v=aSFT6UnyvE0" height="300" target="_blank" rel="noopener"><img src=" https://www.cs.helsinki.fi/group/java/k13/ohpe/img/youtube.jpg"/></a>

<p>&nbsp;</p>

<% partial 'partials/exercise', locals: { name: 'Kasvatuslaitos (3 osaa)' } do %>

  <p>
    Tehtäväpohjassasi on valmiina jo tutuksi tullut luokka <code>Henkilo</code> sekä runko luokalle <code>Kasvatuslaitos</code>. Kasvatuslaitosoliot käsittelevät ihmisiä eri tavalla, esim. punnitsevat ja syöttävät ihmisiä. Rakennamme tässä tehtävässä kasvatuslaitoksen. Luokan Henkilö koodiin ei tehtävässä ole tarkoitus koskea!
  </p>


  <h2>Henkilöiden punnitseminen</h2>

  <p>
    Kasvatuslaitoksen luokkarungossa on valmiina runko metodille <code>punnitse</code>:
  </p>

  <% partial 'partials/code_highlight' do %>
    public class Kasvatuslaitos {

        public int punnitse(Henkilo henkilo) {
            // palautetaan parametrina annetun henkilön paino
            return -1;
        }
    }
  <% end %>

  <p>
    Metodi saa parametrina henkilön ja metodin on tarkoitus palauttaa kutsujalleen parametrina olevan henkilön paino. Paino selviää kutsumalla parametrina olevan henkilön <code>henkilo</code> sopivaa metodia. <strong>Eli täydennä metodin koodi!</strong>
  </p>

  <p>
    Seuraavassa on pääohjelma jossa kasvatuslaitos punnitsee kaksi henkilöä:
  </p>

  <% partial 'partials/code_highlight' do %>
    public static void main(String[] args) {
        // esimerkkipääohjelma tehtävän ensimmäiseen kohtaan

        Kasvatuslaitos haaganNeuvola = new Kasvatuslaitos();

        Henkilo eero = new Henkilo("Eero", 1, 110, 7);
        Henkilo pekka = new Henkilo("Pekka", 33, 176, 85);

        System.out.println(eero.getNimi() + " paino: " + haaganNeuvola.punnitse(eero) + " kiloa");
        System.out.println(pekka.getNimi() + " paino: " + haaganNeuvola.punnitse(pekka) + " kiloa");
    }
  <% end %>

  <p>
    Tulostuksen pitäisi olla seuraava:
  </p>

  <% partial 'partials/sample_output' do %>
    Eero paino: 7 kiloa
    Pekka paino: 85 kiloa
  <% end %>

  <h2>Syöttäminen</h2>

  <p>
    Parametrina olevan olion tilaa on mahdollista muuttaa. Tee kasvatuslaitokselle metodi <code>public void syota(Henkilo henkilo)</code> joka kasvattaa parametrina olevan henkilön painoa yhdellä.
  </p>

  <p>
    Seuraavassa esimerkki, jossa henkilöt ensin punnitaan, ja tämän jälkeen neuvolassa syötetään eeroa kolme kertaa. Tämän jälkeen henkilöt taas punnitaan:
  </p>

  <% partial 'partials/code_highlight' do %>
    public static void main(String[] args) {
        Kasvatuslaitos haaganNeuvola = new Kasvatuslaitos();

        Henkilo eero = new Henkilo("Eero", 1, 110, 7);
        Henkilo pekka = new Henkilo("Pekka", 33, 176, 85);

        System.out.println(eero.getNimi() + " paino: " + haaganNeuvola.punnitse(eero) + " kiloa");
        System.out.println(pekka.getNimi() + " paino: " + haaganNeuvola.punnitse(pekka) + " kiloa");

        haaganNeuvola.syota(eero);
        haaganNeuvola.syota(eero);
        haaganNeuvola.syota(eero);

        System.out.println("");

        System.out.println(eero.getNimi() + " paino: " + haaganNeuvola.punnitse(eero) + " kiloa");
        System.out.println(pekka.getNimi() + " paino: " + haaganNeuvola.punnitse(pekka) + " kiloa");
    }
  <% end %>

  <p>
    Tulostuksen pitäisi paljastaa että Eeron paino on noussut kolmella:
  </p>

  <% partial 'partials/sample_output' do %>
    Eero paino: 7 kiloa
    Pekka paino: 85 kiloa

    Eero paino: 10 kiloa
    Pekka paino: 85 kiloa
  <% end %>

  <h2>Punnitusten laskeminen</h2>

  <p>
    Tee kasvatuslaitokselle metodi <code>public int punnitukset()</code> joka kertoo kuinka monta punnitusta kasvatuslaitos on ylipäätään tehnyt. Testipääohjelma:
  </p>

  <% partial 'partials/code_highlight' do %>
    public static void main(String[] args) {
        // esimerkkipääohjelma tehtävän ensimmäiseen kohtaan

        Kasvatuslaitos haaganNeuvola = new Kasvatuslaitos();

        Henkilo eero = new Henkilo("Eero", 1, 110, 7);
        Henkilo pekka = new Henkilo("Pekka", 33, 176, 85);

        System.out.println("punnituksia tehty " + haaganNeuvola.punnitukset());

        haaganNeuvola.punnitse(eero);
        haaganNeuvola.punnitse(pekka);

        System.out.println("punnituksia tehty " + haaganNeuvola.punnitukset());

        haaganNeuvola.punnitse(eero);
        haaganNeuvola.punnitse(eero);
        haaganNeuvola.punnitse(eero);
        haaganNeuvola.punnitse(eero);

        System.out.println("punnituksia tehty " + haaganNeuvola.punnitukset());
    }
  <% end %>

  <p>
    Tulostuu:
  </p>

  <% partial 'partials/sample_output' do %>
    punnituksia tehty 0
    punnituksia tehty 2
    punnituksia tehty 6
  <% end %>
<% end %>



<% partial 'partials/exercise', locals: { name: 'Maksukortti ja Kassapääte (4 osaa)' } do %>

  <h2>"Tyhmä" Maksukortti</h2>

  <p>
    Teimme edellisessä osassa luokan Maksukortti. Kortilla oli metodit edullisesti ja maukkaasti syömistä sekä rahan lataamista varten.
  </p>

  <p>
    Edellisen osan tyylillä tehdyssä Maksukortti-luokassa oli kuitenkin ongelma. Kortti tiesi lounaiden hinnan ja osasi sen ansiosta vähentää saldoa oikean määrän. Entä kun hinnat nousevat? Tai jos myyntivalikoimaan tulee uusia tuotteita? Hintojen muuttaminen tarkoittaisi, että kaikki jo käytössä olevat kortit pitäisi korvata uusilla, uudet hinnat tuntevilla korteilla.
  </p>

  <p>
    Parempi ratkaisu on tehdä kortit "tyhmiksi", hinnoista ja myytävistä tuotteista tietämättömiksi pelkän saldon säilyttäjiksi. Kaikki äly kannattaakin laittaa erillisiin olioihin, kassapäätteisiin.
  </p>

  <p>
    Toteutetaan ensin Maksukortista "tyhmä" versio. Kortilla on ainoastaan metodit saldon kysymiseen, rahan lataamiseen ja rahan ottamiseen. Täydennä alla (ja tehtäväpohjassa) olevaan luokkaan metodin <code>public boolean otaRahaa(double maara)</code> ohjeen mukaan:
  </p>

  <% partial 'partials/code_highlight' do %>
    public class Maksukortti {
        private double saldo;

        public Maksukortti(double saldo) {
            this.saldo = saldo;
        }

        public double saldo() {
            return this.saldo;
        }

        public void lataaRahaa(double lisays) {
            this.saldo += lisays;
        }

        public boolean otaRahaa(double maara) {
            // toteuta metodi siten että se ottaa kortilta rahaa vain jos saldo on vähintään maara
            // onnistuessaan metodi palauttaa true ja muuten false
        }
    }
  <% end %>

  <p>
    Testipääohjelma:
  </p>

  <% partial 'partials/code_highlight' do %>
    public class Paaohjelma {
        public static void main(String[] args) {
            Maksukortti pekanKortti = new Maksukortti(10);

            System.out.println("rahaa " + pekanKortti.saldo());
            boolean onnistuiko = pekanKortti.otaRahaa(8);
            System.out.println("onnistuiko otto: " + onnistuiko);
            System.out.println("rahaa " + pekanKortti.saldo());

            onnistuiko = pekanKortti.otaRahaa(4);
            System.out.println("onnistuiko otto: " + onnistuiko);
            System.out.println("rahaa " + pekanKortti.saldo());
        }
    }
  <% end %>

  <p>
    Tulostuksen kuuluisi olla seuraavanlainen
  </p>

  <% partial 'partials/sample_output' do %>
    rahaa 10.0
    onnistuiko otto: true
    rahaa 2.0
    onnistuiko otto: false
    rahaa 2.0
  <% end %>

  
  <h2>Kassapääte ja käteiskauppa</h2>

  <p>
    Unicafessa asioidessa asiakas maksaa joko käteisellä tai maksukortilla. Myyjä käyttää kassapäätettä kortin velottamiseen ja käteismaksujen hoitamiseen. Tehdään ensin kassapäätteestä käteismaksuihin sopiva versio.
  </p>

  <p>
    Kassapäätteen runko. Metodien kommentit kertovat halutun toiminnallisuuden:
  </p>

  <% partial 'partials/code_highlight' do %>
    public class Kassapaate {
        private double rahaa;  // kassassa olevan käteisen määrä
        private int edulliset; // myytyjen edullisten lounaiden määrä
        private int maukkaat;  // myytyjen maukkaiden lounaiden määrä

        public Kassapaate() {
            // kassassa on aluksi 1000 euroa rahaa
        }

        public double syoEdullisesti(double maksu) {
            // edullinen lounas maksaa 2.50 euroa.
            // kasvatetaan kassan rahamäärää edullisen lounaan hinnalla ja palautetaan vaihtorahat
            // jos parametrina annettu maksu ei ole riittävän suuri, ei lounasta myydä ja metodi palauttaa koko summan
        }

        public double syoMaukkaasti(double maksu) {
            // maukas lounas maksaa 4.30 euroa.
            // kasvatetaan kassan rahamäärää maukkaan lounaan hinnalla ja palautetaan vaihtorahat
            // jos parametrina annettu maksu ei ole riittävän suuri, ei lounasta myydä ja metodi palauttaa koko summan
        }

        public String toString() {
            return "kassassa rahaa " + rahaa + " edullisia lounaita myyty " + edulliset + " maukkaita lounaita myyty " + maukkaat;
        }
    }
  <% end %>

  <p>
    Kassapäätteessä on aluksi rahaa 1000 euroa. Toteuta yllä olevan rungon metodit ohjeen ja alla olevan pääohjelman esimerkkitulosteen mukaan toimiviksi.
  </p>

  <% partial 'partials/code_highlight' do %>
    public class Paaohjelma {
        public static void main(String[] args) {
            Kassapaate unicafeExactum = new Kassapaate();

            double vaihtorahaa = unicafeExactum.syoEdullisesti(10);
            System.out.println("vaihtorahaa jäi " + vaihtorahaa);

            vaihtorahaa = unicafeExactum.syoEdullisesti(5);
            System.out.println("vaihtorahaa jäi " + vaihtorahaa);

            vaihtorahaa = unicafeExactum.syoMaukkaasti(4.3);
            System.out.println("vaihtorahaa jäi " + vaihtorahaa);

            System.out.println(unicafeExactum);
        }
    }
  <% end %>

  <% partial 'partials/sample_output' do %>
    vaihtorahaa jäi 7.5
    vaihtorahaa jäi 2.5
    vaihtorahaa jäi 0.0
    kassassa rahaa 1009.3 edullisia lounaita myyty 2 maukkaita lounaita myyty 1
  <% end %>

  
  <h2>Kortilla maksaminen</h2>

  <p>
    Laajennetaan kassapäätettä siten että myös kortilla voi maksaa. Teemme kassapäätteelle siis metodit joiden parametrina kassapääte saa maksukortin jolta se vähentää valitun lounaan hinnan. Seuraavassa uusien metodien rungot ja ohje niiden toteuttamiseksi:
  </p>

  <% partial 'partials/code_highlight' do %>
    public class Kassapaate {
        // ...

        public boolean syoEdullisesti(Maksukortti kortti) {
            // edullinen lounas maksaa 2.50 euroa.
            // jos kortilla on tarpeeksi rahaa, vähennetään hinta kortilta ja palautetaan true
            // muuten palautetaan false
        }

        public boolean syoMaukkaasti(Maksukortti kortti) {
            // maukas lounas maksaa 4.30 euroa.
            // jos kortilla on tarpeeksi rahaa, vähennetään hinta kortilta ja palautetaan true
            // muuten palautetaan false
        }

        // ...
    }
  <% end %>

  <p>
    <b>Huom:</b> kortilla maksaminen ei lisää kassapäätteessä olevan käteisen määrää.
  </p>

  <p>
    Seuraavassa testipääohjelma ja haluttu tulostus:
  </p>

  <% partial 'partials/code_highlight' do %>
    public class Paaohjelma {
        public static void main(String[] args) {
            Kassapaate unicafeExactum = new Kassapaate();

            double vaihtorahaa = unicafeExactum.syoEdullisesti(10);
            System.out.println("vaihtorahaa jäi " + vaihtorahaa);

            Maksukortti antinKortti = new Maksukortti(7);

            boolean onnistuiko = unicafeExactum.syoMaukkaasti(antinKortti);
            System.out.println("riittikö raha: " + onnistuiko);
            onnistuiko = unicafeExactum.syoMaukkaasti(antinKortti);
            System.out.println("riittikö raha: " + onnistuiko);
            onnistuiko = unicafeExactum.syoEdullisesti(antinKortti);
            System.out.println("riittikö raha: " + onnistuiko);

            System.out.println(unicafeExactum);
        }
    }
  <% end %>

  <% partial 'partials/sample_output' do %>
    vaihtorahaa jäi 7.5
    riittikö raha: true
    riittikö raha: false
    riittikö raha: true
    kassassa rahaa 1002.5 edullisia lounaita myyty 2 maukkaita lounaita myyty 1
  <% end %>

  
  <h2>Rahan lataaminen</h2>

  <p>
    Lisätään vielä kassapäätteelle metodi jonka avulla kortille voidaan ladata lisää rahaa. Muista, että rahan lataamisen yhteydessä ladattava summa viedään kassapäätteeseen. Metodin runko:
  </p>

  <% partial 'partials/code_highlight' do %>
    public void lataaRahaaKortille(Maksukortti kortti, double summa) {
        // ...
    }
  <% end %>

  <p>
    Testipääohjelma ja esimerkkisyöte:
  </p>

  <% partial 'partials/code_highlight' do %>
    public class Paaohjelma {
        public static void main(String[] args) {
            Kassapaate unicafeExactum = new Kassapaate();
            System.out.println(unicafeExactum);

            Maksukortti antinKortti = new Maksukortti(2);

            System.out.println("kortilla rahaa " + antinKortti.saldo() + " euroa");

            boolean onnistuiko = unicafeExactum.syoMaukkaasti(antinKortti);
            System.out.println("riittikö raha: " + onnistuiko);

            unicafeExactum.lataaRahaaKortille(antinKortti, 100);

            onnistuiko = unicafeExactum.syoMaukkaasti(antinKortti);
            System.out.println("riittikö raha: " + onnistuiko);

            System.out.println("kortilla rahaa " + antinKortti.saldo() + " euroa");
 
            System.out.println(unicafeExactum);
        }
    }
  <% end %>

  <% partial 'partials/sample_output' do %>
    kassassa rahaa 1000.0 edullisia lounaita myyty 0 maukkaita lounaita myyty 0
    kortilla rahaa 2.0 euroa
    riittikö raha: false
    riittikö raha: true
    kortilla rahaa 97.7 euroa
    kassassa rahaa 1100.0 edullisia lounaita myyty 0 maukkaita lounaita myyty 1
  <% end %>
<% end %>



<% partial 'partials/material_sub_heading' do %>
  Samantyyppinen olio metodin parametrina
<% end %>

<p>
  Jatkamme edelleen luokan <code>Henkilo</code> parissa. Kuten muistamme, henkilöt tietävät syntymäpäivänsä:
</p>

<% partial 'partials/code_highlight' do %>
  public class Henkilo {

      private String nimi;
      private Paivays syntymaPaiva;
      private int pituus;
      private int paino;

      // ...
  }
<% end %>


<p>
  Haluamme vertailla kahden henkilön ikää. Vertailu voidaan hoitaa usealla tavalla. Voisimme esimerkiksi toteuttaa Henkilo-luokkaan metodin <code>public int ikaVuosina()</code>, jolloin kahden henkilön iän vertailu tapauhtuisi tällöin seuraavasti:
</p>


<% partial 'partials/code_highlight' do %>
  Henkilo muhammad = new Henkilo("Muhammad ibn Musa al-Khwarizmi", 1, 1, 780);
  Henkilo pascal = new Henkilo("Blaise Pascal", 19, 6, 1623);

  if (muhammad.ikaVuosina() &gt; pascal.ikaVuosina()) {
      System.out.println(muhammad.getNimi() + " on vanhempi kuin " + pascal.getNimi());
  }
<% end %>

<p>
  Harjoittelemme tässä kuitenkin hieman "oliohenkisemmän" tavan kahden henkilön ikävertailun tekemiseen.
</p>

<p>
  Teemme Henkilöluokalle metodin <code>boolean vanhempiKuin(Henkilo verrattava)</code> jonka avulla tiettyä henkilö-olioa voi verrata parametrina annettuun henkilöön iän perusteella.
</p>

<p>
  Metodia on tarkoitus käyttää seuraavaan tyyliin:
</p>

<% partial 'partials/code_highlight' do %>
  Henkilo muhammad = new Henkilo("Muhammad ibn Musa al-Khwarizmi", 1, 1, 780);
  Henkilo pascal = new Henkilo("Blaise Pascal", 19, 6, 1623);

  if (muhammad.vanhempiKuin(pascal)) {  //  sama kun muhammad.vanhempiKuin(pascal)==true
      System.out.println(muhammad.getNimi() + " on vanhempi kuin " + pascal.getNimi());
  } else {
      System.out.println(muhammad.getNimi() + " ei ole vanhempi kuin " + pascal.getNimi());
  }
<% end %>

<p>
  Tässä siis kysytään onko al-Khwarizmi Pascalia vanhempi "jos A on vanhempi kuin B". Metodi <code>vanhempiKuin</code> palauttaa arvon <code>true</code> jos olio jonka kohdalla metodia kutsutaan (<code>olio.vanhempiKuin(parametrinaAnnettavaOlio)</code>) on vanhempi kuin parametrina annettava olio, ja <code>false</code> muuten.
</p>

<p>
  Käytännössä yllä kutsutaan "Muhammad ibn Musa al-Khwarizmia" vastaavan olion, johon muuttuja <code>muhammad</code> viittaa, metodia <code>vanhempiKuin</code>. Metodille annetaan parametriksi "Blaise Pascal" vastaavan olion viite <code>pascal</code>.
</p>

<p>
  Ohjelma tulostaa:
</p>

<% partial 'partials/sample_output' do %>
  Muhammad ibn Musa al-Khwarizmi on vanhempi kuin Blaise Pascal
<% end %>

<p>
  Metodille <code>vanhempiKuin</code> annetaan parametrina henkilöolio. Tarkemmin sanottuna metodin parametriksi määriteltyyn muuttujaan kopioituu parametrina annettavan muuttujan sisältämä arvo, eli viite olioon.
</p>

<p>
  Metodin toteutus näyttää seuraavalta. Huomaa, että metodi voi palauttaa arvon useammasta kohtaa -- alla vertailu on pilkottu useampaan osaan:
</p>

<% partial 'partials/code_highlight' do %>
  public class Henkilo {
      // ...

      public boolean vanhempiKuin(Henkilo verrattava) {
          // toteutus
          if (this.getSyntymaPaiva().getVuosi() &lt; verrattava.getSyntymaPaiva().getVuosi()) {
              return true;
          }

          if (this.getSyntymaPaiva().getVuosi() == verrattava.getSyntymaPaiva().getVuosi()
              && this.getSyntymaPaiva().getKuukausi() &lt; verrattava.getSyntymaPaiva().getKuukausi()) {
              return true;
          }

          if (this.getSyntymaPaiva().getVuosi() == verrattava.getSyntymaPaiva().getVuosi()
              && this.getSyntymaPaiva().getKuukausi() == verrattava.getSyntymaPaiva().getKuukausi()
              && this.getSyntymaPaiva().getPaiva() &lt; verrattava.getSyntymaPaiva().getPaiva()) {
              return true;
          }

          return false;
      }
  }
<% end %>


<p>
  Mietitään hieman olio-ohjelmoinnin periatteiden abstrahointia. Abstrahoinnin ajatuksena on käsitteellistää ohjelmakoodia siten, että kullakin käsitteellä on omat selkeät vastuunsa. Kun pohdimme yllä esitettyä ratkaisua, huomaamme, että päivämäärien vertailutoiminnallisuus kuuluisi mielummin luokkaan <code>Paivays</code> luokan <code>Henkilo</code>-sijaan.
</p>

<p>
  Luodaan luokalle <code>Paivays</code> metodi <code>public boolean aiemmin(Paivays verrattava)</code>. Metodi palauttaa arvon <code>true</code>, jos metodille parametrina annettu päiväys on kyseisen olion päiväyksen jälkeen.
</p>

<% partial 'partials/code_highlight' do %>
  public class Paivays {
      private int paiva;
      private int kuukausi;
      private int vuosi;

      public Paivays(int paiva, int kuukausi, int vuosi) {
          this.paiva = paiva;
          this.kuukausi = kuukausi;
          this.vuosi = vuosi;
      }

      public String toString() {
          return this.paiva + "." + this.kuukausi + "." + this.vuosi;
      }

      // metodilla tarkistetaan onko tämä päiväysolio (<code>this</code>) ennen
      // parametrina annettavaa päiväysoliota (<code>verrattava</code>)
      public boolean aiemmin(Paivays verrattava) {
          // ensin verrataan vuosia
          if (this.vuosi &lt; verrattava.vuosi) {
              return true;
          }

          // jos vuodet ovat samat, verrataan kuukausia
          if (this.vuosi == verrattava.vuosi &amp;&amp; this.kuukausi &lt; verrattava.kuukausi) {
              return true;
          }

          // vuodet ja kuukaudet samoja, verrataan päivää
          if (this.vuosi == verrattava.vuosi &amp;&amp; this.kuukausi == verrattava.kuukausi &amp;&amp;
              this.paiva &lt; verrattava.paiva) {
              return true;
          }

          return false;
      }
  }
<% end %>

<p>
  Vaikka oliomuuttujat <code>vuosi</code>, <code>kuukausi</code> ja <code>paiva</code> ovat olion kapseloimia (<code>private</code>) oliomuuttujia, pystymme lukemaan niiden arvon kirjoittamalla <code>verrattava.<em>muuttujanNimi</em></code>. Tämä johtuu siitä, että <code>private</code>-muuttujat ovat luettavissa kaikissa metodeissa, jotka kyseinen luokka sisältää. Huomaa, että syntaksi (kirjoitusasu) vastaa tässä jonkin olion metodin kutsumista. Toisin kuin metodia kutsuttaessa, viittaamme olion kenttään, jolloin metodikutsun osoittavia sulkeita ei kirjoiteta.
</p>

<p>
  Metodin käyttöesimerkki:
</p>

<% partial 'partials/code_highlight' do %>
  public static void main(String[] args) {
      Paivays p1 = new Paivays(14, 2, 2011);
      Paivays p2 = new Paivays(21, 2, 2011);
      Paivays p3 = new Paivays(1, 3, 2011);
      Paivays p4 = new Paivays(31, 12, 2010);

      System.out.println(p1 + " aiemmin kuin " + p2 + ": " + p1.aiemmin(p2));
      System.out.println(p2 + " aiemmin kuin " + p1 + ": " + p2.aiemmin(p1));

      System.out.println(p2 + " aiemmin kuin " + p3 + ": " + p2.aiemmin(p3));
      System.out.println(p3 + " aiemmin kuin " + p2 + ": " + p3.aiemmin(p2));

      System.out.println(p4 + " aiemmin kuin " + p1 + ": " + p4.aiemmin(p1));
      System.out.println(p1 + " aiemmin kuin " + p4 + ": " + p1.aiemmin(p4));
  }
<% end %>

<% partial 'partials/sample_output' do %>
  14.2.2011 aiemmin kuin 21.2.2011: true
  21.2.2011 aiemmin kuin 14.2.2011: false
  21.2.2011 aiemmin kuin 1.3.2011: true
  1.3.2011 aiemmin kuin 21.2.2011: false
  31.12.2010 aiemmin kuin 14.2.2011: true
  14.2.2011 aiemmin kuin 31.12.2010: false
<% end %>

<p>
  Muunnetaan vielä henkilön metodia vanhempiKuin siten, että hyödynnämme jatkossa päivämäärän tarjoamaa vertailutoiminnallisuutta.
</p>

<% partial 'partials/code_highlight' do %>
  public class Henkilo {
      // ...

      public boolean vanhempiKuin(Henkilo verrattava) {
          if (this.syntymaPaiva.aiemmin(verrattava.getSyntymaPaiva())) {
              return true;
          }

          return false;

          // tai suoraan:
          // return this.syntymaPaiva.aiemmin(verrattava.getSyntymaPaiva());
      }
  }
<% end %>

<p>
  Nyt päivämäärän konkreettinen vertailu on toteutettu luokassa, johon se loogisesti (luokkien nimien perusteella) kuuluukin.
</p>

<% partial 'partials/exercise', locals: { name: 'Asuntovertailu (3 osaa)' } do %>

  <p>
    Asuntovälitystoimiston tietojärjestelmässä kuvataan myynnissä olevaa asuntoa seuraavasta luokasta tehdyillä olioilla:
  </p>

  <% partial 'partials/code_highlight' do %>
    public class Asunto {
        private int huoneita;
        private int nelioita;
        private int neliohinta;

        public Asunto(int huoneita, int nelioita, int neliohinta) {
            this.huoneita = huoneita;
            this.nelioita = nelioita;
            this.neliohinta = neliohinta;
        }
    }
  <% end %>

  <p>
    Tehtävänä on toteuttaa muutama metodi, joiden avulla myynnissä olevia asuntoja voidaan vertailla.
  </p>

  <h2>Onko asunto suurempi</h2>

  <p>
    Tee metodi <code>public boolean suurempi(Asunto verrattava)</code> joka palauttaa true jos asunto-olio, jolle metodia kutsutaan on suurempi kuin verrattavana oleva asunto-olio.
  </p>

  <p>
    Esimerkki metodin toiminnasta:
  </p>

  <% partial 'partials/code_highlight' do %>
    Asunto eiraYksio = new Asunto(1, 16, 5500);
    Asunto kallioKaksio = new Asunto(2, 38, 4200);
    Asunto jakomakiKolmio = new Asunto(3, 78, 2500);

    System.out.println(eiraYksio.suurempi(kallioKaksio));       // false
    System.out.println(jakomakiKolmio.suurempi(kallioKaksio));  // true
  <% end %>

  <h2>Asuntojen hintaero</h2>

  <p>
    Tee metodi <code>public int hintaero(Asunto verrattava)</code> joka palauttaa asunto-olion jolle metodia kutsuttiin ja parametrina olevan asunto-olion hintaeron. Hintaero on asuntojen hintojen (=neliöhinta*neliöt) itseisarvo.
  </p>

  <p>
    Esimerkki metodin toiminnasta:
  </p>

  <% partial 'partials/code_highlight' do %>
    Asunto eiraYksio = new Asunto(1, 16, 5500);
    Asunto kallioKaksio = new Asunto(2, 38, 4200);
    Asunto jakomakiKolmio = new Asunto(3, 78, 2500);

    System.out.println(eiraYksio.hintaero(kallioKaksio));        // 71600
    System.out.println(jakomakiKolmio.hintaero(kallioKaksio));   // 35400
  <% end %>

  <h2>Onko asunto kalliimpi</h2>

  <p>
    Tee metodi <code>public boolean kalliimpi(Asunto verrattava)</code> joka palauttaa true jos asunto-olio, jolle metodia kutsutaan on kalliimpi kuin verrattavana oleva asunto-olio.
  </p>

  <p>
    Esimerkki metodin toiminnasta:
  </p>

  <% partial 'partials/code_highlight' do %>
    Asunto eiraYksio = new Asunto(1, 16, 5500);
    Asunto kallioKaksio = new Asunto(2, 38, 4200);
    Asunto jakomakiKolmio = new Asunto(3, 78, 2500);

    System.out.println(eiraYksio.kalliimpi(kallioKaksio));       // false
    System.out.println(jakomakiKolmio.kalliimpi(kallioKaksio));   // true
  <% end %>
<% end %>


<% partial 'partials/material_sub_heading' do %>
  Olioiden yhtäsuuruuden vertailu
<% end %>

<p>
  Opimme merkkijonojen käsittelyn yhteydessä, että merkkijonojen vertailu tulee toteuttaa <code>equals</code>-metodin avullla. Tämä tapahtuu seuraavasti.
</p>


<% partial 'partials/code_highlight' do %>
  Scanner lukija = new Scanner(System.in);

  System.out.println("Syötä kaksi sanaa, kumpikin omalle rivilleen.")
  String eka = lukija.nextLine();
  String toka = lukija.nextLine();

  if (eka.equals(toka)) {
      System.out.println("Sanat olivat samat.");
  } else {
      System.out.println("Sanat eivät olleet samat.");
  }
<% end %>

<p>
  Alkeistyyppisten muuttujien kuten <code>int</code> kanssa muuttujien vertailu on mahdollista kahden yhtäsuuruusmerkin avulla. Tämä johtuu siitä, että alkeistyyppisten muuttujien arvo sijaitsee "muuttujan lokerossa". Viittaustyyppisten muuttujien arvo on taas osoite viitattavaan olioon, eli viittaustyyppisten muuttujien "lokerossa" on viite muistipaikkaan. Kahden yhtäsuuruusmerkin avulla verrataan "muuttujan lokeron" sisällön yhtäsuuruutta -- viittaustyyppisillä muuttujilla vertailu tarkastelisi siis muuttujien osoitteiden yhtäsuuruutta.
</p>

<p>
  Metodi <code>equals</code> taas tarkastelee muuttujaan liittyvän olion sisältöä. Jos haluamme pystyä vertailemaan kahta itse toteuttamaamme oliota equals-metodilla, tulee metodi määritellä luokkaan. Metodi equals määritellään luokkaan boolean-tyyppisen arvon palauttavana metodina -- boolean-muuttujan arvo kertoo ovatko oliot samat.
</p>

<p>
  Metodi <code>equals</code> toteutetaan siten, että sen avulla voidaan vertailla nykyistä oliota mihin tahansa muuhun olioon. Metodi saa parametrinaan Object-tyyppisen olion -- kaikki oliot ovat oman tyyppinsä lisäksi Object-tyyppisiä. Metodissa ensin vertaillaan ovatko osoitteet samat: jos kyllä, oliot ovat samat. Tämän jälkeen tarkastellaan ovatko olion tyypit samat: jos ei, oliot eivät ole samat. Tämän jälkeen parametrina saatu Object-olio muunnetaan tyyppimuunnoksella tarkasteltavan olion muotoiseksi, ja oliomuuttujien arvoja vertaillaan. Alla vertailu on toteutettu Paivays-oliolle.
</p>



<% partial 'partials/code_highlight' do %>
  public class Paivays {
      private int paiva;
      private int kuukausi;
      private int vuosi;

      public Paivays(int paiva, int kuukausi, int vuosi) {
          this.paiva = paiva;
          this.kuukausi = kuukausi;
          this.vuosi = vuosi;
      }

      public int getPaiva() {
          return this.paiva;
      }

      public int getKuukausi() {
          return this.kuukausi;
      }

      public int getVuosi() {
          return this.vuosi;
      }

      public boolean equals(Object verrattava) {
          // jos muuttujat sijaitsevat samassa paikassa, ovat ne samat
          if (this == verrattava) {
              return true;
          }

          // jos verrattava olio ei ole Paivays-tyyppinen, oliot eivät ole samat
          if (!(verrattava instanceof Paivays)) {
              return false;
          }

          // muunnetaan Object-tyyppinen verrattava-olio
          // Paivays-tyyppiseksi verrattavaPaivays-olioksi
          Paivays verrattavaPaivays = (Paivays) verrattava;

          // jos olioiden oliomuuttujien arvot ovat samat, ovat oliot samat
          if (this.paiva == verrattavaPaivays.paiva &&
              this.kuukausi == verrattavaPaivays.kuukausi &&
              this.vuosi == verrattavaPaivays.vuosi) {
              return true;
          }

          // muulloin oliot eivät ole samat
          return false;
      }
  
      @Override
      public String toString() {
          return this.paiva + "." + this.kuukausi + "." + this.vuosi;
      }
  }
<% end %>

<p>
  Vastaavan vertailutoiminnallisuuden rakentaminen onnistuu myös Henkilö-olioille. Alla vertailu on toteutettu Henkilo-oliolle, jolla ei ole erillista Paivays-oliota. Huomaa, että henkilöiden nimet ovat merkijonoja (eli olioita), joten niiden vertailussa käytetään equals-metodia.
</p>

<% partial 'partials/code_highlight' do %>
  public class Henkilo {

      private String nimi;
      private int ika;
      private int paino;
      private int pituus;

      // konstruktorit ja metodit


      public boolean equals(Object verrattava) {
          // jos muuttujat sijaitsevat samassa paikassa, ovat ne samat
          if (this == verrattava) {
              return true;
          }

          // jos verrattava olio ei ole Henkilo-tyyppinen, oliot eivät ole samat
          if (!(verrattava instanceof Henkilo)) {
              return false;
          }

          // muunnetaan olio Henkilo-olioksi
          Henkilo verrattavaHenkilo = (Henkilo) verrattava;

          // jos olioiden oliomuuttujien arvot ovat samat, ovat oliot samat
          if (this.nimi.equals(verrattavaHenkilo.nimi) && 
              this.ika == verrattavaHenkilo.ika &&
              this.paino == verrattavaHenkilo.paino &&
              this.pituus == verrattavaHenkilo.pituus) {
              return true;
          }

          // muulloin oliot eivät ole samat
          return false;
      }

      // .. metodeja
  }
<% end %>


<% partial 'partials/exercise', locals: { name: 'Kappale' } do %>
  
  <p>
    Tehtäväpohjassa on luokka <code>Kappale</code>, jonka perusteella voidaan luoda musiikkikappaleita esittäviä olioita. Lisää luokkaan kappale metodi <code>equals</code>, jonka avulla voidaan tarkastella musiikkikappaleiden samankaltaisuutta.
  </p>
  
  <% partial 'partials/code_highlight' do %>
    Kappale jackSparrow = new Kappale("The Lonely Island", "Jack Sparrow", 196);
    Kappale toinenSparrow = new Kappale("The Lonely Island", "Jack Sparrow", 196);

    if (jackSparrow.equals(toinenSparrow)) {
        System.out.println("Kappaleet olivat samat.");
    }

    if (jackSparrow.equals("Toinen olio")) {
        System.out.println("Nyt on jotain hassua.");
    }
  <% end %>

  <% partial 'partials/sample_output' do %>
    Kappaleet olivat samat.
  <% end %>
<% end %>


<% partial 'partials/exercise', locals: { name: 'Henkilön vertailu' } do %>
  
  <p>
    Tehtäväpohjassa on luokka <code>Henkilo</code>, johon liittyy <code>Paivays</code>-olio. Lisää luokalle Henkilo metodi <code>public boolean equals(Object verrattava)</code>, jonka avulla voidaan verrata henkilöiden samuutta. Vertailussa tulee verrata kaikkien henkilön muuttujien yhtäsuuruutta (ml. syntymäpäivä).
  </p>

  <p>
    Tehtäväpohjassa ei ole testejä. Keksi erilaisia esimerkkikoodeja, joilla voit testata ohjelman toimintaa. Alla pari esimerkkiä.
  </p>

  <% partial 'partials/code_highlight' do %>
    Paivays pvm = new Paivays(24, 3, 2017);
    Paivays pvm2 = new Paivays(23, 7, 2017);

    Henkilo leevi = new Henkilo("Leevi", pvm, 62, 9);
    Henkilo lilja = new Henkilo("Lilja", pvm2, 65, 8);

    if (leevi.equals(lilja)) {
        System.out.println("Meniköhän nyt ihan oikein?");
    } 

    Henkilo leeviEriPainolla = new Henkilo("Leevi", pvm, 62, 10);

    if (leevi.equals(leeviEriPainolla)) {
        System.out.println("Meniköhän nyt ihan oikein?");
    } 

  <% end %>
  
<% end %>


<% partial 'partials/hint', locals: { name: 'Mikä ihmeen Object?' } do %>

  <p>
    Olio-ohjelmoinnin periaatteissa todettiin seuraavaa: <em>Olio-ohjelmoinnissa on mahdollista luoda luokkia, jotka perivät toisen luokan ominaisuuksia (eli oliomuuttujat ja metodit). Tällöin luokasta tehdyt oliot ovat samalla myös perityn luokan ilmentymiä, jolloin oliot voivat esiintyä useampina erilaisina olioina käyttötarpeesta riippuen.</em>
  </p>

  <p>
    Jokainen luomamme luokka (ja Javan valmis luokka) perii luokan Object, vaikkei sitä erikseen ohjelmakoodissa näy. Tämän takia mistä tahansa luokasta tehty ilmentymä voidaan asettaa parametriksi metodiin, joka saa parametrina Object-tyyppisen muuttujan. Object-luokan periminen näkyy myös muissa asioissa: esimerkiksi metodi <code>toString</code> on olemassa vaikkei sitä erikseen toteuteta, aivan samalla tavalla kuin metodi <code>equals</code>.
  </p>

  <p>
    Esimerkiksi seuraava lähdekoodi siis "toimii" oikein, vaikkei toiminta ehkä olekaan haluttua.
  </p>
  
  <% partial 'partials/code_highlight' do %>
    public class Lintu {
        private String nimi;

        public Lintu(String nimi) {
            this.nimi = nimi;
        } 
    }
  <% end %>


  <% partial 'partials/code_highlight' do %>
    Lintu red = new Lintu("Red");
    System.out.println(red);

    Lintu chuck = new Lintu("Chuck");
    System.out.println(chuck);

    if (red.equals(chuck)) {
        System.out.println(red + " on sama kuin " + chuck);
    }
  <% end %>

  <p>
    Vaikka ohjelma on syntaktisesti oikein, ei lopputulos liene kuitenkaan toivottu.
  </p>
  
<% end %>


<% partial 'partials/material_sub_heading' do %>
  Olio metodin paluuarvona
<% end %>


<p>
  Olemme nähneet metodeja jotka palauttavat totuusarvoja, lukuja ja merkkijonoja. On helppoa arvata, että metodi voi palauttaa minkä tahansa tyyppisen olion.
</p>

<p>
  Seuraavassa esimerkissä on yksinkertainen laskuri, jolla on metodi <code>kloonaa</code>. Metodin avulla laskurista voidaan tehdä klooni, eli uusi laskurio-olio, jolla on luomishetkellä sama arvo kuin kloonattavalla laskurilla:
</p>

<% partial 'partials/code_highlight' do %>
  public Laskuri {
      private int arvo;

      // esimerkki useamman konstruktorin käytöstä:
      // konstruktorista voi kutsua toista konstruktoria this-kutsulla
      // huomaa tosin, että this-kutsun tulee olla konstruktorin ensimmäisellä rivillä.
      public Laskuri() {
          this(0);
      }

      public Laskuri(int alkuarvo) {
          this.arvo = alkuarvo;
      }

      public void kasvata() {
          this.arvo++;
      }

      public String toString() {
          return "arvo: " + arvo;
      }

      public Laskuri kloonaa() {
          // luodaan uusi laskuriolio, joka saa alkuarvokseen kloonattavan laskurin arvon
          Laskuri klooni = new Laskuri(this.arvo);

          // palautetaan klooni kutsujalle
          return klooni;
      }
  }
<% end %>

<p>
  Seuraavassa käyttöesimerkki:
</p>

<% partial 'partials/code_highlight' do %>
  Laskuri laskuri = new Laskuri();
  laskuri.kasvata();
  laskuri.kasvata();

  System.out.println(laskuri);         // tulostuu 2

  Laskuri klooni = laskuri.kloonaa();

  System.out.println(laskuri);         // tulostuu 2
  System.out.println(klooni);          // tulostuu 2

  laskuri.kasvata();
  laskuri.kasvata();
  laskuri.kasvata();
  laskuri.kasvata();

  System.out.println(laskuri);         // tulostuu 6
  System.out.println(klooni);          // tulostuu 2

  klooni.kasvata();

  System.out.println(laskuri);         // tulostuu 6
  System.out.println(klooni);          // tulostuu 3
<% end %>

<p>
  Kloonattavan ja kloonin sisältämä arvo on kloonauksen tapahduttua sama. Kyseessä on kuitenkin kaksi erillistä olioa, eli kun toista laskureista kasvatetaan, ei kasvatus vaikuta toisen arvoon millään tavalla.
</p>

<p>
  Vastaavasti myös <code>Tehdas</code>-olio voisi luoda ja palauttaa uusia <code>Auto</code>-olioita. Alla on hahmoteltu tehtaan runkoa -- tehdas tietää myös luotavien autojen merkin.
</p>

<% partial 'partials/code_highlight' do %>
  public class Tehdas {
      private String merkki;

      public Tehdas(String merkki) {
          this.merkki = merkki;
      }

      public Auto tuotaAuto() {
          return new Auto(this.merkki);
      }
  }
<% end %>


<% partial 'partials/exercise', locals: { name: 'Päiväys (3 osaa)' } do %>

  <p>
    Tehtäväpohjan mukana tulee aiemmin esitelty luokka <code>Paivays</code>, jossa päivämäärä talletetaan oliomuuttujien <code>vuosi</code>, <code>kuukausi</code>, ja <code>paiva</code> avulla:
  </p>

  <% partial 'partials/code_highlight' do %>
    public class Paivays {
        private int paiva;
        private int kuukausi;
        private int vuosi;

        public Paivays(int paiva, int kuukausi, int vuosi) {
            this.paiva = paiva;
            this.kuukausi = kuukausi;
            this.vuosi = vuosi;
        }

        public String toString() {
            return this.paiva + "." + this.kuukausi + "." + this.vuosi;
        }

        public boolean aiemmin(Paivays verrattava) {
            // ensin verrataan vuosia
            if (this.vuosi &lt; verrattava.vuosi) {
                return true;
            }

            // jos vuodet ovat samat, verrataan kuukausia
            if (this.vuosi == verrattava.vuosi &amp;&amp; this.kuukausi &lt; verrattava.kuukausi) {
                return true;
            }

            // vuodet ja kuukaudet samoja, verrataan päivää
            if (this.vuosi == verrattava.vuosi &amp;&amp; this.kuukausi == verrattava.kuukausi &amp;&amp;
                this.paiva &lt; verrattava.paiva) {
                return true;
            }

            return false;
        }
    }
  <% end %>

  <p>
    Tässä tehtäväsarjassa laajennetaan luokkaa.
  </p>

  
  <h2>Seuraava päivä</h2>

  <p>
    Toteuta metodi <code>public void etene()</code>, joka siirtää päiväystä yhdellä päivällä. Tässä tehtävässä oletetaan, että jokaisessa kuukaudessa on 30 päivää. Huom! Sinun tulee <em>tietyissä</em> tilanteissa muuttaa kuukauden ja vuoden arvoa.
  </p>

  
  <h2>Tietty määrä päiviä eteenpäin</h2>

  <p>
    Toteuta metodi <code>public void etene(int montakoPaivaa)</code>, joka siirtää päiväystä annetun päivien määrän verran. Käytä apuna edellisessä tehtävässä toteutettua metodia <code>etene()</code>.
  </p>

  
  <h2>Ajan kuluminen</h2>

  <p>
    Lisätään <code>Paivays</code>-olioon mahdollisuus edistää aikaa. Tee oliolle metodi <code>Paivays paivienPaasta(int paivia)</code>, joka luo <strong>uuden</strong> <code>Paivays</code>-olion, jonka päiväys on annetun päivien lukumäärän verran suurempi kuin oliolla, jolle sitä kutsuttiin. Voit edelleen olettaa, että jokaisessa kuukaudessa on 30 päivää. Huomaa, että vanhan päiväysolion on pysyttävä muuttumattomana!
  </p>

  <p>
    Koska metodissa on luotava <strong>uusi olio</strong>, tulee rungon olla suunnilleen seuraavanlainen:
  </p>

  <% partial 'partials/code_highlight' do %>
    public Paivays paivienPaasta(int paivia) {
        Paivays uusiPaivays = new Paivays( ... );

        // tehdään jotain...

        return uusiPaivays;
    }
  <% end %>

  <p>
    Ohessa on esimerkki metodin toiminnasta.
  </p>

  <% partial 'partials/code_highlight' do %>
    public static void main(String[] args) {
        Paivays pvm = new Paivays(13, 2, 2015);
        System.out.println("Tarkistellun viikon perjantai on " + pvm);

        Paivays uusiPvm = pvm.paivienPaasta(7);
        int vk = 1;
        while (vk &lt;= 7) {
            System.out.println("Perjantai " + vk + " viikon kuluttua on " + uusiPvm);
            uusiPvm = uusiPvm.paivienPaasta(7);

            vk++;
        }


        System.out.println("Päivämäärä 790:n päivän päästä tarkistellusta perjantaista on ... kokeile itse!");
        //    System.out.println("Kokeile " + pvm.paivienPaasta(790));
    }
  <% end %>

  <p>
    Ohjelma tulostaa:
  </p>

  <% partial 'partials/sample_output' do %>
    Tarkistellun viikon perjantai on 13.2.2015
    Perjantai 1 viikon kuluttua on 20.2.2015
    Perjantai 2 viikon kuluttua on 27.2.2015
    Perjantai 3 viikon kuluttua on 4.3.2015
    Perjantai 4 viikon kuluttua on 11.3.2015
    Perjantai 5 viikon kuluttua on 18.3.2015
    Perjantai 6 viikon kuluttua on 25.3.2015
    Perjantai 7 viikon kuluttua on 2.4.2015
    Päivämäärä 790:n päivän päästä tarkistellusta perjantaista on ... kokeile itse!
  <% end %>

  <p>
    <strong>Huom!</strong> Sen sijaan, että muuttaisimme vanhan olion tilaa palautamme uuden olion. Kuvitellaan, että <code>Paivays</code>-luokalle on olemassa metodi <code>edista</code>, joka toimii vastaavasti kuin ohjelmoimamme metodi, mutta se muuttaa vanhan olion tilaa. Tällöin seuraava koodin pätkä tuottaisi ongelmia.
  </p>

  <% partial 'partials/code_highlight' do %>
    Paivays nyt = new Paivays(13, 2, 2015);
    Paivays viikonPaasta = nyt;
    viikonPaasta.edista(7);

    System.out.println("Nyt: " + nyt);
    System.out.println("Viikon päästä: " + viikonPaasta);
  <% end %>

  <p>
    Ohjelman tulostus olisi seuraavanlainen:
  </p>

  <% partial 'partials/sample_output' do %>
    Nyt 20.2.2015
    Viikon päästä 20.2.2015
  <% end %>

  <p>
    Tämä johtuu siitä, että tavallinen sijoitus kopioi ainoastaan viitteen olioon. Siis itse asiassa ohjelman oliot <code>nyt</code> ja <code>viikonPaasta</code> viittavaat <strong>yhteen ja samaan</strong> <code>Paivays</code>-olioon.
  </p>
  
<% end %>



<% partial 'partials/exercise', locals: { name: 'Raha (3 osaa)' } do %>

  <p>
    Maksukortti-tehtävässä käytimme rahamäärän tallettamiseen double-tyyppistä oliomuuttujaa. Todellisissa sovelluksissa näin ei kannata tehdä, sillä kuten jo olemme nähneet, doubleilla laskenta ei ole tarkkaa. Onkin järkevämpää toteuttaa rahamäärän käsittely oman luokkansa avulla. Seuraavassa on luokan runko:
  </p>

  <% partial 'partials/code_highlight' do %>
    public class Raha {

        private final int euroa;
        private final int senttia;

        public Raha(int euroa, int senttia) {
            this.euroa = euroa;
            this.senttia = senttia;
        }

        public int eurot() {
            return euroa;
        }

        public int sentit() {
            return senttia;
        }

        public String toString() {
            String nolla = "";
            if (senttia &lt;= 10) {
                nolla = "0";
            }

            return euroa + "." + nolla + senttia + "e";
        }
    }
  <% end %>

  <p>
    Määrittelyssä pistää silmään oliomuuttujien määrittelyn yhteydessä käytetty sana <code>final</code>, tällä saadaan aikaan se, että oliomuuttujien arvoa ei pystytä muuttamaan sen jälkeen kun ne on konstruktorissa asetettu. Raha-luokan oliot ovatkin muuttumattomia eli <em>immutaabeleita</em>, eli jos halutaan esim. kasvattaa rahamäärää, on luotava uusi olio, joka kuvaa kasvatettua rahasummaa.
  </p>

  <p>
    Luomme seuraavassa muutaman operaation rahojen käsittelyyn.
  </p>


  <h2>Plus</h2>

  <p>
    Tee ensin metodi <code>public Raha plus(Raha lisattava)</code>, joka palauttaa uuden raha-olion, joka on arvoltaan yhtä suuri kuin se olio jolle metodia kutsuttiin ja parametrina oleva olio yhteensä.
  </p>

  <p>
    Metodin runko on seuraavanlainen:
  </p>

  <% partial 'partials/code_highlight' do %>
    public Raha plus(Raha lisattava) {
        Raha uusi = new Raha(...); // luodaan uusi Raha-olio jolla on oikea arvo

        // palautetaan uusi Raha-olio
        return uusi;
    }
  <% end %>

  <p>
    Seuraavassa esimerkkejä metodin toiminnasta
  </p>

  <% partial 'partials/code_highlight' do %>
    Raha a = new Raha(10,0);
    Raha b = new Raha(5,0);

    Raha c = a.plus(b);

    System.out.println(a);  // 10.00e
    System.out.println(b);  // 5.00e
    System.out.println(c);  // 15.00e

    a = a.plus(c);          // HUOM: tässä syntyy uusi Raha-olio, joka laitataan "a:n langan päähän"
    //       vanha a:n langan päässä ollut 10 euroa häviää ja Javan roskien kerääjä korjaa sen pois

    System.out.println(a);  // 25.00e
    System.out.println(b);  // 5.00e
    System.out.println(c);  // 15.00e
  <% end %>

  
  <h2>Vähemmän</h2>

  <p>
    Tee metodi <code>public boolean vahemman(Raha verrattava)</code>, joka palauttaa true jos raha-olio jolle metodia kutsutaan on arvoltaan pienempi kuin raha-olio, joka on metodin parametrina.
  </p>

  <% partial 'partials/code_highlight' do %>
    Raha a = new Raha(10, 0);
    Raha b = new Raha(3, 0);
    Raha c = new Raha(5, 0);

    System.out.println(a.vahemman(b));  // false
    System.out.println(b.vahemman(c));  // true
  <% end %>

  
  <h2>Miinus</h2>

  <p>
    Tee metodi <code>public Raha miinus(Raha vahentaja)</code>, joka palauttaa uuden raha-olion, jonka arvoksi tulee sen olion jolle metodia kutsuttiin ja parametrina olevan olion arvojen erotus. Jos erotus olisi negatiivinen, tulee luotavan raha-olion arvoksi 0.
  </p>

  <p>
    Seuraavassa esimerkkejä metodin toiminnasta
  </p>

  <% partial 'partials/code_highlight' do %>
    Raha a = new Raha(10, 0);
    Raha b = new Raha(3, 50);

    Raha c = a.miinus(b);

    System.out.println(a);  // 10.00e
    System.out.println(b);  // 3.50e
    System.out.println(c);  // 6.50e

    c = c.miinus(a);        // HUOM: tässä syntyy uusi Raha-olio, joka laitataan "c:n langan päähän"
    //       vanha c:n langan päässä ollut 6.5 euroa häviää ja Javan roskien kerääjä korjaa sen pois

    System.out.println(a);  // 10.00e
    System.out.println(b);  // 3.50e
    System.out.println(c);  // 0.00e
  <% end %>

<% end %>





<% partial 'partials/material_heading' do %>
  Crowdsorcerer: Arvioi tehtäviä
<% end %>

<p>
  Otetaan hetkeksi askel taaksepäin ja muistellaan listojen käyttöä. Tämän jälkeen palaamme takaisin olioiden ja listojen pariin. 
</p>

<p>
  Ohjelmointikurssin neljännessä osassa loimme taas omia tehtäviä Crowdsorcererin avulla. Nyt on hetki vertaisarviointiin -- arvioimme Crowdsorcereriin lähetettyjä tehtäviä! Anna vertaispalautetta kahdesta jonkun toisen kurssilaisen lähettämästä tehtävästä ja arvioi lopuksi itse tekemääsi tehtävää. Itse tekemäsi tehtävä näkyy vain jos olet tehnyt sen -- jos et tehnyt tehtävää, pääset arvioimaan yhden ylimääräisen tehtävän.
</p>

<% partial 'partials/hint', locals: { name: 'Vertaisarviointi' } do %>

  <p>
    Alla on kolme Crowdsorcereriin tehtyä tehtävää: kaksi jonkun kurssitoverisi lähettämää ja yksi itsearviointia varten. Niiden yhteydessä on muistin virkistykseksi ohjeistus, jonka pohjalta kyseiset tehtävänannot on tehty.
  </p>

  <p>
    Tarkastele jokaisen tehtävän eri osia: tehtävänantoa, tehtäväpohjaa ja malliratkaisua sekä testaukseen käytettäviä syötteitä ja tulosteita. Arvioi niiden selkeyttä, vaikeutta ja sitä, kuinka hyvin ne vastaavat ohjeistukseensa.
  </p>

  <p>
    Voit vaihtaa näkymää tehtäväpohjan ja mallivastauksen välillä painamalla lähdekoodin yläpalkin painikkeita. Palautteenannon avuksi on annettu väittämiä. Voit valita kuinka samaa mieltä niiden kanssa olet painamalla hymiöitä. Annathan myös sanallista palautetta sille varattuun kenttään! Lisää vielä tehtävää mielestäsi kuvaavia tageja ja paina Lähetä.
  </p>

  <p>
    Anna arvio kummallekin vertaispalautetehtävälle ja lopuksi vielä omallesi.
  </p>

  <p>
    Muista olla reilu ja ystävällinen. Hyvä palaute on rehellistä, mutta kannustavaa!
  </p>

  <p>
    Voit halutessasi ladata arvioitavan tehtävän tehtäväpohjan ja malliratkaisun koneellesi, ja testata niiden käyttöä. Molemmat tulevat ZIP-paketeissa, jolloin sinun täytyy purkaa ne, ennen kuin voit avata ne NetBeansissä.
  </p>

<% end %>


<% partial 'partials/general_callout', locals: { name: 'Suunnittele oma tehtävä: listat' } do %>

  <p>
    Suunnittele tehtävä, joka harjoituttaa listojen käsittelyä ja tietojen hakemista niistä.
  </p>

  <p>
    Tee tehtävään valmiiksi lista tai listoja, jotka sisältävät oman valintasi mukaan joko merkkijonoja, kokonailukuja tai liukulukuja. Täytä listan arvot valmiiksi.
  </p>

  <p>
    Ohjeista tulevaa tehtävän ratkaisijaa kysymään käyttäjältä komentoa, jonka jälkeen listalta haetaan komennon perusteella jotakin tietoa, joka sen jälkeen tuolostetaan. Jos käskyä ei tarjota, tulee ohjelman tulostaa jokin varoitusteksti.
  </p>

  <p>
    Esimerkiksi yksi tälläinen tehtävä voisi sisältää listan kokonaislukuja, ja käskyt voisivat olla: "suurin", "pienin", "keskiarvo". Kun tuleva tehtävän ratkaisija antaa käskyn "keskiarvo", tulee ohjelman tulostaan listan lukujen keskiarvon ja niin edelleen.
  </p>

  <p>
    Muista merkitä ainakin käskyyn reagointiin liittyvät rivit malliratkaisuriveiksi -- näin ratkaisu ei tule suoraan tehtäväpohjaan.
  </p>
  
<% end %>


<div class='crowdsorcerer-widget' data-assignment='7' peer-review data-exercises='3'></div>



<% partial 'partials/material_heading' do %>
  Listat ja oliot
<% end %>

<p>
  Edellisessä osassa tutuksi tulleet listat ovat olioita, joihin pystyy lisäämään arvoja. Listalle lisättyjä arvoja voidaan tarkastella indeksin perusteella, ja listalla olevia arvoja voidaan etsiä ja poistaa. Kaikkia listan tarjoamia toimintoja käytetään listan tarjoamien metodien kautta.
</p>

<p>
  Listalle lisättävien muuttujien tyyppi määrätään listan luomisen yhteydessä annettavan tyyppiparametrin avulla. Esimerkiksi <code>ArrayList&lt;String&gt;</code> sisältää merkkijonoja, <code>ArrayList&lt;Integer&gt;</code> sisältää kokonaislukuja, ja <code>ArrayList&lt;Double&gt;</code> sisältää liukulukuja.
</p>

<p>
  Alla olevassa esimerkissä lisätään ensin merkkijonoja listalle, jonka jälkeen listalla olevat merkkijonot tulostetaan yksitellen.
</p>


<% partial 'partials/code_highlight' do %>
  ArrayList&lt;String&gt; nimet = new ArrayList&lt;&gt;();

  // merkkijono voidaan ensin muuttujaan
  String nimi = "Betty Jennings";
  // ja sitten lisätä se listalle
  nimet.add(nimi);

  // merkkijono voidaan myös lisätä suoraan listalle:
  nimet.add("Betty Snyder");
  nimet.add("Frances Spence");
  nimet.add("Kay McNulty");
  nimet.add("Marlyn Wescoff");
  nimet.add("Ruth Lichterman");

  // listan alkioiden läpikäynti onnistuu useamman erilaisen
  // toistolauseen avulla

  // 1. while-toistolause
  int indeksi = 0;
  while (indeksi &lt; nimet.size()) {
      System.out.println(nimet.get(indeksi));
      indeksi++;
  }

  System.out.println();
  // 2. for-toistolause indeksillä
  for (int i = 0; i &lt; nimet.size(); i++) {
      System.out.println(nimet.get(i));
  }

  System.out.println();
  // 3. for-each toistolause (ei indeksiä)
  for (String nimi: nimet) {
      System.out.println(nimi);
  }
<% end %>

<% partial 'partials/sample_output' do %>
  Betty Jennings
  Betty Snyder
  Frances Spence
  Kay McNulty
  Marlyn Wescoff
  Ruth Lichterman

  Betty Jennings
  Betty Snyder
  Frances Spence
  Kay McNulty
  Marlyn Wescoff
  Ruth Lichterman

  Betty Jennings
  Betty Snyder
  Frances Spence
  Kay McNulty
  Marlyn Wescoff
  Ruth Lichterman
<% end %>


<% partial 'partials/material_sub_heading' do %>
  Olioita listalla
<% end %>

<p>
  Edellisessä osassa lisäsimme listalle muunmuassa merkkijonoja. Merkkijonot ovat olioita, joten ei liene yllätys että listalla voi olla olioita. Tarkastellaan seuraavaksi listan ja olioiden yhteistoimintaa tarkemmin.
</p>

<p>
  Oletetaan, että käytössämme on alla oleva luokka.
</p>


<% partial 'partials/code_highlight' do %>
  public class Henkilo {

      private String nimi;
      private int ika;
      private int paino;
      private int pituus;

      public Henkilo(String nimi) {
          this.nimi = nimi;
          this.ika = 0;
          this.paino = 0;
          this.pituus = 0;
      }

      // muita konstruktoreja ja metodeja

      public String getNimi() {
          return this.nimi;
      }

      public int getIka() {
          return this.ika;
      }

      public void vanhene() {
          this.ika++;
      }

      public void setPituus(int uusiPituus) {
          this.pituus = uusiPituus;
      }

      public void setPaino(int uusiPaino) {
          this.paino = uusiPaino;
      }

      public double painoIndeksi() {
          double pituusPerSata = this.pituus / 100.0;
          return this.paino / (pituusPerSata * pituusPerSata);
      }

      @Override
      public String toString() {
          return this.nimi + ", ikä " + this.ika + " vuotta";
      }
  }
<% end %>

<p>
  Olioiden käsittely listalla ei oikeastaan poikkea aiemmin näkemästämme listan käytöstä millään tavalla. Oleellista on vain listalle lisättävien olioiden tyypin määrittely listan luomisen yhteydessä.
</p>

<p>
  Alla olevassa esimerkissä luodaan ensin Henkilo-tyyppisille olioille tarkoitettu lista, jonka jälkeen listalle lisätään henkilöolioita. Lopulta henkilöoliot tulostetaan yksitellen.
</p>


<% partial 'partials/code_highlight' do %>
  ArrayList&lt;Henkilo&gt; henkilot = new ArrayList&lt;&gt;();

  // henkilöolio voidaan ensin luoda
  Henkilo juhana = new Henkilo("Juhana");
  // ja sitten lisätä se listalle
  henkilot.add(juhana);

  // henkilöolio voidaan myös lisätä listalle "samassa lauseessa"
  henkilot.add(new Henkilo("Matti"));
  henkilot.add(new Henkilo("Martin"));

  for (Henkilo henkilo: henkilot) {
      System.out.println(henkilo);
  }
<% end %>

<% partial 'partials/sample_output' do %>
  Juhana, ikä 0 vuotta
  Matti, ikä 0 vuotta
  Martin, ikä 0 vuotta
<% end %>

<p>
  Aiemmin käyttämämme rakenne syötteiden lukemiseen on yhä varsin käytännöllinen.
</p>

<% partial 'partials/code_highlight' do %>
  Scanner lukija = new Scanner(System.in);
  ArrayList&lt;Henkilo&gt; henkilot = new ArrayList&lt;&gt;();

  while (true) {
      System.out.print("Kirjoita nimi, tyhjä lopettaa: ");
      String nimi = lukija.nextLine();
      if (nimi.isEmpty()) {
          break;
      }

      henkilot.add(new Henkilo(nimi));
  }

  System.out.println();
  System.out.println("Henkilöitä yhteensä: " + henkilot.size());
  System.out.println("Henkilöt: ");
  
  for (Henkilo henkilo: henkilot) {
      System.out.println(henkilo);
  }
<% end %>

<p>
  Listalla olevia olioita voidaan myös tarkastella listan läpikäynnin yhteydessä. Alla olevassa esimerkissä tulostetaan vain täysi-ikäiset henkilöt.
</p>

<% partial 'partials/code_highlight' do %>
  // ..


  for (Henkilo henkilo: henkilot) {
      if (henkilo.getIka() &gt;= 18) {
          System.out.println(henkilo);
      }
  }
<% end %>

<p>
  Ikärajan voi kysyä myös käyttäjältä.
</p>

<% partial 'partials/code_highlight' do %>
  // ..
  System.out.print("Mikä ikäraja? ");
  int ikaraja = Integer.parseInt(lukija.nextLine());

  for (Henkilo henkilo: henkilot) {
      if (henkilo.getIka() &gt;= ikaraja) {
          System.out.println(henkilo);
      }
  }
<% end %>



<% partial 'partials/exercise', locals: { name: 'Televisio-ohjelmat' } do %>

  <p>
    Tehtäväpohjassa on valmiina televisio-ohjelmaa kuvaava luokka Ohjelma. Luokalla Ohjelma on oliomuuttujat nimi ja pituus, konstruktori, ja muutamia metodeja.
  </p>

  <p>
    Toteuta ohjelma, joka ensin lukee käyttäjältä televisio-ohjelmia. Kun käyttäjä syöttää tyhjän ohjelman nimen, televisio-ohjelmien lukeminen lopetetaan.
  </p>

  <p>
    Tämän jälkeen käyttäjältä kysytään ohjelman maksimipituutta. Kun käyttäjä on syöttänyt ohjelman maksimipituuden, tulostetaan kaikki ne ohjelmat, joiden pituus on pienempi tai yhtäsuuri kuin haluttu maksimipituus.
  </p>

  <% partial 'partials/sample_output' do %>
    Nimi: <font color="red">Salatut elämät</font>
    Pituus: <font color="red">30</font>
    Nimi: <font color="red">Miehen puolikkaat</font>
    Pituus: <font color="red">30</font>
    Nimi: <font color="red">Remppa vai muutto</font>
    Pituus: <font color="red">60</font>
    Nimi: <font color="red">House</font>
    Pituus: <font color="red">60</font>

    Ohjelman maksimipituus? <font color="red">30</font>
    Salatut elämät, 30 minuuttia
    Miehen puolikkaat, 30 minuuttia
  <% end %>

<% end %>


<% partial 'partials/exercise', locals: { name: 'Kirjat (2 osaa)' } do %>

  <p>
    Toteuta ohjelma, joka ensin lukee kirjojen tietoja käyttäjältä. Jokaisesta kirjasta tulee lukea kirjan nimi, sivujen lukumäärä sekä kirjoitusvuosi. Kirjojen lukeminen lopetetaan kun käyttäjä syöttää tyhjän kirjan nimen.
  </p>

  <p>
    Tämän jälkeen käyttäjältä kysytään mitä tulostetaan. Jos käyttäjä syöttää merkkijonon "kaikki", tulostetaan kirjojen nimet, sivujen lukumäärät sekä kirjoitusvuodet. Jos taas käyttäjä syöttää merkkijonon "nimi", tulostetaan vain kirjojen nimet.
  </p>

  <p>
    Ohjelmaa varten kannattanee toteuttaa Kirjaa kuvaava luokka. Vaikka tehtävässä on todellisuudessa vain yksi osa, on se kahden osan arvoinen.
  </p>

  <% partial 'partials/sample_output' do %>
    Nimi: <font color="red">Minä en sitten muutu</font>
    Sivuja: <font color="red">201</font>
    Kirjoitusvuosi: <font color="red">2010</font>
    Nimi: <font color="red">Nalle Puh ja elämisen taito</font>
    Sivuja: <font color="red">100</font>
    Kirjoitusvuosi: <font color="red">2005</font>
    Nimi: <font color="red">Beautiful Code</font>
    Sivuja: <font color="red">593</font>
    Kirjoitusvuosi: <font color="red">2007</font>
    Nimi: <font color="red">KonMari</font>
    Sivuja: <font color="red">222</font>
    Kirjoitusvuosi: <font color="red">2011</font>

    Mitä tulostetaan? <font color="red">kaikki</font>
    Minä en sitten muutu, 201 sivua, 2010
    Nalle Puh ja elämisen taito, 100 sivua, 2005
    Beautiful Code, 593 sivua, 2007
    KonMari, 222 sivua, 2011
  <% end %>

  <% partial 'partials/sample_output' do %>
    Nimi: <font color="red">Minä en sitten muutu</font>
    Sivuja: <font color="red">201</font>
    Kirjoitusvuosi: <font color="red">2010</font>
    Nimi: <font color="red">Nalle Puh ja elämisen taito</font>
    Sivuja: <font color="red">100</font>
    Kirjoitusvuosi: <font color="red">2005</font>
    Nimi: <font color="red">Beautiful Code</font>
    Sivuja: <font color="red">593</font>
    Kirjoitusvuosi: <font color="red">2007</font>
    Nimi: <font color="red">KonMari</font>
    Sivuja: <font color="red">222</font>
    Kirjoitusvuosi: <font color="red">2011</font>

    Mitä tulostetaan? <font color="red">nimi</font>
    Minä en sitten muutu
    Nalle Puh ja elämisen taito
    Beautiful Code
    KonMari
  <% end %>
<% end %>




<% partial 'partials/material_sub_heading' do %>
  Listakin sisältää viitteitä
<% end %>

<p>
  Kun olio lisätään listalle, listalle kopioidaan viite. Kuten aiemmin, olion sisäisestä tilasta ei luoda kopiota, vaan listalle lisätään viite olemassa olevaan olioon.
</p>

<p>
  Alla olevassa esimerkissä luodaan ensin olio <code>juhana</code>, joka lisätään listalle. Tämän jälkeen listalle lisätään kaksi muuta oliota. Seuraavaksi <code>juhana</code>-olion metodia <code>vanhene</code> kutsutaan. Lopulta jokaista listalla olevaa oliota vanhennetaan.
</p>

<% partial 'partials/code_highlight' do %>
  ArrayList&lt;Henkilo&gt; henkilot = new ArrayList&lt;&gt;();

  Henkilo juhana = new Henkilo("Juhana");
  henkilot.add(juhana);

  henkilot.add(new Henkilo("Matti"));
  henkilot.add(new Henkilo("Martin"));

  // juhana vanhenee 2 vuotta
  juhana.vanhene();
  juhana.vanhene();

  for (Henkilo henkilo: henkilot) {
      henkilo.vanhene();
  }

  for (Henkilo henkilo: henkilot) {
      System.out.println(henkilo);
  }
<% end %>

<% partial 'partials/sample_output' do %>
  Juhana, ikä 3 vuotta
  Matti, ikä 1 vuotta
  Martin, ikä 1 vuotta
<% end %>

<p>
  Listalle on kopioituna viitteet olioihin. Yllä olevassa esimerkissä muuttujan <code>juhana</code> arvona on sama viite kuin listalla, joten "Juhanan" ikä muuttuu myös jos hän vanhenee listan ulkopuolella.
</p>

<img src="/img/drawings/henkilot-ja-juhana.png"/>

<p>
  &nbsp;
</p>


<% partial 'partials/material_sub_heading' do %>
  Lista oliomuuttujana
<% end %>

<p>
  Listat ovat olioita, joten oliomuuttujaksi voi asettaa listan. Tarkastellaan tätä seuraavaksi.
</p>

<p>
  Olemme aiemmin huomanneet, että listat ovat esimerkiksi näppäriä silloin, silloin kun haluamme pitää kirjaa useammasta erillisestä asiasta. Alla olevassa esimerkissä käsitteelle soittolista on luotu luokka. Soittolista sisältää kappaleita.
</p>

<% partial 'partials/code_highlight' do %>
  // importit

  public class Soittolista {
      private ArrayList&lt;String&gt; kappaleet;

      public Soittolista() {
          this.kappaleet = new ArrayList&lt;&gt;();
      }

      public void lisaaKappale(String kappale) {
          this.kappaleet.add(kappale);
      }

      public void poistaKappale(String kappale) {
          this.kappaleet.remove(kappale);
      }

      public void tulostaKappaleet() {
          for (String kappale: this.kappaleet) {
              System.out.println(kappale);
          }
      }
  }
<% end %>

<p>
  Soittolistojen luominen on edellisen luokan avulla helppoa.
</p>

<% partial 'partials/code_highlight' do %>
  Soittolista lista = new Soittolista();
  lista.lisaaKappale("Sorateiden kuningas");
  lista.lisaaKappale("Teuvo, maanteiden kuningas");
  lista.tulostaKappaleet();
<% end %>

<% partial 'partials/sample_output' do %>
  Sorateiden kuningas
  Teuvo, maanteiden kuningas
<% end %>


<% partial 'partials/exercise', locals: { name: 'Ruokalista (3 osaa)' } do %>

  <p>
    Kumpulan kampuksella Helsingissä toimivaan Unicafe-nimiseen gourmet-ravintolaan tarvitaan uusi ruokalista. Keittiömestari tietää ohjelmoinnista, ja haluaa listan hallinnointiin tietokonejärjestelmän. Toteutetaan tässä tehtävässä järjestelmän sydän, luokka Ruokalista.
  </p>

  <p>
    Tehtäväpohjan mukana tulee <code>Main</code>-luokka, jossa voit testata ruokalistan toimintaa. Ruokalistan toteuttamista varten saat seuraavanlaisen tehtäväpohjan:
  </p>

  <% partial 'partials/code_highlight' do %>
    import java.util.ArrayList;

    public class Ruokalista {

        private ArrayList&lt;String&gt; ateriat;

        public Ruokalista() {
            this.ateriat = new ArrayList&lt;&gt;();
        }

        // toteuta tänne tarvittavat metodit
    }
  <% end %>

  <p>
    Ruokalistaoliolla on oliomuuttujana ArrayList, jonka on tarkoitus tallentaa ruokalistalla olevien ruokalajien nimet. Ruokalistan tulee tarjota seuraavat metodit:
  </p>

  <ul>
    <li>
      <code>public void lisaaAteria(String ateria)</code> lisää aterian ruokalistalle.
    </li>
    <li>
      <code>public void tulostaAteriat()</code> tulostaa ateriat.
    </li>
    <li>
      <code>public void tyhjennaRuokalista()</code> tyhjentää ruokalistan.
    </li>    
  </ul>


  <h2>Aterian lisääminen</h2>

  <p>
    Toteuta metodi <code>public void lisaaAteria(String ateria)</code>, joka lisää uuden aterian listalle <code>ateriat</code>. Jos lisättävä ateria on jo listalla, sitä ei tule lisätä uudelleen. Jos et muista miten listalla olemassaoloa tarkastellaan, lue edellisestä osasta kohta "Onko listalla".
  </p>


  <h2>Aterioiden tulostaminen</h2>

  <p>
    Toteuta metodi <code>public void tulostaAteriat()</code>, joka tulostaa ateriat. Kolmen aterian lisäyksen jälkeen tulostuksen tulee olla seuraavanlainen.
  </p>

  <% partial 'partials/sample_output' do %>
    ensimmäisenä lisätty ateria
    toisena lisätty ateria
    kolmantena lisätty ateria
  <% end %>


  <h2>Ruokalistan tyhjentäminen</h2>

  <p>
    Toteuta metodi <code>public void tyhjennaRuokalista()</code> joka tyhjentää ruokalistan. <code>ArrayList</code>-luokalla on metodi josta on tässä hyötyä. NetBeans osaa vihjata käytettävissä olevista metodeista kun kirjoitat olion nimen ja pisteen. Yritä kirjoittaa <code>ateriat.</code> metodirungon sisällä ja katso mitä käy.
  </p>

<% end %>


<p>
  Oliomuuttujana oleva lista voi sisältää myös muunlaisia olioita. Laajennetaan neljännessä osassa hahmoteltua luokkaa <code>PainonvartijaYhdistys</code> siten, että yhdistys lisää kaikki jäsenensä listalle. Laajennetussa versiossa konstruktorille annetaan alimman painoindeksin lisäksi myös nimi:
</p>

<% partial 'partials/code_highlight' do %>
  public class PainonvartijaYhdistys {
      private double alinPainoindeksi;
      private String nimi;
      private ArrayList&lt;Henkilo&gt; jasenet;

      public PainonvartijaYhdistys(String nimi, double alinPainoindeksi) {
          this.alinPainoindeksi = alinPainoindeksi;
          this.nimi = nimi;
          this.jasenet = new ArrayList&lt;&gt;();
      }

      //..
  }
<% end %>

<p>
  Tehdään metodi jolla henkilö liitetään yhdistykseen. Metodi ei liitä yhdistykseen kuin tarpeeksi suuren painoindeksin omaavat henkilöt. Tehdään myös toString jossa tulostetaan jäsenten nimet:
</p>

<% partial 'partials/code_highlight' do %>
  public class PainonvartijaYhdistys {
      // ...

      public boolean hyvaksytaanJaseneksi(Henkilo henkilo) {
          if (henkilo.painoIndeksi() &lt; this.alinPainoindeksi) {
              return false;
          }

          return true;
      }

      public void lisaaJaseneksi(Henkilo henkilo) {
          // sama kuin hyvaksytaanJaseneksi(henkilo) == false
          if (!hyvaksytaanJaseneksi(henkilo)) {
              // void-tyyppisistä metodeista voi palata
              // return-kutsulla
              return;
          }

          this.jasenet.add(henkilo);
      }

      public String toString() {
          String jasenetMerkkijonona = "";

          for (Henkilo jasen: this.jasenet) {
              jasenetMerkkijonona += "  " + jasen.getNimi() + "\n";
          }

          return "Painonvartijayhdistys " + this.nimi + " jäsenet: \n" + jasenetMerkkijonona;
      }
  }
<% end %>

<p>
  Metodi <code>lisaaJaseneksi</code> käyttää aiemmin tehtyä metodia <code>hyvaksytaanJaseneksi</code>.
</p>

<p>
  Kokeillaan laajentunutta painonvartijayhdistystä:
</p>

<% partial 'partials/code_highlight' do %>
  PainonvartijaYhdistys painonVartija = new PainonvartijaYhdistys("Kumpulan paino", 25);

  Henkilo matti = new Henkilo("Matti");
  matti.setPaino(86);
  matti.setPituus(180);
  painonVartija.lisaaJaseneksi(matti);

  Henkilo juhana = new Henkilo("Juhana");
  juhana.setPaino(64);
  juhana.setPituus(172);
  painonVartija.lisaaJaseneksi(juhana);

  Henkilo harri = new Henkilo("Harri");
  harri.setPaino(104);
  harri.setPituus(182);
  painonVartija.lisaaJaseneksi(harri);

  Henkilo petri = new Henkilo("Petri");
  petri.setPaino(112);
  petri.setPituus(173);
  painonVartija.lisaaJaseneksi(petri);

  System.out.println(painonVartija);
<% end %>

<p>
  Tulostuksesta huomaamme, että Juhanaa ei kelpuutettu jäseneksi:
</p>

<% partial 'partials/sample_output' do %>
  Painonvartijayhdistys Kumpulan paino jäsenet:
  Matti
  Harri
  Petri
<% end %>


<div class="parqu-exercise" data-id="21" data-name="Arraylist oliona"></div>

<!-- CAST4 -->

<a href="http://www.youtube.com/watch?feature=player_embedded&v=Rut2pt5ztN0" height="300" target="_blank" rel="noopener"><img src=" https://www.cs.helsinki.fi/group/java/k13/ohpe/img/youtube.jpg"/></a>

<p>
  &nbsp;
</p>

<p>
  Tehdään vielä lopuksi painovartijayhdistykselle metodi, jolla saadaan tietoon yhdistyksen suurimman painoindeksin omaava henkilö.
</p>

<% partial 'partials/code_highlight' do %>
  public class PainonvartijaYhdistys {
      // ...

      public Henkilo suurinPainoindeksinen() {
          // jos jasenlista on tyhjä, palautetaan null-viite
          if (this.jasenet.isEmpty()) {
              return null;
          }

          Henkilo painavinTahanAsti = this.jasenet.get(0);

          // Huom! Aloitamme tässä läpikäynnin ensimmäisestä
          // listan alkiosta (ei nollannesta)
          // -- tähän for-each -toisto ei sovi
              
          int indeksi = 1;
          while (indeksi < this.jasenet.size()) {
              Henkilo henkilo = this.jasenet.get(indeksi);
              if (henkilo.painoIndeksi() &gt; painavinTahanAsti.painoIndeksi()) {
                  painavinTahanAsti = henkilo;
              }

              indeksi++;
          }

          // tai:
          for (int i = 1; i < this.jasenet.size; i++)
              Henkilo henkilo = this.jasenet.get(indeksi);
              if (henkilo.painoIndeksi() &gt; painavinTahanAsti.painoIndeksi()) {
                  painavinTahanAsti = henkilo;
              }
          }

          return painavinTahanAsti;
      }
  }
<% end %>

<p>
  Logiikaltaan edeltävä metodi toimii samaan tapaan kuin suurimman luvun etsiminen taulukosta. Käytössä on apumuuttuja <code>painavinTahanAsti</code> joka laitetaan aluksi viittaamaan listan ensimmäiseen henkilöön. Sen jälkeen käydään lista läpi ja katsotaan tuleeko vastaan suuremman painoindeksin omaavia henkilöitä, jos tulee, niin otetaan viite talteen muuttujaan <code>painavinTahanAsti</code>. Lopuksi palautetaan muuttujan arvo eli viite henkilöolioon.
</p>

<p>
  Tehdään lisäys edelliseen pääohjelmaan. Pääohjelma ottaa vastaan metodin palauttaman viitteen muuttujaan <code>painavin</code>.
</p>

<% partial 'partials/code_highlight' do %>
  PainonvartijaYhdistys painonVartija = new PainonvartijaYhdistys("Kumpulan paino", 25);

  // .. lisätään listalle ..

  Henkilo painavin = painonVartija.suurinPainoindeksinen();
  System.out.print("suurin painoindeksi on jäsenellä " + painavin.getNimi());
<% end %>

<% partial 'partials/sample_output' do %>
  suurin painoindeksi on jäsenellä Petri
<% end %>


<% partial 'partials/exercise', locals: { name: 'Puhelinmuistio (3 osaa)' } do %>

  <p>
    Tehtävässä tehdään puhelinmuistio.
  </p>

  <h2>Henkilö</h2>

  <p>
    Tee ensin luokka <code>Henkilo</code>. Luokan tulee toimia seuraavan esimerkin osoittamalla tavalla:
  </p>

  <% partial 'partials/code_highlight' do %>
    Henkilo pekka = new Henkilo("Pekka Mikkola", "040-123123");

    System.out.println(pekka.getNimi());
    System.out.println(pekka.getNumero());

    System.out.println(pekka);

    pekka.vaihdaNumeroa("050-333444");
    System.out.println(pekka);
  <% end %>

  <p>
    Tulostuu:
  </p>

  <% partial 'partials/sample_output' do %>
    Pekka Mikkola
    040-123123
    Pekka Mikkola  puh: 040-123123
    Pekka Mikkola  puh: 050-333444
  <% end %>

  <p>
    Tee siis luokalle
  </p>

  <ul>
    <li> metodi <code>public String toString()</code>, joka palauttaa henkilön merkkijonoesityksen (yo. esimerkin tapaan muotoiltuna)</li>
    <li> konstruktori, jolla asetetaan henkilölle nimi ja puhelinnumero</li>
    <li> <code>public String getNimi()</code>, joka palauttaa nimen</li>
    <li> <code>public String getNumero()</code>, joka palauttaa puhelinnumeron</li>
    <li> metodi <code>public void vaihdaNumeroa(String uusiNumero)</code>, joka muuttaa henkilön puhelinnumeroa</li>
  </ul>

  
  <h2>Henkilöiden lisäys puhelinmuistioon</h2>

  <p>
    Tee luokka <code>Puhelinmuistio</code> joka tallettaa sisällään olevaan ArrayListiin <code>Henkilo</code>-olioita. Tässä vaiheessa luokalle tehdään seuraavat metodit:
  </p>

  <ul>
    <li> <code>public void lisaa(String nimi, String numero)</code> luo <code>Henkilo</code>-olion ja lisää sen puhelinmuistion ArrayListiin.</li>
    <li><code>public void tulostaKaikki()</code>, tulostaa puhelinmuistion sisällön</li>
  </ul>

  <p>
    Esimerkki muistion toiminnasta:
  </p>

  <% partial 'partials/code_highlight' do %>
    Puhelinmuistio muistio = new Puhelinmuistio();

    muistio.lisaa("Pekka Mikkola", "040-123123");
    muistio.lisaa("Antti Laaksonen", "045-456123");
    muistio.lisaa("Juhana Laurinharju", "050-222333");

    muistio.tulostaKaikki();
  <% end %>

  <p>
    Ohjelman tulostus oikein toteutetuilla luokilla on:
  </p>

  <% partial 'partials/sample_output' do %>
    Pekka Mikkola  puh: 040-123123
    Antti Laaksonen  puh: 045-456123
    Juhana Laurinharju  puh: 050-222333
  <% end %>

  
  <h2>Numerojen haku muistiosta</h2>

  <p>
    Tehdään puhelinmuistiolle metodi <code>public String haeNumero(String nimi)</code>, joka  palauttaa parametrina annetun henkilön numeron. Jos henkilö ei ole muistiossa, palautetaan merkkijono "numero ei tiedossa". Esimerkki metodin toiminnasta:
  </p>

  <% partial 'partials/code_highlight' do %>
    Puhelinmuistio muistio = new Puhelinmuistio();
    muistio.lisaa("Pekka Mikkola", "040-123123");
    muistio.lisaa("Antti Laaksonen", "045-456123");
    muistio.lisaa("Juhana Laurinharju", "050-222333");

    String numero = muistio.haeNumero("Pekka Mikkola");
    System.out.println(numero);

    numero = muistio.haeNumero("Martti Tienari");
    System.out.println(numero);
  <% end %>

  <p>
    Tulostuu:
  </p>

  <% partial 'partials/sample_output' do %>
    040-123123
    numero ei tiedossa
  <% end %>
  
<% end %>


<% partial 'partials/exercise', locals: { name: 'Lahjapakkaamo (2 osaa)' } do %>


  <p>
    Tässä tehtävässä harjoitellaan lahjojen pakkaamista. Tehdään luokat <code>Lahja</code> ja <code>Pakkaus</code>. Lahjalla on nimi ja paino, ja Pakkaus sisältää lahjoja.
  </p>

  <h2>Lahja-luokka</h2>

  <p>
    Tee luokka <code>Lahja</code>, josta muodostetut oliot kuvaavat erilaisia lahjoja. Tallennettavat tiedot ovat tavaran nimi ja paino (kg).
  </p>

  <p>
    Lisää luokkaan seuraavat metodit:
  </p>

  <ul>
    <li>Konstruktori, jolle annetaan parametrina lahjan nimi ja paino</li>
    <li>Metodi <code>public String getNimi()</code>, joka palauttaa lahjan nimen</li>
    <li>Metodi <code>public int getPaino()</code>, joka palauttaa lahjan painon</li>
    <li>Metodi <code>public String toString()</code>, joka palauttaa merkkijonon muotoa "nimi (paino kg)"</li>
  </ul>

  <p>
    Seuraavassa on luokan käyttöesimerkki:
  </p>

  <% partial 'partials/code_highlight' do %>
    public class Main {
        public static void main(String[] args) {
            Lahja kirja = new Lahja("Aapiskukko", 2);

            System.out.println("Lahjan nimi: " + kirja.getNimi());
            System.out.println("Lahjan paino: " + kirja.getPaino());

            System.out.println("Lahja: " + kirja);
        }
    }
  <% end %>

  <p>
    Ohjelman tulostuksen tulisi olla seuraava:
  </p>

  <% partial 'partials/sample_output' do %>
    Lahjan nimi: Aapiskukko
    Lahjan paino: 2
    Lahja: Aapiskukko (2 kg)<% end %>


  <h2>Pakkaus-luokka</h2>

  <p>
    Tee luokka <code>Pakkaus</code>. Pakkaus voi sisältää äärettömän määrän lahjoja, jonka lisäksi se tarjoaa metodin lahjojen yhteispainon laskemiseen.
  </p>

  <p>
    Lisää luokkaan seuraavat metodit:
  </p>

  <ul>
    <li> Parametriton konstruktori</li>
    <li> Metodi <code>public void lisaaLahja(Lahja lahja)</code>, joka lisää parametrina annettavan lahjan pakkaukseen. Metodi ei palauta mitään arvoa.</li>
  </ul>

  <p>
    Tavarat kannattaa tallentaa <code>ArrayList</code>-olioon:
  </p>

  <% partial 'partials/code_highlight' do %>
    ArrayList&lt;Lahja&gt; lahjat = new ArrayList&lt;&gt;();
  <% end %>

  <p>
    Seuraavassa on luokan käyttöesimerkki:
  </p>

  <% partial 'partials/code_highlight' do %>
    public class Main {
        public static void main(String[] args) {
            Lahja kirja = new Lahja("Aapiskukko", 2);

            Pakkaus paketti = new Pakkaus();
            paketti.lisaaLahja(kirja);
            System.out.println(paketti.getPaino());
        }
    }
  <% end %>

  <p>
    Ohjelman tulostuksen tulisi olla seuraava:
  </p>

  <% partial 'partials/sample_output' do %>
    2
  <% end %>

<% end %>


<% partial 'partials/exercise', locals: { name: 'Tavara, Matkalaukku ja Lastiruuma (7 osaa)' } do %>

  <p>
    Tässä tehtäväsarjassa tehdään luokat <code>Tavara</code>, <code>Matkalaukku</code> ja <code>Lastiruuma</code>, joiden avulla harjoitellaan lisää olioita, jotka sisältävät toisia olioita.
  </p>

  <h2>Tavara-luokka</h2>

  <p>
    Tee luokka <code>Tavara</code>, josta muodostetut oliot vastaavat erilaisia tavaroita. Tallennettavat tiedot ovat tavaran nimi ja paino (kg).
  </p>

  <p>
    Lisää luokkaan seuraavat metodit:
  </p>

  <ul>
    <li>Konstruktori, jolle annetaan parametrina tavaran nimi ja paino</li>
    <li>Metodi <code>public String getNimi()</code>, joka palauttaa tavaran nimen</li>
    <li>Metodi <code>public int getPaino()</code>, joka palauttaa tavaran painon</li>
    <li>Metodi <code>public String toString()</code>, joka palauttaa merkkijonon muotoa "nimi (paino kg)"</li>
  </ul>

  <p>
    Seuraavassa on luokan käyttöesimerkki:
  </p>

  <% partial 'partials/code_highlight' do %>
    public class Main {
        public static void main(String[] args) {
            Tavara kirja = new Tavara("Aapiskukko", 2);
            Tavara puhelin = new Tavara("Nokia 3210", 1);

            System.out.println("Kirjan nimi: " + kirja.getNimi());
            System.out.println("Kirjan paino: " + kirja.getPaino());

            System.out.println("Kirja: " + kirja);
            System.out.println("Puhelin: " + puhelin);
        }
    }
  <% end %>

  <p>
    Ohjelman tulostuksen tulisi olla seuraava:
  </p>

  <% partial 'partials/sample_output' do %>
    Kirjan nimi: Aapiskukko
    Kirjan paino: 2
    Kirja: Aapiskukko (2 kg)
    Puhelin: Nokia 3210 (1 kg)<% end %>


  <h2>Matkalaukku-luokka</h2>

  <p>
    Tee luokka <code>Matkalaukku</code>. Matkalaukkuun liittyy tavaroita ja maksimipaino, joka määrittelee tavaroiden suurimman mahdollisen yhteispainon.
  </p>

  <p>
    Lisää luokkaan seuraavat metodit:
  </p>

  <ul>
    <li> Konstruktori, jolle annetaan maksimipaino</li>
    <li> Metodi <code>public void lisaaTavara(Tavara tavara)</code>, joka lisää parametrina annettavan tavaran matkalaukkuun. Metodi ei palauta mitään arvoa.</li>
    <li> Metodi <code>public String toString()</code>, joka palauttaa merkkijonon muotoa "x tavaraa (y kg)"</li>
  </ul>

  <p>
    Tavarat kannattaa tallentaa <code>ArrayList</code>-olioon:
  </p>

  <% partial 'partials/code_highlight' do %>
    ArrayList&lt;Tavara&gt; tavarat = new ArrayList&lt;&gt;();
  <% end %>

  <p>
    Luokan <code>Matkalaukku</code> tulee valvoa, että sen sisältämien tavaroiden yhteispaino ei ylitä maksimipainoa. Jos maksimipaino ylittyisi lisättävän tavaran vuoksi, metodi <code>lisaaTavara</code> ei saa lisätä uutta tavaraa laukkuun.
  </p>

  <p>
    Seuraavassa on luokan käyttöesimerkki:
  </p>

  <% partial 'partials/code_highlight' do %>
    public class Main {
        public static void main(String[] args) {
            Tavara kirja = new Tavara("Aapiskukko", 2);
            Tavara puhelin = new Tavara("Nokia 3210", 1);
            Tavara tiiliskivi = new Tavara("tiiliskivi", 4);

            Matkalaukku matkalaukku = new Matkalaukku(5);
            System.out.println(matkalaukku);

            matkalaukku.lisaaTavara(kirja);
            System.out.println(matkalaukku);

            matkalaukku.lisaaTavara(puhelin);
            System.out.println(matkalaukku);

            matkalaukku.lisaaTavara(tiiliskivi);
            System.out.println(matkalaukku);
        }
    }
  <% end %>

  <p>
    Ohjelman tulostuksen tulisi olla seuraava:
  </p>

  <% partial 'partials/sample_output' do %>
    0 tavaraa (0 kg)
    1 tavaraa (2 kg)
    2 tavaraa (3 kg)
    2 tavaraa (3 kg)
  <% end %>


  <h2>Kielenhuoltoa</h2>

  <p>
    Ilmoitukset "0 tavaraa" ja "1 tavaraa" eivät ole kovin hyvää suomea &ndash; paremmat muodot olisivat "ei tavaroita" ja "1 tavara". Tee tämä muutos luokassa <code>Matkalaukku</code> sijaitsevaan toString-metodiin.
  </p>

  <p>
    Nyt edellisen ohjelman tulostuksen tulisi olla seuraava:
  </p>

  <% partial 'partials/sample_output' do %>
    ei tavaroita (0 kg)
    1 tavara (2 kg)
    2 tavaraa (3 kg)
    2 tavaraa (3 kg)
  <% end %>


  <h2>Kaikki tavarat</h2>

  <p>
    Lisää luokkaan <code>Matkalaukku</code> seuraavat metodit:
  </p>

  <ul>
    <li> metodi <code>tulostaTavarat</code>, joka tulostaa kaikki matkalaukussa olevat tavarat</li>
    <li> metodi <code>yhteispaino</code>, joka palauttaa tavaroiden yhteispainon</li>
  </ul>

  <p>
    Seuraavassa on luokan käyttöesimerkki:
  </p>

  <% partial 'partials/code_highlight' do %>
    public class Main {
        public static void main(String[] args) {
            Tavara kirja = new Tavara("Aapiskukko", 2);
            Tavara puhelin = new Tavara("Nokia 3210", 1);
            Tavara tiiliskivi = new Tavara("tiiliskivi", 4);

            Matkalaukku matkalaukku = new Matkalaukku(10);
            matkalaukku.lisaaTavara(kirja);
            matkalaukku.lisaaTavara(puhelin);
            matkalaukku.lisaaTavara(tiiliskivi);

            System.out.println("Matkalaukussa on seuraavat tavarat:");
            matkalaukku.tulostaTavarat();
            System.out.println("Yhteispaino: " + matkalaukku.yhteispaino() + " kg");
        }
    }
  <% end %>

  <p>
    Ohjelman tulostuksen tulisi olla seuraava:
  </p>

  <% partial 'partials/sample_output' do %>
    Matkalaukussa on seuraavat tavarat:
    Aapiskukko (2 kg)
    Nokia 3210 (1 kg)
    Tiiliskivi (4 kg)
    Yhteispaino: 7 kg
  <% end %>

  <p>
    Muokkaa myös luokkaasi siten, että käytät vain kahta oliomuuttujaa. Toinen sisältää maksimipainon, toinen on lista laukussa olevista tavaroista.
  </p>


  <h2>Raskain tavara</h2>

  <p>
    Lisää vielä luokkaan <code>Matkalaukku</code> metodi <code>raskainTavara</code>, joka palauttaa painoltaan suurimman tavaran. Jos yhtä raskaita tavaroita on useita, metodi voi palauttaa minkä tahansa niistä. Metodin tulee palauttaa olioviite. Jos laukku on tyhjä, palauta arvo <em>null</em>.
  </p>

  <p>
    Seuraavassa on luokan käyttöesimerkki:
  </p>

  <% partial 'partials/code_highlight' do %>
    public class Main {
        public static void main(String[] args) {
            Tavara kirja = new Tavara("Aapiskukko", 2);
            Tavara puhelin = new Tavara("Nokia 3210", 1);
            Tavara tiiliskivi = new Tavara("Tiiliskivi", 4);

            Matkalaukku matkalaukku = new Matkalaukku(10);
            matkalaukku.lisaaTavara(kirja);
            matkalaukku.lisaaTavara(puhelin);
            matkalaukku.lisaaTavara(tiiliskivi);

            Tavara raskain = matkalaukku.raskainTavara();
            System.out.println("Raskain tavara: " + raskain);
        }
    }
  <% end %>

  <p>
    Ohjelman tulostuksen tulisi olla seuraava:
  </p>

  <% partial 'partials/sample_output' do %>
    Raskain tavara: Tiiliskivi (4 kg)<% end %>


  <h2>Lastiruuma-luokka</h2>

  <p>
    Tee luokka <code>Lastiruuma</code>, johon liittyvät seuraavat metodit:
  </p>

  <ul>
    <li> konstruktori, jolle annetaan maksimipaino</li>
    <li> metodi <code>public void lisaaMatkalaukku(Matkalaukku laukku)</code>, joka lisää parametrina annetun matkalaukun lastiruumaan</li>
    <li> metodi <code>public String toString()</code>, joka palauttaa merkkijonon muotoa "x matkalaukkua (y kg)"</li>
  </ul>

  <p>
    Tallenna matkalaukut sopivaan <code>ArrayList</code>-rakenteeseen.
  </p>

  <p>
    Luokan <code>Lastiruuma</code> tulee valvoa, että sen sisältämien matkalaukkujen yhteispaino ei ylitä maksimipainoa. Jos maksimipaino ylittyisi uuden matkalaukun vuoksi, metodi <code>lisaaMatkalaukku</code> ei saa lisätä uutta matkalaukkua.
  </p>

  <p>
    Seuraavassa on luokan käyttöesimerkki:
  </p>

  <% partial 'partials/code_highlight' do %>
    public class Main {
        public static void main(String[] args) {
            Tavara kirja = new Tavara("Aapiskukko", 2);
            Tavara puhelin = new Tavara("Nokia 3210", 1);
            Tavara tiiliskivi = new Tavara("tiiliskivi", 4);

            Matkalaukku adanLaukku = new Matkalaukku(10);
            adanLaukku.lisaaTavara(kirja);
            adanLaukku.lisaaTavara(puhelin);

            Matkalaukku pekanLaukku = new Matkalaukku(10);
            pekanLaukku.lisaaTavara(tiiliskivi);

            Lastiruuma lastiruuma = new Lastiruuma(1000);
            lastiruuma.lisaaMatkalaukku(adanLaukku);
            lastiruuma.lisaaMatkalaukku(pekanLaukku);

            System.out.println(lastiruuma);
        }
    }
  <% end %>

  <p>
    Ohjelman tulostuksen tulisi olla seuraava:
  </p>

  <% partial 'partials/sample_output' do %>
    2 matkalaukkua (7 kg)
  <% end %>


  <h2>Lastiruuman sisältö</h2>

  <p>
    Lisää luokkaan <code>Lastiruuma</code> metodi <code>public void tulostaTavarat()</code>, joka tulostaa kaikki lastiruuman matkalaukuissa olevat tavarat.
  </p>

  <p>
    Seuraavassa on luokan käyttöesimerkki:
  </p>

  <% partial 'partials/code_highlight' do %>
    public class Main {
        public static void main(String[] args) {
            Tavara kirja = new Tavara("Aapiskukko", 2);
            Tavara puhelin = new Tavara("Nokia 3210", 1);
            Tavara tiiliskivi = new Tavara("tiiliskivi", 4);

            Matkalaukku adanLaukku = new Matkalaukku(10);
            adanLaukku.lisaaTavara(kirja);
            adanLaukku.lisaaTavara(puhelin);

            Matkalaukku pekanLaukku = new Matkalaukku(10);
            pekanLaukku.lisaaTavara(tiiliskivi);

            Lastiruuma lastiruuma = new Lastiruuma(1000);
            lastiruuma.lisaaMatkalaukku(adanLaukku);
            lastiruuma.lisaaMatkalaukku(pekanLaukku);

            System.out.println("Ruuman matkalaukuissa on seuraavat tavarat:");
            lastiruuma.tulostaTavarat();
        }
    }
  <% end %>

  <p>
    Ohjelman tulostuksen tulisi olla seuraava:
  </p>

  <% partial 'partials/sample_output' do %>
    Ruuman matkalaukuissa on seuraavat tavarat:
    Aapiskukko (2 kg)
    Nokia 3210 (1 kg)
    tiiliskivi (4 kg)
  <% end %>

<% end %>



<% partial 'partials/material_heading' do %>
  Tiedon ryhmittely hajautustaulun avulla
<% end %>


<p>
  Hajautustaulu sisältää korkeintaan yhden arvon yhtä avainta kohti. Seuraavassa esimerkissä tallennamme henkilöiden puhelinnumeroita hajautustauluun.
</p>

<% partial 'partials/code_highlight' do %>
  HashMap&lt;String, String&gt; puhelinnumerot = new HashMap&lt;&gt;();
  puhelinnumerot.put("Pekka", "040-12348765");

  System.out.println("Pekan numero: " + puhelinnumerot.get("Pekka"));

  puhelinnumerot.put("Pekka", "09-111333");

  System.out.println("Pekan numero: " + puhelinnumerot.get("Pekka"));
<% end %>

<% partial 'partials/sample_output' do %>
  Pekan numero: 040-12348765
  Pekan numero: 09-111333
<% end %>


<p>
  Entä jos haluaisimme liittää yhteen avaimeen useita arvoja, eli esimerkiksi useampia puhelinnumeroita yhdelle henkilölle?
</p>

<p>
  Koska hajautustaulun avaimet ja arvot voivat olla mitä tahansa muuttujia, listojen käyttäminen hajautustaulun arvona onnistuu. Useamman arvon lisääminen yhdelle arvolle onnistuu liittämällä avaimeen lista. Muutetaan puhelinnumeroiden talletustapaa seuraavasti:
</p>

<% partial 'partials/code_highlight' do %>
  HashMap&lt;String, ArrayList&lt;String&gt;&gt; puhelinnumerot = new HashMap&lt;&gt;();
<% end %>

<p>
  Nyt hajautustaulussa on jokaiseen avaimeen liitettynä lista. Vaikka new-komento luo hajautustaulun, ei hajautustaulu sisällä alussa yhtäkään listaa. Ne on luotava tarvittaessa erikseen.
</p>

<% partial 'partials/code_highlight' do %>
  HashMap&lt;String, ArrayList&lt;String&gt;&gt; puhelinnumerot = new HashMap&lt;&gt;();

  // liitetään Pekka-nimeen ensin tyhjä ArrayList
  puhelinnumerot.put("Pekka", new ArrayList&lt;&gt;());

  // ja lisätään Pekkaa vastaavalle listalle puhelinnumero
  puhelinnumerot.get("Pekka").add("040-12348765");
  // ja lisätään toinenkin puhelinnumero
  puhelinnumerot.get("Pekka").add("09-111333");

  System.out.println("Pekan numerot: " + puhelinnumerot.get("Pekka"));
<% end %>

<% partial 'partials/sample_output' do %>
  Pekan numero: [040-12348765, 09-111333]
<% end %>

<p>
  Määrittelimme muuttujan puhelinnumero tyypiksi <code>HashMap&lt;String, ArrayList&lt;String&gt;&gt;</code>. Tämä tarkoittaa hajautustaulua, joka käyttää avaimena merkkijonoa ja arvona merkkijonoja sisältävää listaa. Hajautustauluun lisättävät arvot ovat siis konkreettisia listoja.
</p>

<% partial 'partials/code_highlight' do %>
  // liitetään Pekka-nimeen ensin tyhjä ArrayList
  puhelinnumerot.put("Pekka", new  ArrayList&lt;&gt;());

  // ...
<% end %>

<p>
  Vastaavalla tyylillä voi toteuttaa esimerkiksi tehtävien pistekirjanpidon. Alla olevassa esimerkissä on hahmoteltu luokkaa <code>Tehtavakirjanpito</code>, mikä sisältää käyttäjäkohtaisen pistekirjanpidon. Käyttäjä esitetään merkkijonona ja pisteet kokonaislukuina.

<% partial 'partials/code_highlight' do %>
  public class Tehtavakirjanpito {
      private HashMap&lt;String, ArrayList&lt;Integer&gt;&gt; tehdytTehtavat;

      public Tehtavakirjanpito() {
          this.tehdytTehtavat = new HashMap&lt;&gt;();
      }

      public void lisaa(String kayttaja, int tehtava) {
          // uudelle käyttäjälle on lisättävä HashMapiin tyhjä lista jos sitä
          // ei ole jo lisätty
          this.tehdytTehtavat.putIfAbsent(kayttaja, new ArrayList&lt;&gt;());

          // haetaan ensin käyttäjän tehtävät sisältävä lista ja tehdään siihen lisäys
          ArrayList&lt;Integer&gt; tehdyt = this.tehdytTehtavat.get(kayttaja);
          tehdyt.add(tehtava);

          // edellinen olisi onnitunut myös ilman apumuuttujaa seuraavasti
          // this.tehdytTehtavat.get(kayttaja).add(tehtava);
      }

      public void tulosta() {
          for (String nimi: tehdytTehtavat.keySet()) {
              System.out.println(nimi + ": " + tehdytTehtavat.get(nimi));
          }
      }
  }
<% end %>

<% partial 'partials/code_highlight' do %>
  Tehtavakirjanpito kirjanpito = new Tehtavakirjanpito();
  kirjanpito.lisaa("Ada", 3);
  kirjanpito.lisaa("Ada", 4);
  kirjanpito.lisaa("Ada", 3);
  kirjanpito.lisaa("Ada", 3);

  kirjanpito.lisaa("Pekka", 4);
  kirjanpito.lisaa("Pekka", 4);

  kirjanpito.lisaa("Matti", 1);
  kirjanpito.lisaa("Matti", 2);

  kirjanpito.tulosta();
<% end %>

<% partial 'partials/sample_output' do %>
  Matti: [1, 2]
  Pekka: [4, 4]
  Ada: [3, 4, 3, 3]
<% end %>


<% partial 'partials/exercise', locals: { name: 'Usean käännöksen sanakirja' } do %>

  <p>
    Tehtävänäsi on toteuttaa luokka <code>UseanKaannoksenSanakirja</code>, johon voidaan lisätä yksi tai useampi käännös jokaiselle sanalle. Luokan tulee toteuttaa seuraavat metodit:
  </p>

  <ul>
    <li><code>public void lisaa(String sana, String kaannos)</code> lisää käännöksen sanalle säilyttäen vanhat käännökset</li>
    <li><code>public ArrayList&lt;String&gt; kaanna(String sana)</code> palauttaa listan, joka sisältää sanojen käännökset. Jos sanalle ei ole yhtäkään käännöstä, metodin tulee palauttaa tyhjä lista.</li>
    <li><code>public void poista(String sana)</code> poistaa sanan ja sen kaikki käännökset sanakirjasta.</li>
  </ul>

  <p>
    Käännökset kannattanee lisätä <code>HashMap&lt;String, ArrayList&lt;String&gt;&gt;</code>-tyyppiseen oliomuuttujaan.
  </p>

  <p>
    Esimerkki:
  </p>

  <% partial 'partials/code_highlight' do %>
    UseanKaannoksenSanakirja sanakirja = new UseanKaannoksenSanakirja();
    sanakirja.lisaa("kuusi", "six");
    sanakirja.lisaa("kuusi", "spruce");

    sanakirja.lisaa("pii", "silicon");
    sanakirja.lisaa("pii", "pi");

    System.out.println(sanakirja.kaanna("kuusi"));
    sanakirja.poista("pii");
    System.out.println(sanakirja.kaanna("pii"));
  <% end %>

  <% partial 'partials/sample_output' do %>
    [six, spruce]
    []
  <% end %>

<% end %>




<% partial 'partials/material_heading' do %>
  Käyttöliittymän ja sovelluslogiikan eriyttäminen
<% end %>



<% partial 'partials/material_heading' do %>
  Ongelmasta kokonaisuuteen ja takaisin osiin
<% end %>

<p>
  Tarkastellaan erään ohjelman rakennusprosessia sekä tutustutaan sovelluksen vastuualueiden erottamiseen toisistaan. Ohjelma kysyy käyttäjältä sanoja kunnes käyttäjä syöttää saman sanan uudestaan. Ohjelma käyttää listaa sanojen tallentamiseen.
</p>

<% partial 'partials/sample_output' do %>
  Anna sana: <font color="red">porkkana</font>
  Anna sana: <font color="red">selleri</font>
  Anna sana: <font color="red">nauris</font>
  Anna sana: <font color="red">lanttu</font>
  Anna sana: <font color="red">selleri</font>
  Annoit saman sanan uudestaan!
<% end %>

<p>
  Rakennetaan ohjelma osissa. Eräs haasteista on se, että on vaikea päättää miten lähestyä tehtävää, eli miten ongelma tulisi jäsentää osaongelmiksi, ja mistä osaongelmasta kannattaisi aloittaa. Yhtä oikeaa vastausta ei ole -- joskus on hyvä lähteä pohtimaan ongelmaan liittyviä käsitteitä ja niiden yhteyksiä, joskus taas ohjelman tarjoamaa käyttöliittymää.
</p>

<p>
  Käyttöliittymän hahmottelu voisi lähteä liikenteeseen luokasta Kayttoliittyma. Käyttöliittymä käyttää Scanner-oliota, jonka sille voi antaa. Tämän lisäksi käyttöliittymällä on käynnistämiseen tarkoitettu metodi.
</p>

<% partial 'partials/code_highlight' do %>
  public class Kayttoliittyma {
      private Scanner lukija;

      public Kayttoliittyma(Scanner lukija) {
          this.lukija = lukija;
      }

      public void kaynnista() {
          // tehdään jotain
      }
  }
<% end %>

<p>
  Käyttöliittymän luominen ja käynnistäminen onnistuu seuraavasti.
</p>

<% partial 'partials/code_highlight' do %>
  public static void main(String[] args) {
      Scanner lukija = new Scanner(System.in);
      Kayttoliittyma kayttoliittyma = new Kayttoliittyma(lukija);
      kayttoliittyma.kaynnista();
  }
<% end %>


<% partial 'partials/material_sub_heading' do %>
  Toisto ja lopetus
<% end %>

<p>
  Ohjelmassa on (ainakin) kaksi "aliongelmaa". Ensimmäinen on sanojen toistuva lukeminen käyttäjältä kunnes tietty ehto toteutuu. Tämä voitaisiin hahmotella seuraavaan tapaan.
</p>


<% partial 'partials/code_highlight' do %>
  public class Kayttoliittyma {
      private Scanner lukija;

      public Kayttoliittyma(Scanner lukija) {
          this.lukija = lukija;
      }

      public void kaynnista() {

          while (true) {
              System.out.print("Anna sana: ");
              String sana = lukija.nextLine();

              if (<em>pitää lopettaa</em>) {
                  break;
              }

          }

          System.out.println("Annoit saman sanan uudestaan!");
      }
  }
<% end %>

<p>
  Sanojen kysely jatkuu kunnes käyttäjä syöttää jo aiemmin syötetyn sanan. Täydennetään ohjelmaa siten, että se tarkastaa onko sana jo syötetty. Vielä ei tiedetä miten toiminnallisuus kannattaisi tehdä, joten tehdään siitä vasta runko.
</p>

<% partial 'partials/code_highlight' do %>
  public class Kayttoliittyma {
      private Scanner lukija;

      public Kayttoliittyma(Scanner lukija) {
          this.lukija = lukija;
      }

      public void kaynnista() {

          while (true) {
              System.out.print("Anna sana: ");
              String sana = lukija.nextLine();

              if (onJoSyotetty(sana)) {
                  break;
              }

          }

          System.out.println("Annoit saman sanan uudestaan!");
      }

      public boolean onJoSyotetty(String sana) {
          // tänne jotain

          return false;
      }
  }
<% end %>

<p>
  Ohjelmaa on hyvä testata koko ajan, joten tehdään metodista kokeiluversio:
</p>

<% partial 'partials/code_highlight' do %>
  public boolean onJoSyotetty(String sana) {
      if (sana.equals("loppu")) {
          return true;
      }

      return false;
  }
<% end %>

<p>
  Nyt toisto jatkuu niin kauan kunnes syötteenä on sana loppu:
</p>

<% partial 'partials/sample_output' do %>
  Anna sana: <span class="red">porkkana</span>
  Anna sana: <span class="red">selleri</span>
  Anna sana: <span class="red">nauris</span>
  Anna sana: <span class="red">lanttu</span>
  Anna sana: <span class="red">loppu</span>
  Annoit saman sanan uudestaan!
<% end %>

<p>
  Ohjelma ei toimi vielä kokonaisuudessaan, mutta ensimmäinen osaongelma eli ohjelman pysäyttäminen kunnes tietty ehto toteutuu on saatu toimimaan.
</p>

<% partial 'partials/material_sub_heading' do %>
  Oleellisten tietojen tallentaminen
<% end %>

<p>
  Toinen osaongelma on aiemmin syötettyjen sanojen muistaminen. Lista sopii mainiosti tähän tarkoitukseen.
</p>

<% partial 'partials/code_highlight' do %>
  public class Kayttoliittyma {
      private Scanner lukija;
      private ArrayList&lt;String&gt; aiemmatSanat;

      public Kayttoliittyma(Scanner lukija) {
          this.lukija = lukija;
          this.aiemmatSanat = new ArrayList&lt;String&gt;();
      }

      //...
<% end %>

<p>
  Kun uusi sana syötetään, on se lisättävä syötettyjen sanojen joukkoon. Tämä tapahtuu lisäämällä while-silmukkaan listan sisältöä päivittävä rivi:
</p>

<% partial 'partials/code_highlight' do %>
  while (true) {
      System.out.print("Anna sana: ");
      String sana = lukija.nextLine();

      if (onJoSyotetty(sana)) {
          break;
      }

      // lisätään uusi sana aiempien sanojen listaan
      this.aiemmatSanat.add(sana);
  }
<% end %>

<p>
  Kayttoliittyma näyttää kokonaisuudessaan seuraavalta.
</p>

<% partial 'partials/code_highlight' do %>
  public class Kayttoliittyma {
      private Scanner lukija;
      private ArrayList&lt;String&gt; aiemmatSanat;

      public Kayttoliittyma(Scanner lukija) {
          this.lukija = lukija;
          this.aiemmatSanat = new ArrayList&lt;String&gt;();
      }

      public void kaynnista() {

          while (true) {
              System.out.print("Anna sana: ");
              String sana = lukija.nextLine();

              if (onJoSyotetty(sana)) {
                  break;
              }

              // lisätään uusi sana aiempien sanojen listaan
              this.aiemmatSanat.add(sana);
          }

          System.out.println("Annoit saman sanan uudestaan!");
      }

      public boolean onJoSyotetty(String sana) {
          if (sana.equals("loppu")) {
              return true;
          }

          return false;
      }
  }
<% end %>

<p>
  Jälleen kannattaa testata, että ohjelma toimii edelleen. Voi olla hyödyksi esimerkiksi lisätä kaynnista-metodin loppuun testitulostus, joka varmistaa että syötetyt sanat todella menivät listaan.
</p>

<% partial 'partials/code_highlight' do %>
  // testitulostus joka varmistaa että kaikki toimii edelleen
  for(String sana: this.aiemmatSanat) {
      System.out.println(sana);
  }
<% end %>

<% partial 'partials/material_sub_heading' do %>
  Osaongelmien ratkaisujen yhdistäminen
<% end %>

<p>
  Muokataan vielä äsken tekemämme metodi <code>onJoSyotetty</code> tutkimaan onko kysytty sana jo syötettyjen joukossa, eli listassa.
</p>

<% partial 'partials/code_highlight' do %>
  public boolean onJoSyotetty(String sana) {
      return this.aiemmatSanat.contains(sana);
  }
<% end %>

<p>
  Nyt sovellus toimii kutakuinkin halutusti.
</p>

<% partial 'partials/material_sub_heading' do %>
  Oliot luonnollisena osana ongelmanratkaisua
<% end %>

<p>
  Rakensimme äsken ratkaisun ongelmaan, missä luetaan käyttäjältä sanoja, kunnes käyttäjä antaa saman sanan uudestaan. Syöte ohjelmalle oli esimerkiksi seuraavanlainen.
</p>

<% partial 'partials/sample_output' do %>
  Anna sana: <span class="red">porkkana</span>
  Anna sana: <span class="red">selleri</span>
  Anna sana: <span class="red">nauris</span>
  Anna sana: <span class="red">lanttu</span>
  Anna sana: <span class="red">selleri</span>
  Annoit saman sanan uudestaan!
<% end %>

<p>
  Päädyimme ratkaisuun
</p>

<% partial 'partials/code_highlight' do %>
  public class Kayttoliittyma {
      private Scanner lukija;
      private ArrayList&lt;String&gt; aiemmatSanat;

      public Kayttoliittyma(Scanner lukija) {
          this.lukija = lukija;
          this.aiemmatSanat = new ArrayList&lt;String&gt;();
      }

      public void kaynnista() {

          while (true) {
              System.out.print("Anna sana: ");
              String sana = lukija.nextLine();

              if (onJoSyotetty(sana)) {
                  break;
              }

              // lisätään uusi sana aiempien sanojen listaan
              aiemmatSanat.add(sana);
          }

          System.out.println("Annoit saman sanan uudestaan!");
      }

      public boolean onJoSyotetty(String sana) {
          return this.aiemmatSanat.contains(sana);
      }
  }
<% end %>

<p>
  Ohjelman käyttämä apumuuttuja lista <code>aiemmatSanat</code> on yksityiskohta käyttöliittymän kannalta. Käyttöliittymän kannaltahan on oleellista, että muistetaan niiden <em>sanojen joukko</em> jotka on nähty jo aiemmin. Sanojen joukko on selkeä erillinen "käsite", tai abstraktio. Tälläiset selkeät käsitteet ovat potentiaalisia olioita; kun koodissa huomataan "käsite" voi sen eristämistä erilliseksi luokaksi harkita.
</p>

<% partial 'partials/material_sub_sub_heading' do %>
  Sanajoukko
<% end %>

<p>
  Tehdään luokka <code>Sanajoukko</code>, jonka käyttöönoton jälkeen käyttöliittymän metodi <code>kaynnista</code> on seuraavanlainen:
</p>

<% partial 'partials/code_highlight' do %>
  while (true) {
      String sana = lukija.nextLine();

      if (aiemmatSanat.sisaltaa(sana)) {
          break;
      }

      aiemmatSanat.lisaa(sana);
  }

  System.out.println("Annoit saman sanan uudestaan!");
<% end %>

<p>
  Käyttöliittymän kannalta Sanajoukolla kannattaisi siis olla metodit <code>boolean sisaltaa(String sana)</code> jolla tarkastetaan sisältyykö annettu sana jo sanajoukkoon ja <code>void lisaa(String sana)</code> jolla annettu sana lisätään joukkoon.
</p>

<p>
  Huomaamme, että näin kirjoitettuna käyttöliittymän luettavuus on huomattavasti parempi.
</p>

<p>
  Luokan <code>Sanajoukko</code> runko näyttää seuraavanlaiselta:
</p>

<% partial 'partials/code_highlight' do %>
  public class Sanajoukko {
      // oliomuuttuja(t)

      public Sanajoukko() {
          // konstruktori
      }

      public boolean sisaltaa(String sana) {
          // sisältää-metodin toteutus
          return false;
      }

      public void lisaa(String sana) {
          // lisaa-metodin toteutus
      }
  }
<% end %>


<% partial 'partials/material_sub_sub_heading' do %>
  Toteutus aiemmasta ratkaisusta
<% end %>

<p>
  Voimme toteuttaa sanajoukon siirtämällä aiemman ratkaisumme listan sanajoukon oliomuuttujaksi:
</p>

<% partial 'partials/code_highlight' do %>
  import java.util.ArrayList;

  public class Sanajoukko {
      private ArrayList&lt;String&gt; sanat;

      public Sanajoukko() {
          this.sanat = new ArrayList&lt;&gt;();
      }

      public void lisaa(String sana) {
          this.sanat.add(sana);
      }

      public boolean sisaltaa(String sana) {
          return this.sanat.contains(sana);
      }
  }
<% end %>


<p>
  Ratkaisu on nyt melko elegantti. Erillinen käsite on saatu erotettua ja käyttöliittymä näyttää siistiltä. Kaikki "likaiset yksityiskohdat" on saatu siivottua eli kapseloitua olion sisälle.
</p>

<p>
  Muokataan käyttöliittymää niin, että se käyttää Sanajoukkoa. Sanajoukko annetaan käyttöliittymälle samalla tavalla parametrina kuin Scanner.
</p>

<% partial 'partials/code_highlight' do %>
  public class Kayttoliittyma {
      private Scanner lukija;
      private Sanajoukko sanajoukko;

      public Kayttoliittyma(Scanner lukija, Sanajoukko sanajoukko) {
          this.lukija = lukija;
          this.sanajoukko = sanajoukko;
      }

      public void kaynnista() {

          while (true) {
              System.out.print("Anna sana: ");
              String sana = lukija.nextLine();

              if (this.sanajoukko.sisaltaa(sana)) {
                  break;
              }

              this.sanajoukko.lisaa(sana);
          }

          System.out.println("Annoit saman sanan uudestaan!");
      }
  }
<% end %>

<p>
  Ohjelman käynnistäminen tapahtuu nyt seuraavasti:
</p>


<% partial 'partials/code_highlight' do %>
  public static void main(String[] args) {
      Scanner lukija = new Scanner(System.in);
      Sanajoukko joukko = new Sanajoukko();

      Kayttoliittyma kayttoliittyma = new Kayttoliittyma(lukija, joukko);
      kayttoliittyma.kaynnista();
  }
<% end %>


<% partial 'partials/material_sub_heading' do %>
  Luokan sisäisen toteutuksen muuttaminen
<% end %>

<p>
  Olemme päätyneet tilanteeseen missä <code>Sanajoukko</code> ainoastaan "kapseloi" ArrayList:in. Onko tässä järkeä? Kenties. Voimme nimittäin halutessamme tehdä Sanajoukolle muitakin muutoksia. Ennen pitkään saatamme esim. huomata, että sanajoukko pitää tallentaa tiedostoon. Jos tekisimme nämä muutokset Sanajoukkoon muuttamatta käyttöliittymän käyttävien metodien nimiä, ei käyttöliittymää tarvitsisi muuttaa mitenkään.
</p>

<p>
  Oleellista on tässä se, että Sanajoukko-luokkaan tehdyt sisäiset muutokset eivät vaikuta luokkaan Käyttöliittymä. Tämä johtuu siitä, että käyttöliittymä käyttää sanajoukkoa sen tarjoamien metodien -- eli julkisten rajapintojen -- kautta.
</p>

<% partial 'partials/material_sub_heading' do %>
  Uusien toiminnallisuuksien toteuttaminen: palindromit
<% end %>

<p>
  Voi olla, että jatkossa ohjelmaa halutaan laajentaa siten, että <code>Sanajoukko</code>-luokan olisi osattava uusia asiota. Jos ohjelmassa haluttaisiin esimerkiksi tietää kuinka moni syötetyistä sanoista oli palindromi, voidaan sanajoukkoa laajentaa metodilla <code>palindromeja</code>.
</p>

<% partial 'partials/code_highlight' do %>
  public void kaynnista() {

      while (true) {
          System.out.print("Anna sana: ");
          String sana = lukija.nextLine();

          if (this.sanajoukko.sisaltaa(sana)) {
              break;
          }

          this.sanajoukko.lisaa(sana);
      }

      System.out.println("Annoit saman sanan uudestaan!");
      System.out.println("Sanoistasi " + this.sanajoukko.palindromeja() + " oli palindromeja");
  }
<% end %>

<p>
  Käyttöliittymä säilyy siistinä ja palindromien laskeminen jää <code>Sanajoukko</code>-olion huoleksi. Metodin toteutus voisi olla esimerkiksi seuraavanlainen.
</p>

<% partial 'partials/code_highlight' do %>
  import java.util.ArrayList;

  public class Sanajoukko {
      private ArrayList&lt;String&gt; sanat;

      public Sanajoukko() {
          this.sanat = new ArrayList&lt;&gt;();
      }

      public boolean sisaltaa(String sana) {
          return this.sanat.contains(sana);
      }

      public void lisaa(String sana) {
          this.sanat.add(sana);
      }

      public int palindromeja() {
          int lukumaara = 0;

          for (String sana: this.sanat) {
              if (onPalindromi(sana)) {
                  lukumaara++;
              }
          }

          return lukumaara;
      }

      public boolean onPalindromi(String sana) {
          int loppu = sana.length() - 1;

          int i = 0;
          while (i &lt; sana.length() / 2) {
              // metodi charAt palauttaa annetussa indeksissä olevan merkin
              // alkeistyyppisenä char-muuttujana
              if(sana.charAt(i) != sana.charAt(loppu - i)) {
                  return false;
              }

              i++;
          }

          return true;
      }
  }
<% end %>

<p>
  Metodissa <code>palindromeja</code> käytetään sekä apumetodia <code>onPalindromi</code> että virran filter-metodia. Virran <code>count</code>-metodi palauttaa <code>long</code>-tyyppisen kokonaisluvun, joka tulee muuntaa int-tyyppiseksi ennen sen palautusta metodista.
</p>


<% partial 'partials/material_sub_heading' do %>
  Uusiokäyttö
<% end %>


<p>
  Kun ohjelmakoodin käsitteet on eriytetty omiksi luokikseen, voi niitä uusiokäyttää helposti muissa projekteissa. Esimerkiksi luokkaa <code>Sanajoukko</code> voisi käyttää yhtä hyvin graafisesta käyttöliittymästä, ja se voisi myös olla osa kännykässä olevaa sovellusta. Tämän lisäksi ohjelman toiminnan testaaminen on huomattavasti helpompaa silloin kun ohjelma on jaettu erillisiin käsitteisiin, joita kutakin voi käyttää myös omana itsenäisenä yksikkönään.
</p>


<% partial 'partials/material_sub_heading' do %>
  Neuvoja ohjelmointiin
<% end %>

<p>
  Yllä kuvatussa laajemmassa esimerkissä noudatettiin seuraavia neuvoja.
</p>

<ul>

  <li> Etene pieni askel kerrallaan
    <ul>
      <li> Yritä pilkkoa ongelma osaongelmiin ja <strong>ratkaise vain yksi osaongelma kerrallaan</strong> </li>
      <li> Testaa aina että ohjelma on etenemässä oikeaan suuntaan eli että osaongelman ratkaisu meni oikein</li>
      <li> Tunnista ehdot, minkä tapauksessa ohjelman tulee toimia eri tavalla. Esimerkiksi yllä tarkistus, jolla katsotaan onko sana jo syötetty, johtaa erilaiseen toiminnallisuuden.</li>
    </ul>
  </li>

  <li> Kirjoita mahdollisimman "siistiä" koodia
    <ul>
      <li> sisennä koodi </li>
      <li> käytä kuvaavia muuttujien ja metodien nimiä</li>
      <li> älä tee liian pitkiä metodeja, edes mainia</li>
      <li> tee yhdessä metodissa vaan yksi asia</li>
      <li> <strong>poista koodistasi kaikki copy-paste</strong></li>
      <li> korvaa koodisi "huonot" ja epäsiistit osat siistillä koodilla</li>
    </ul>
  </li>

  <li>
    Astu tarvittaessa askel taaksepäin ja mieti kokonaisuutta. Jos ohjelma ei toimi, voi olla hyvä idea palata aiemmin toimineeseen tilaan. Käänteisesti voidaan sanoa, että rikkinäinen ohjelma korjaantuu harvemmin lisäämällä siihen lisää koodia.
  </li>

</ul>

<p>
  Ohjelmoijat noudattavat näitä käytänteitä sen takia että ohjelmointi olisi helpompaa. Käytänteiden noudattaminen tekee myös ohjelmien lukemisesta, ylläpitämisestä ja muokkaamisesta helpompaa muille.
</p>



<% partial 'partials/exercise', locals: { name: 'Sanakirja (5 osaa)' } do %>

  <p>
    Tässä tehtäväsarjassa toteutetaan sanakirja, josta voi hakea suomen kielen sanoille englanninkielisiä käännöksiä. Sanakirjan tekemisessä käytetään <code>HashMap</code>-tietorakennetta.
  </p>

  <h2>Luokka Sanakirja</h2>

  <p>
    Toteuta luokka nimeltä <code>Sanakirja</code>. Luokalla on aluksi seuraavat metodit:
  </p>

  <ul>
    <li> <code>public String kaanna(String sana)</code> metodi palauttaa parametrinsa käännöksen. Jos sanaa ei tunneta, palautetaan <em>null</em>.</li>
    <li> <code>public void lisaa(String sana, String kaannos)</code> metodi lisää sanakirjaan uuden käännöksen</li>
  </ul>

  <p>
    Toteuta luokka Sanakirja siten, että sen ainoa oliomuuttuja on <code>HashMap</code>-tietorakenne.
  </p>

  <p>
    Testaa sanakirjasi toimintaa:
  </p>

  <% partial 'partials/code_highlight' do %>
    Sanakirja sanakirja = new Sanakirja();
    sanakirja.lisaa("apina", "monkey");
    sanakirja.lisaa("banaani", "banana");
    sanakirja.lisaa("cembalo", "harpsichord");

    System.out.println(sanakirja.kaanna("apina"));
    System.out.println(sanakirja.kaanna("porkkana"));
  <% end %>

  <% partial 'partials/sample_output' do %>
    monkey
    null
  <% end %>


  <h2>Sanojen lukumäärä</h2>

  <p>
    Lisää sanakirjaan metodi <code>public int sanojenLukumaara()</code>, joka palauttaa sanakirjassa olevien sanojen lukumäärän.
  </p>

  <% partial 'partials/code_highlight' do %>
    Sanakirja sanakirja = new Sanakirja();
    sanakirja.lisaa("apina", "monkey");
    sanakirja.lisaa("banaani", "banana");
    System.out.println(sanakirja.sanojenLukumaara());

    sanakirja.lisaa("cembalo", "harpsichord");
    System.out.println(sanakirja.sanojenLukumaara());
  <% end %>


  <% partial 'partials/sample_output' do %>
    2
    3
  <% end %>

  <p>
    Tässä osassa kannattaa tutkiskella HashMapin valmiiksi tarjoamia metodeja... Vaihtoehtoisesti <code>long</code>-tyyppisen muuttujan saa muunnettua <code>int</code>-tyyppiseksi seuraavalla tavalla.
  </p>

  <% partial 'partials/code_highlight' do %>
    long lukuLongina = 1L;
    int lukuInttina = (int) lukuLongina;
  <% end %>


  <h2>Kaikkien sanojen listaaminen</h2>

  <p>
    Lisää sanakirjaan metodi <code>public ArrayList&lt;String&gt; kaannoksetListana()</code> joka palauttaa sanakirjan sisällön listana <i>avain = arvo</i> muotoisia merkkijonoja.
  </p>

  <% partial 'partials/code_highlight' do %>
    Sanakirja sanakirja = new Sanakirja();
    sanakirja.lisaa("apina", "monkey");
    sanakirja.lisaa("banaani", "banana");
    sanakirja.lisaa("cembalo", "harpsichord");

    ArrayList&lt;String&gt; kaannokset = sanakirja.kaannoksetListana();

    for (String kaannos: kaannokset) {
        System.out.println(kaannos);
    }
  <% end %>

  <% partial 'partials/sample_output' do %>
    banaani = banana
    apina = monkey
    cembalo = harpsichord
  <% end %>


  <h2>Tekstikäyttöliittymän alku</h2>

  <p>
    Harjoitellaan erillisen tekstikäyttöliittymän tekemistä. Luo luokka <code>Tekstikayttoliittyma</code>, jolla on seuraavat metodit:
  </p>

  <ul>
    <li> konstruktori <code>public Tekstikayttoliittyma(Scanner lukija, Sanakirja sanakirja)</code></li>
    <li> metodi <code>public void kaynnista()</code>, joka käynnistää tekstikäyttöliittymän.</li>
  </ul>

  <p>
    Tekstikäyttöliittymä tallettaa konstruktorin parametrina saamansa lukijan ja sanakirjan oliomuuttujiin. Muita oliomuuttujia ei tarvita. <strong>Käyttäjän syötteen lukeminen tulee hoitaa konstruktorin parametrina saatua lukija-olioa käyttäen! Myös kaikki käännökset on talletettava konstruktorin parametrina saatuun sanakirja-olioon. Tekstikäyttöliittymä ei saa luoda Scanneria tai Sanakirjaa itse!</strong>
  </p>

  <p>
    <strong>HUOM:</strong> vielä uudelleen edellinen, eli <strong>Tekstikäyttöliittymä ei saa luoda itse skanneria</strong> vaan sen on käytettävä parametrina saamaansa skanneria syötteiden lukemiseen!
  </p>

  <p>
    Tekstikäyttöliittymässä tulee aluksi olla vain komento <code>lopeta</code>, joka poistuu tekstikäyttöliittymästä. Jos käyttäjä syöttää jotain muuta, käyttäjälle sanotaan "Tuntematon komento".
  </p>

  <% partial 'partials/code_highlight' do %>
    Scanner lukija = new Scanner(System.in);
    Sanakirja sanakirja = new Sanakirja();

    Tekstikayttoliittyma kayttoliittyma = new Tekstikayttoliittyma(lukija, sanakirja);
    kayttoliittyma.kaynnista();
  <% end %>

  <% partial 'partials/sample_output' do %>
    Komennot:
    lopeta - poistuu käyttöliittymästä

    Komento: <font color="red">apua</font>
    Tuntematon komento.

    Komento: <font color="red">lopeta</font>
    Hei hei!
  <% end %>

  <h2>Sanojen lisääminen ja kääntäminen</h2>

  <p>
    Lisää tekstikäyttöliittymälle komennot <code>lisaa</code> ja <code>kaanna</code>. Komento <code>lisaa</code> lisää kysyy käyttäjältä sanaparin ja lisää sen sanakirjaan. Komento <code>kaanna</code> kysyy käyttäjältä sanaa ja tulostaa sen käännöksen.
  </p>

  <% partial 'partials/code_highlight' do %>
    Scanner lukija = new Scanner(System.in);
    Sanakirja sanakirja = new Sanakirja();

    Tekstikayttoliittyma kayttoliittyma = new Tekstikayttoliittyma(lukija, sanakirja);
    kayttoliittyma.kaynnista();
  <% end %>

  <% partial 'partials/sample_output' do %>
    Komennot:
    lisaa - lisää sanaparin sanakirjaan
    kaanna - kysyy sanan ja tulostaa sen käännöksen
    lopeta - poistuu käyttöliittymästä

    Komento: <font color="red">lisaa</font>
    Suomeksi: <font color="red">porkkana</font>
    Käännös: <font color="red">carrot</font>

    Komento: <font color="red">kaanna</font>
    Anna sana: <font color="red">porkkana</font>
    Käännös: carrot

    Komento: <font color="red">lopeta</font>
    Hei hei!
  <% end %>

<% end %>

---



---

<% partial 'partials/material_heading' do %>
  Käyttöliittymän ja sovelluslogiikan eriyttäminen
<% end %>

<p>
TODO: paljon kevyempi esimerkki
</p>

<p>
  Edellisessä osassa tarkasteltiin sovelluksen jakamista vastuualueisiin. Jatketaan tässä samalla teemalla.
</p>

<p>
  Suurin syy käyttöliittymän ja sovelluslogiikan eriyttämiseen on ohjelman ylläpidettävyyden ja ymmärrettävyyden lisääminen. Sovellluslogiikan eri osa-alueet ovat ideaalitilanteessa käyttöliittymäriippumattomia, jolloin niitä voidaan parannella ilman käyttöliittymään koskemista. Vastaavasti osia voidaan siirtää sovelluksesta toiseen, jolloin käyttöliittymä on esimerkiksi vaihdettavissa tekstikäyttöliittymästä graafiseen käyttöliittymään.
</p>

<p>
  Edellä kuvattu tilanne vaatii kuitenkin sen, että ohjelman komponenttien tarjoamat rajapinnat eli metodit ja niiden parametrit on selkeästi määritelty.
</p>

<p>
  Pohditaan uudestaan edellisen osan lopussa nähtyä kivi-paperi-sakset -peliä sekä siihen liittyvää "tekoälyä". Peli kysyy ensin käyttäjältä siirtoa, sitten tietokoneen valintaa, ja lopulta kertoo tuloksen. Pelin lopettaminen onnistuu nyt hahmottelemassamme versiossa syöttämällä tyhjän merkkijonon.
</p>

<% partial 'partials/sample_output' do %>
  KPS!
  Valitse [k]ivi, [p]aperi tai [s]akset: <font color="red">k</font>
  Tietokone valitsi: k
  Tasapeli.
  Tilanne: Pelaaja 0 - 0 Tietokone

  Valitse [k]ivi, [p]aperi tai [s]akset: <font color="red">p</font>
  Tietokone valitsi: k
  Pelaaja voitti!
  Tilanne: Pelaaja 1 - 0 Tietokone

  Valitse [k]ivi, [p]aperi tai [s]akset: <font color="red">p</font>
  Tietokone valitsi: k
  Pelaaja voitti!
  Tilanne: Pelaaja 2 - 0 Tietokone

  Valitse [k]ivi, [p]aperi tai [s]akset: <font color="red">s</font>
  Tietokone valitsi: k
  Tietokone voitti!
  Tilanne: Pelaaja 2 - 1 Tietokone

  Valitse [k]ivi, [p]aperi tai [s]akset: <font color="red">s</font>
  Tietokone valitsi: k
  Tietokone voitti!
  Tilanne: Pelaaja 2 - 2 Tietokone

  Valitse [k]ivi, [p]aperi tai [s]akset: <font color="red">k</font>
  Tietokone valitsi: k
  Tasapeli.
  Tilanne: Pelaaja 2 - 2 Tietokone

  Valitse [k]ivi, [p]aperi tai [s]akset:
  Peli päättyi.
  Lopputilanne: Pelaaja 2 - 2 Tietokone
<% end %>

<p>
  Luodaan ohjelmaa varten neljä luokkaa: (1) tekstikäyttöliittymän toteuttamiseen käytettävä luokka <code>Tekstikayttoliittyma</code>, (2) pistetilanteen ylläpitoon käytettävä <code>Pistetilanne</code>, (3) Kivi-paperi-sakset -pelin sääntöjen ylläpitoon käytettävä luokka <code>Saannot</code> ja (4) tietokoneen tarjoaman vastustajan toimintaa kontrolloiva luokka <code>Tekoaly</code>.
</p>



<% partial 'partials/material_sub_heading' do %>
  Tietokoneen "tekoäly"
<% end %>

<p>
  Tekoäly antaa siirron sovellukselle pyydettäessä, jonka lisäksi sille kerrotaan kierroksen lopussa vastustajan siirto. Ensimmäinen tekoäly voi olla hyvin yksinkertainen -- kun tekoäly luodaan erilliseen luokkaan, sitä voidaan jatkossa tarvittaessa parantaa. Luodaan luokasta <code>Tekoaly</code> sellainen, että se palauttaa aina kiven eikä tee tiedolla vastustajan aiemmista siirroista mitään.
</p>

<p>
  Sovitaan, että ohjelmassa käytetään merkkijonoa "k" kiven kuvaamiseen, "p" paperin kuvaamiseen ja "s" saksien kuvaamiseen.
</p>

<% partial 'partials/code_highlight' do %>
public class Tekoaly {

    public String annaSiirto() {
        return "k";
    }

    public void tallennaVastustajanSiirto(String siirto) {

    }
}
<% end %>


<% partial 'partials/material_sub_heading' do %>
  Pistetilanteen ylläpito
<% end %>

<p>
  Pistetilanteen ylläpito tapahtuu luokan <code>Pistetilanne</code> avulla. Pistetilanne tallentaa sekä pelaajan että tekoälyn pisteet sekä mahdollistaa näiden pisteiden kasvattamisen. Tämän lisäksi pistetilanteen voi tulostaa <code>toString</code>-metodilla. Pistetilanne näyttää seuraavalta.
</p>

<% partial 'partials/code_highlight' do %>
  public class Pistetilanne {

      private int pelaajaPisteet;
      private int tietokonePisteet;

      public Pistetilanne() {
          this.pelaajaPisteet = 0;
          this.tietokonePisteet = 0;
      }

      public void pelaajaVoitti() {
          this.pelaajaPisteet++;
      }

      public void tietokoneVoitti() {
          this.tietokonePisteet++;
      }

      @Override
      public String toString() {
          return "Pelaaja " + this.pelaajaPisteet + " - " + this.tietokonePisteet + " Tietokone";
      }
  }
<% end %>


<% partial 'partials/material_sub_heading' do %>
  Pelin säännöt
<% end %>

<p>
  Hyödynnetään Wikipediaa <a href="https://fi.wikipedia.org/wiki/Kivi,_paperi_ja_sakset"  target="_blank">Kivi, paperi ja sakset</a>-pelin sääntöjen tarkastamiseen. Voitto tai tappio määritellään seuraavalla tavalla.
</p>

<table class="table">
  <tr>
    <th>
      Pelaaja 1
    </th>
    <th>
      Pelaaja 2
    </th>
    <th>
      Voittaja
    </th>
  </tr>
  <tr>
    <td>
      Kivi
    </td>
    <td>
      Sakset
    </td>
    <td>
      Pelaaja 1
    </td>
  </tr>
  <tr>
    <td>
      Kivi
    </td>
    <td>
      Paperi
    </td>
    <td>
      Pelaaja 2
    </td>
  </tr>
  <tr>
    <td>
      Kivi
    </td>
    <td>
      Kivi
    </td>
    <td>
      Tasapeli
    </td>
  </tr>
  <tr>
    <td>
      Sakset
    </td>
    <td>
      Paperi
    </td>
    <td>
      Pelaaja 1
    </td>
  </tr>
  <tr>
    <td colspan="3">
      ...
    </td>
  </tr>
</table>

<p>
  Luodaan sääntöjä varten luokka <code>Saannot</code>, joka palauttaa pelaajan voittaessa merkkijonon "pelaaja", tietokoneen voittaessa merkkijonon "tietokone", ja tasapelin yhteydessä merkkijonon "tasapeli".
</p>

<% partial 'partials/code_highlight' do %>
  public class Saannot {

      public String voittaja(String pelaajanValinta, String tietokoneenValinta) {
          if (pelaajanValinta.equals("k")) {
              if (tietokoneenValinta.equals("p")) {
                  return "tietokone";
              }

              if (tietokoneenValinta.equals("s")) {
                  return "pelaaja";
              }
          }

          if (pelaajanValinta.equals("p")) {
              if (tietokoneenValinta.equals("s")) {
                  return "tietokone";
              }

              if (tietokoneenValinta.equals("k")) {
                  return "pelaaja";
              }
          }

          if (pelaajanValinta.equals("s")) {
              if (tietokoneenValinta.equals("k")) {
                  return "tietokone";
              }

              if (tietokoneenValinta.equals("p")) {
                  return "pelaaja";
              }
          }

          return "tasapeli";
      }
  }
<% end %>

<p>
  Ylläolevan esimerkin voisi toteuttaa myös myöhemmin tutuksi tulevien enum-tyyppisten muuttujien avulla (eli järjestettävien ja ennalta määriteltyjen käsitteiden perusteella). Näitä käytettäessä käyttäisimme erillistä käsitettä <code>Siirto</code>, joka tietäisi miten se vertautuu toisiin siirtoihin. Vastaavasti käytössä olisi myös käsite <code>Tulos</code>, joka voisi olla esimerkiksi voitto, tappio tai tasapeli.
</p>


<% partial 'partials/material_sub_heading' do %>
  Tekstikäyttöliittymä
<% end %>

<p>
  Nivotaan edelliset osat yhteen. Tekstikäyttöliittymä on luokka, joka sisältää sovelluslogiikkaan liittyvät oliot oliomuuttujina. Käytössämme olevilla sovelluslogiikan palasilla tekstikäyttöliittymän rakenne on seuraava:
</p>

<% partial 'partials/code_highlight' do %>
  public class Kayttoliittyma {
      // tekstikäyttöliittymän tarvitsemat oliomuuttujat
      private Scanner lukija;
      private Tekoaly tekoaly;
      private Saannot saannot;
      private Pistetilanne pistetilanne;

      // konstruktori, jolle annetaan parametrina tarvitut oliomuuttujat
      // ...

      // käyttöliittymän käynnistysmetodi
      public void kaynnista() {
          // tervehdysviesti

          // ohjelman toistuva logiikka
          while (true) {

              // syötteen lukeminen

              // lopetusehdon tarkastelu

              // logiikka
          }


          // lopetusviesti
      }
  }
<% end %>

<p>
  Hahmotellaan metodiin <code>kaynnista</code> käyttöliittymän tekstit.
</p>


<% partial 'partials/code_highlight' do %>
  public void kaynnista() {
      System.out.println("KPS!");
      System.out.println("");

      while (true) {
          System.out.print("Valitse [k]ivi, [p]aperi tai [s]akset: ");
          String pelaajanValinta = lukija.nextLine();

          if (/* lopetusehto */) {
              break;
          }

          String tietokoneenValinta = tekoaly.annaSiirto();
          System.out.println("Tietokone valitsi: " + tietokoneenValinta);

          tekoaly.tallennaVastustajanSiirto(pelaajanValinta);

          String voittaja = saannot.voittaja(pelaajanValinta, tietokoneenValinta);


          // kerro voittaja ja päivitä pisteet

          System.out.println("Tilanne: " + pistetilanne);
          System.out.println("");

      }

      System.out.println("Peli päättyi.");
      System.out.println("Lopputilanne: " + pistetilanne);
  }
<% end %>

<p>
  Lopetusehto on selkeä. Jos käyttäjä ei syötä merkkijonoa k, p tai s, toistosta poistutaan.
</p>

<% partial 'partials/code_highlight' do %>
  public boolean pelaajaHaluaaLopettaa(String pelaajanValinta) {
      return !pelaajanValinta.equals("k")
              && !pelaajanValinta.equals("p")
              && !pelaajanValinta.equals("s");
  }
<% end %>

<p>
  Voittajan kertomiseen ja pisteiden päivittämiseen käytetään sääntöjä ja pistetilannetta.
</p>

<% partial 'partials/code_highlight' do %>
  public void kerroVoittajaJaPaivitaPisteet(String voittaja) {
      if (voittaja.equals("tietokone")) {
          System.out.println("Tietokone voitti!");
          pistetilanne.tietokoneVoitti();
      } else if (voittaja.equals("pelaaja")) {
          System.out.println("Pelaaja voitti!");
          pistetilanne.pelaajaVoitti();
      } else {
          System.out.println("Tasapeli.");
      }
  }
<% end %>

<p>
  Kayttoliittyma on kokonaisuudessaan seuraavanlainen.
</p>

<% partial 'partials/code_highlight' do %>
import java.util.Scanner;

public class Kayttoliittyma {

    private Scanner lukija;
    private Tekoaly tekoaly;
    private Saannot saannot;
    private Pistetilanne pistetilanne;

    public Kayttoliittyma(Scanner lukija, Tekoaly tekoaly, Saannot saannot, Pistetilanne pistetilanne) {
        this.lukija = lukija;
        this.tekoaly = tekoaly;
        this.saannot = saannot;
        this.pistetilanne = pistetilanne;
    }

    public void kaynnista() {
        System.out.println("KPS!");
        System.out.println("");

        while (true) {
            System.out.print("Valitse [k]ivi, [p]aperi tai [s]akset: ");
            String pelaajanValinta = lukija.nextLine();

            if (pelaajaHaluaaLopettaa(pelaajanValinta)) {
                break;
            }

            String tietokoneenValinta = tekoaly.annaSiirto();
            System.out.println("Tietokone valitsi: " + tietokoneenValinta);

            tekoaly.tallennaVastustajanSiirto(pelaajanValinta);

            String voittaja = saannot.voittaja(pelaajanValinta, tietokoneenValinta);

            kerroVoittajaJaPaivitaPisteet(voittaja);

            System.out.println("Tilanne: " + pistetilanne);
            System.out.println("");

        }

        System.out.println("Peli päättyi.");
        System.out.println("Lopputilanne: " + pistetilanne);
    }

    public void kerroVoittajaJaPaivitaPisteet(String voittaja) {
        if (voittaja.equals("tietokone")) {
            System.out.println("Tietokone voitti!");
            pistetilanne.tietokoneVoitti();
        } else if (voittaja.equals("pelaaja")) {
            System.out.println("Pelaaja voitti!");
            pistetilanne.pelaajaVoitti();
        } else {
            System.out.println("Tasapeli.");
        }
    }

    public boolean pelaajaHaluaaLopettaa(String pelaajanValinta) {
        return !pelaajanValinta.equals("k")
                && !pelaajanValinta.equals("p")
                && !pelaajanValinta.equals("s");
    }
}
<% end %>

<p>
  Sovelluksen käynnistäminen onnistuu erillisestä Main-luokasta suoraviivaisesti.
</p>

<% partial 'partials/code_highlight' do %>
import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        // Testaa ohjelmasi toimintaa täällä!
        Scanner lukija = new Scanner(System.in);
        Pistetilanne pisteet = new Pistetilanne();
        Tekoaly tekoaly = new Tekoaly();
        Saannot saannot = new Saannot();

        Kayttoliittyma kayttis = new Kayttoliittyma(lukija, tekoaly, saannot, pisteet);
        kayttis.kaynnista();
    }
}
<% end %>

<% partial 'partials/material_sub_heading' do %>
  Pelin jatkokehitys
<% end %>

<p>
  Sovellus toimii nyt halutulla tavalla. Jos ohjelmoija haluaisi muuttaa pelin sääntöjä -- esimerkiksi lisäämällä uusia siirtotyyppejä pelin <a href="http://bigbangtheory.wikia.com/wiki/Rock_Paper_Scissors_Lizard_Spock" target="_blank" norel>Rock, Paper, Scissors, Lizard & Spock</a>-hengessä, muutettavia kohtia on melko paljon, sillä siirtoa ei ole abstrahoitu omaksi käsitteekseen vaan se esitetään merkkijonona.
</p>

<p>
  Toisaalta, tekoäly on kapseloitu sovelluksessa hyvin, jolloin sen jatkokehitys on suoraviivaista. Selkeä parannus edelliseen tekoälyyn olisi pelata aina sellainen siirto, joka voittaa pelaajan edellisen siirron. Tämä onnistuisi seuraavasti.
</p>

<% partial 'partials/code_highlight' do %>
  public class Tekoaly {
      private String vastustajanSiirto;

      public Tekoaly() {
          this.vastustajanSiirto = "k";
      }

      public String annaSiirto() {
          if (this.vastustajanSiirto.equals("k")) {
              return "p";
          } else if (this.vastustajanSiirto.equals("p")) {
              return "s";
          } else {
              return "k";
          }
      }

      public void tallennaVastustajanSiirto(String siirto) {
          this.vastustajanSiirto = siirto;
      }
  }
<% end %>

<p>
  Edellisen osan lopussa hahmoteltiin myös hieman parempaa tekoälyä..
</p>


<% partial 'partials/exercise', locals: { name: 'Lintubongarin tietokanta (3 osaa)' } do %>

  <p><b>Tehtävä vastaa kolmea yksiosaista tehtävää. </b></p>

  <p>
    Tässä tehtävässä suunnittelet ja toteutat tietokannan lintubongareille. Tietokanta sisältää lintuja, joista jokaisella on nimi (merkkijono) ja latinankielinen nimi (merkkijono). Tämän lisäksi tietokanta laskee kunkin linnun havaintokertoja.
  </p>

  <p>
    Ohjelmasi täytyy toteuttaa seuraavat komennot:
  </p>

  <ul>
    <li><code>Lisaa</code> - lisää linnun (<b>huom:</b> komennon nimessä ei ä-kirjainta!)</li>
    <li><code>Havainto</code> - lisää havainnon</li>
    <li><code>Tilasto</code> - tulostaa kaikki linnut</li>
    <li><code>Nayta</code> - tulostaa yhden linnun (<b>huom:</b> komennon nimessä ei ä-kirjainta!)</li>
    <li><code>Lopeta</code> - lopettaa ohjelman</li>
  </ul>

  <p>
    Lisäksi virheelliset syötteet pitää käsitellä. (Ks. <code>Simo</code> alla). Tässä vielä esimerkki ohjelman toiminnasta:
  </p>

  <% partial 'partials/sample_output' do %>
    ? <font color="red">Lisaa</font>
    Nimi: <font color="red">Korppi</font>
    Latinankielinen nimi: <font color="red">Corvus Corvus</font>
    ? <font color="red">Lisaa</font>
    Nimi: <font color="red">Haukka</font>
    Latinankielinen nimi: <font color="red">Dorkus Dorkus</font>
    ? <font color="red">Havainto</font>
    Mikä havaittu? <font color="red">Haukka</font>
    ? <font color="red">Havainto</font>
    Mikä havaittu? <font color="red">Simo</font>
    Ei ole lintu!
    ? <font color="red">Havainto</font>
    Mikä havaittu? <font color="red">Haukka</font>
    ? <font color="red">Tilasto</font>
    Haukka (Dorkus Dorkus): 2 havaintoa
    Korppi (Corvus Corvus): 0 havaintoa
    ? <font color="red">Nayta</font>
    Mikä? <font color="red">Haukka</font>
    Haukka (Dorkus Dorkus): 2 havaintoa
    ? <font color="red">Lopeta</font>
  <% end %>

  <p>
    <strong>Huom!</strong> Ohjelmasi rakenne on täysin vapaa. Testaamme vain että <code>Paaohjelma</code> luokan <code>main</code>-metodi toimii kuten tässä on kuvailtu. Hyödyt tehtävässä todennäköisesti ongelma-aluetta sopivasti kuvaavista luokista.
  </p>

<% end %>
