---
  title: Osa 7
  exercise_page: true
  quiz_page: true
  published: false
---


<% partial 'partials/exercise', locals: { name: 'Lintubongarin tietokanta (3 osaa)' } do %>

  <p><b>Tehtävä vastaa kolmea yksiosaista tehtävää. </b></p>

  <p>
    Tässä tehtävässä suunnittelet ja toteutat tietokannan lintubongareille. Tietokanta sisältää lintuja, joista jokaisella on nimi (merkkijono) ja latinankielinen nimi (merkkijono). Tämän lisäksi tietokanta laskee kunkin linnun havaintokertoja.
  </p>

  <p>
    Ohjelmasi täytyy toteuttaa seuraavat komennot:
  </p>

  <ul>
    <li><code>Lisaa</code> - lisää linnun (<b>huom:</b> komennon nimessä ei ä-kirjainta!)</li>
    <li><code>Havainto</code> - lisää havainnon</li>
    <li><code>Tilasto</code> - tulostaa kaikki linnut</li>
    <li><code>Nayta</code> - tulostaa yhden linnun (<b>huom:</b> komennon nimessä ei ä-kirjainta!)</li>
    <li><code>Lopeta</code> - lopettaa ohjelman</li>
  </ul>

  <p>
    Lisäksi virheelliset syötteet pitää käsitellä. (Ks. <code>Simo</code> alla). Tässä vielä esimerkki ohjelman toiminnasta:
  </p>

  <% partial 'partials/sample_output' do %>
    ? <font color="red">Lisaa</font>
    Nimi: <font color="red">Korppi</font>
    Latinankielinen nimi: <font color="red">Corvus Corvus</font>
    ? <font color="red">Lisaa</font>
    Nimi: <font color="red">Haukka</font>
    Latinankielinen nimi: <font color="red">Dorkus Dorkus</font>
    ? <font color="red">Havainto</font>
    Mikä havaittu? <font color="red">Haukka</font>
    ? <font color="red">Havainto</font>
    Mikä havaittu? <font color="red">Simo</font>
    Ei ole lintu!
    ? <font color="red">Havainto</font>
    Mikä havaittu? <font color="red">Haukka</font>
    ? <font color="red">Tilasto</font>
    Haukka (Dorkus Dorkus): 2 havaintoa
    Korppi (Corvus Corvus): 0 havaintoa
    ? <font color="red">Nayta</font>
    Mikä? <font color="red">Haukka</font>
    Haukka (Dorkus Dorkus): 2 havaintoa
    ? <font color="red">Lopeta</font>
  <% end %>

  <p>
    <strong>Huom!</strong> Ohjelmasi rakenne on täysin vapaa. Testaamme vain että <code>Paaohjelma</code> luokan <code>main</code>-metodi toimii kuten tässä on kuvailtu. Hyödyt tehtävässä todennäköisesti ongelma-aluetta sopivasti kuvaavista luokista.
  </p>

<% end %>



...



<p>
  TODO: musiikin soittamista?
</p>

---


<p>
Miksi vain hetkellisesti? Tieto on tietokoneen muistissa, josta se katoaa kun ohjelma sammutetaan. Tiedon tallentaminen pidemmäksi aikaa vaatii pitkittäismuistia, eli kovalevyä. Tällä kurssilla tutustutaan mm. tiedostoon kirjoittamiseen ja tiedoston lukemiseen. Muita tallennustapoja tarkastellaan muunmuassa kurssilla Tietokantojen perusteet.
</p>

<% partial 'partials/material_heading' do %>
  Merkkijonojen käsittely
<% end %>

- charat
- indexOf
- substring

- split -> taulukko


--- 



<% partial 'partials/material_sub_heading' do %>
  Merkkijonon... metodit?
<% end %>

<p>
  Merkkijonot poikkeavat luonteeltaan hieman esimerkiksi kokonaisluvuista. Kokonaisluvut ovat "pelkkiä arvoja" -- niiden avulla voi tehdä laskutoimituksia ja niiden arvon voi tulostaa:
</p>

<% partial 'partials/code_highlight' do %>
int x = 1;
int y = 3;

y = 3 * x + 2;

System.out.println("y:n arvo nyt: " + y);
<% end %>

<% partial 'partials/sample_output' do %>
y:n arvo nyt: 5
<% end %>

<p>
  Merkkijonot taas ovat hieman "älykkäämpiä" ja tietävät esimerkiksi pituutensa:
</p>

<% partial 'partials/code_highlight' do %>
String sana1 = "Ohjelmointi";
String sana2 = "Java";

System.out.println("merkkijonon " + sana1 + " pituus: " + sana1.length());
System.out.println("merkkijonon " + sana2 + " pituus: " + sana2.length());
<% end %>

<p>
  Tulostuu:
</p>

<% partial 'partials/sample_output' do %>
merkkijonon Ohjelmointi pituus on 11
merkkijonon Java pituus on 4
<% end %>

<p>
  Pituus saadaan selville kutsumalla merkkijonon metodia <code>length()</code>. Merkkijonoilla on joukko muitakin metodeja. Kokonaisluvuilla eli <code>int</code>:eillä ei ole metodeja ollenkaan, ne eivät itsessään "osaa" mitään. Mistä tässä oikein on kyse?
</p>


<% partial 'partials/material_sub_heading' do %>
  Olioihin liittyy sekä metodeja että arvoja
<% end %>

<p>
  Merkkijonot ovat olioita, joihin liittyy sekä merkkijonon teksti että metodeja, joilla tekstiä voi käsitellä. Termi <strong>olio</strong> tarkoittaa tietynlaista muuttujaa. Jatkossa tulemme näkemään hyvin paljon muitakin olioita kuin merkkijonoja.
</p>

<p>
  Olion metodia kutsutaan lisäämällä muuttujan nimen perään piste ja metodin nimi. Näiden lisäksi tulee sulut sekä mahdolliset parametrit:
</p>

<% partial 'partials/code_highlight' do %>
  String sana1 = "Ohjelmointi";
  String sana2 = "Java";

  sana1.length();    // kutsutaan merkkijono-olion sana1 metodia length()
  sana2.length();    // kutsutaan merkkijono-olion sana2 metodia length()
<% end %>

<p>
  Metodikutsu kohdistuu nimenomaan siihen olioon, mille metodia kutsutaan. Yllä kutsumme ensin <code>sana1</code>-nimisen merkkijonon <code>length()</code>-metodia, sitten merkkijonon <code>sana2</code> metodia <code>length()</code>.</p>

<p>
  Vanha tuttumme <code>lukija</code> on myös olio:
</p>

<% partial 'partials/code_highlight' do %>
Scanner lukija = new Scanner(System.in);
<% end %>

<p>
  Lukijat ja merkkijonot ovat molemmat oliota, mutta ne ovat kuitenkin varsin erilaisia. Lukijoilla on mm. metodi <code>nextLine()</code> jota merkkijonoilla ei ole. Javassa oliot "synnytetään" eli luodaan melkein aina komennolla <code>new</code>, merkkijonot muodostavat tässä suhteessa poikkeuksen! -- Merkkijonoja voi luoda kahdella tavalla:
</p>

<% partial 'partials/code_highlight' do %>
String banaani = new String("Banaani");
String porkkana = "porkkana";
<% end %>

<p>
  Kumpikin ylläolevista riveistä luo uuden merkkijono-olion. Merkkijonojen luonnissa <code>new</code>-komentoa käytetään kuitenkin hyvin harvoin, sillä Java-ohjelmointikielen toteuttajat ovat tehneet merkkijonojen luomiseen lyhyemmän (ei new-komentoa tarvitsevan) tavan.
</p>

<p>
  Olion "tyypistä" puhuttaessa puhutaan usein <em>luokista</em>. Merkkijonojen luokka on <code>String</code>, lukijoiden luokka taas on <code>Scanner</code>. Opimme jatkossa luokista ja olioista paljon lisää.
</p>



<% partial 'partials/material_sub_heading' do %>
  Monimutkaisemman tiedon lukeminen
<% end %>

<p>
  Edellisessä esimerkissä sekä sitä seuranneissa tehtävissä tiedoston sisältö käsiteltiin riveittäin lukuina tai merkkijonoina. Mikäli tiedosto noudattaa jonkinlaista ennalta määrättyä rakennetta ja sen sisältämä tieto liittyy konkreettiseen käsitteeseen, voidaan luetut rivit muuttaa myös olioiksi.
</p>

<p>
  Oletetaan, että käytössämme on seuraavaa muotoa noudattava reseptejä sisältävä tiedosto. Tiedosto sisältää aina ensin reseptin nimen, jota seuraa reseptiin liittyvät raaka-aineet. Raaka-aineita seuraa tyhjä rivi, jonka jälkeen alkaa uusi resepti. Tiedoston muoto on siis seuraava
</p>

<% partial 'partials/sample_output' do %>
  Reseptin 1 nimi
  reseptin 1 raaka-aine 1
  reseptin 1 raaka-aine 2

  Reseptin 2 nimi
  reseptin 2 raaka-aine 1
  reseptin 2 raaka-aine 2
  reseptin 2 raaka-aine 3
  reseptin 2 raaka-aine 4

  Reseptin 3 nimi
  reseptin 3 raaka-aine 1
  reseptin 3 raaka-aine 2
  reseptin 3 raaka-aine 3
  reseptin 3 raaka-aine 4
<% end %>

<p>
  Käsitettä <code>Resepti</code> voidaan luoda kuvaamaan seuraavanlainen luokka, joka sisältää sekä nimen että listan raaka-aineita.
</p>

<% partial 'partials/code_highlight' do %>
  import java.util.ArrayList;

  public class Resepti {
      private String nimi;
      private ArrayList&lt;String&gt; raakaAineet;

      public Resepti(String nimi) {
          this.nimi = nimi;
          this.raakaAineet = new ArrayList&lt;&gt;();
      }

      public void lisaaRaakaAine(String raakaAine) {
          this.raakaAineet.add(raakaAine);
      }

      public String toString() {
          String palautettava = this.nimi;
          for (String raakaAine: this.raakaAineet) {
              palautettava += "\n  " + raakaAine;
          }
          return palautettava;
      }
  }
<% end %>

<% partial 'partials/code_highlight' do %>
  Resepti resepti = new Resepti("Lettutaikina");
  resepti.lisaaRaakaAine("0.5 litraa maitoa");
  resepti.lisaaRaakaAine("2 munaa");
  resepti.lisaaRaakaAine("sopivasti jauhoa");
  resepti.lisaaRaakaAine("0.5 tl suolaa");
  resepti.lisaaRaakaAine("2 rkl sokeria");
  resepti.lisaaRaakaAine("voita paistamiseen");

  System.out.println(resepti);
<% end %>

<% partial 'partials/sample_output' do %>
  Lettutaikina
    0.5 litraa maitoa
    2 munaa
    sopivasti jauhoa
    0.5 tl suolaa
    2 rkl sokeria
    voita paistamiseen
<% end %>

<p>
  Nyt tiedoston lukeminen onnistuu seuraavasti.
</p>


<% partial 'partials/code_highlight' do %>
  ArrayList&lt;Resepti&gt; reseptit = new ArrayList&lt;&gt;();
  Scanner lukija = new Scanner(System.in);
  System.out.println("Mistä tiedostosta luetaan?");
  String tiedosto = lukija.nextLine();

  try (Scanner tiedostonLukija = new Scanner(new File(tiedosto))) {

      // luetaan reseptit ja raaka-aineet
      while (tiedostonLukija.hasNextLine()) {
          // luetaan resepti ja luodaan sitä vastaava olio
          String reseptinNimi = tiedostonLukija.nextLine();
          Resepti resepti = new Resepti(reseptinNimi);

          // lisätään resepti listalle
          reseptit.add(resepti);

          // lisätään reseptiin raaka-aineet
          while (tiedostonLukija.hasNextLine()) {
              String raakaAine = tiedostonLukija.nextLine();

              // reseptin raaka-aineet lopetetaan tyhjällä rivillä
              if(raakaAine.isEmpty()) {
                  // poistutaan tästä while-toistolauseesta
                  // (ulompi jatkaa)
                  break;
              }

              resepti.lisaaRaakaAine(raakaAine);
          }

      }
  } catch (Exception e) {
      System.out.println("Virhe: " + e.getMessage());
  }

  // tee jotain luetuilla resepteillä
<% end %>


<%= partial 'partials/quiz', locals: { id: '5a874484c1b9900004293f60' } %>

<%= partial 'partials/quiz', locals: { id: '5a87457fc1b9900004293f62' } %>

<%= partial 'partials/quiz', locals: { id: '5a8745e7c1b9900004293f63' } %>



<% partial 'partials/exercise', locals: { name: 'Reseptihaku (4 osaa)' } do %>

  <p>
    Tässä tehtävässä tehdään ohjelma, joka tarjoaa käyttäjälle mahdollisuuden reseptien hakuun reseptin nimen, keittoajan tai raaka-aineen nimen perusteella. Ohjelman tulee lukea reseptit käyttäjän antamasta tiedostosta.
  </p>

  <p>
    Jokainen resepti koostuu kolmesta tai useammasta rivistä reseptitiedostossa. Ensimmäisellä rivillä on reseptin nimi, toisella rivillä reseptin keittoaika (kokonaisluku), ja kolmas ja sitä seuraavat rivit kertovat reseptin raaka-aineet. Reseptin raaka-aineiden kuvaus päättyy tyhjään riviin. Tiedostossa voi olla useampia reseptejä. Alla kuvattuna esimerkkitiedosto.
  </p>

  <% partial 'partials/sample_output' do %>
    Lettutaikina
    60
    maito
    muna
    jauho
    sokeri
    suola
    voi

    Lihapullat
    20
    jauheliha
    muna
    korppujauho

    Tofurullat
    30
    tofu
    riisi
    vesi
    porkkana
    kurkku
    avokado
    wasabi
  <% end %>

  <p>
    Ohjelma toteutetaan osissa. Ensin ohjelmaan luodaan mahdollisuus reseptien lukemiseen sekä listaamiseen. Tämän jälkeen ohjelmaan lisätään mahdollisuus reseptien hakemiseen nimen perusteella, keittoajan perusteella ja lopulta raaka-aineen perusteella.
  </p>

  <p>
    Tehtäväpohjassa on mukana tiedosto <code>reseptit.txt</code>, jota voi käyttää sovelluksen testaamiseen. <em>Huomaa, että ohjelman ei tule listata reseptien raaka-aineita, mutta niitä käytetään hakutoiminnallisuudessa.</em>
  </p>


  <h2>
    Reseptien lukeminen ja listaaminen
  </h2>

  <p>
    Luo ohjelmaan ensin mahdollisuus reseptien lukemiseen sekä listaamiseen. Ohjelman käyttöliittymän tulee olla seuraavanlainen. Voit olettaa, että käyttäjä syöttää aina tiedoston, joka on olemassa. Alla oletetaan, että tehtävänannossa annetut esimerkkireseptit ovat tiedostossa <code>reseptit.txt</code>.
  </p>

  <% partial 'partials/sample_output' do %>
    Mistä luetaan? <font color="red">reseptit.txt</font>

    Komennot:
    listaa - listaa reseptit
    lopeta - lopettaa ohjelman

    Syötä komento: <font color="red">listaa</font>

    Reseptit:
    Lettutaikina, keittoaika: 60
    Lihapullat, keittoaika: 20
    Tofurullat, keittoaika: 30

    Syötä komento:  <font color="red">lopeta</font>
  <% end %>


  <h2>
    Reseptien hakeminen nimen perusteella
  </h2>

  <p>
    Lisää ohjelmaan mahdollisuus reseptien hakemiseen nimen perusteella. Nimen perusteella hakeminen tapahtuu komennolla <code>hae nimi</code>, jonka jälkeen käyttäjältä kysytään merkkijonoa, jota etsitään reseptin nimistä. Hakutoiminnallisuuden tulee toimia siten, että se tulostaa kaikki ne reseptit, joiden nimessä esiintyy käyttäjän kirjoittama merkkijono.
  </p>


  <% partial 'partials/sample_output' do %>
    Mistä luetaan? <font color="red">reseptit.txt</font>

    Komennot:
    listaa - listaa reseptit
    lopeta - lopettaa ohjelman
    hae nimi - hakee reseptiä nimen perusteella

    Syötä komento: <font color="red">listaa</font>

    Reseptit:
    Lettutaikina, keittoaika: 60
    Lihapullat, keittoaika: 20
    Tofurullat, keittoaika: 30

    Syötä komento: <font color="red">hae nimi</font>
    Mitä haetaan: <font color="red">rulla</font>

    Reseptit:
    Tofurullat, keittoaika: 30

    Syötä komento:  <font color="red">lopeta</font>
  <% end %>


  <h2>
    Reseptien hakeminen keittoajan perusteella
  </h2>

  <p>
    Lisää seuraavaksi ohjelmaan mahdollisuus reseptien hakemiseen keittoajan perusteella. Keittoajan perusteella hakeminen tapahtuu komennolla <code>hae keittoaika</code>, jonka jälkeen käyttäjältä kysytään suurinta hyväksyttävää keittoaikaa. Hakutoiminnallisuuden tulee toimia siten, että se tulostaa kaikki ne reseptit, joiden keittoaika on pienempi tai yhtä suuri kuin käyttäjän syöttämä keittoaika.
  </p>


  <% partial 'partials/sample_output' do %>
    Mistä luetaan? <font color="red">reseptit.txt</font>

    Komennot:
    listaa - listaa reseptit
    lopeta - lopettaa ohjelman
    hae nimi - hakee reseptiä nimen perusteella
    hae keittoaika - hakee reseptiä keittoajan perusteella

    Syötä komento: <font color="red">hae keittoaika</font>
    Keittoaika korkeintaan: <font color="red">30</font>

    Reseptit:
    Lihapullat, keittoaika: 20
    Tofurullat, keittoaika: 30

    Syötä komento: <font color="red">hae keittoaika</font>
    Keittoaika korkeintaan: <font color="red">15</font>

    Reseptit:

    Syötä komento: <font color="red">hae nimi</font>
    Mitä haetaan: <font color="red">rulla</font>

    Reseptit:
    Tofurullat, keittoaika: 30

    Syötä komento:  <font color="red">lopeta</font>
  <% end %>


  <h2>
    Reseptien hakeminen raaka-aineen perusteella
  </h2>

  <p>
    Lisää lopulta ohjelmaan mahdollisuus reseptien hakemiseen raaka-aineen perusteella. Raaka-aineen perusteella hakeminen tapahtuu komennolla <code>hae aine</code>, jonka jälkeen käyttäjältä kysytään merkkijonoa. Hakutoiminnallisuuden tulee toimia siten, että se tulostaa kaikki ne reseptit, joiden raaka-aineissa esiintyy käyttäjän antama merkkijono. Huomaa, että tässä annetun merkkijonon täytyy vastata täysin haettua raaka-ainetta (esim. "okeri" ei käy ole sama kuin "sokeri").
  </p>

  <% partial 'partials/sample_output' do %>
    Mistä luetaan? <font color="red">reseptit.txt</font>

    Komennot:
    listaa - listaa reseptit
    lopeta - lopettaa ohjelman
    hae nimi - hakee reseptiä nimen perusteella
    hae keittoaika - hakee reseptiä keittoajan perusteella
    hae aine - hakee reseptiä raaka-aineen perusteella

    Syötä komento: <font color="red">hae keittoaika</font>
    Keittoaika korkeintaan: <font color="red">30</font>

    Reseptit:
    Lihapullat, keittoaika: 20
    Tofurullat, keittoaika: 30

    Syötä komento: <font color="red">hae aine</font>
    Mitä raaka-ainetta haetaan: <font color="red">sokeri</font>

    Reseptit:
    Lettutaikina, keittoaika: 60

    Syötä komento: <font color="red">hae aine</font>
    Mitä raaka-ainetta haetaan: <font color="red">muna</font>

    Reseptit:
    Lettutaikina, keittoaika: 60
    Lihapullat, keittoaika: 20

    Syötä komento: <font color="red">hae aine</font>
    Mitä raaka-ainetta haetaan: <font color="red">una</font>

    Reseptit:

    Syötä komento:  <font color="red">lopeta</font>
  <% end %>

<% end %>


<% partial 'partials/material_sub_heading' do %>
  Lukeminen verkkoyhteyden yli
<% end %>

<p>
  Lähes kaikki verkkosivut, kuten tämäkin oppimateriaali, voidaan lukea tekstimuodossa ohjelmallista käsittelyä varten. Scanner-oliolle voi antaa konstruktorin parametrina lähes minkälaisen syötevirran tahansa. Alla olevassa esimerkissä luodaan URL-olio annetusta web-osoitteesta, pyydetään siihen liittyvää tietovirtaa, ja annetaan se uudelle Scanner-oliolle luettavaksi.
</p>


<% partial 'partials/code_highlight' do %>
ArrayList&lt;String&gt; rivit = new ArrayList&lt;&gt;();

// luodaan lukija web-osoitteen lukemista varten
try (Scanner lukija = new Scanner(new URL("http://www.cs.helsinki.fi/home/").openStream())) {

    // luetaan osoitteesta http://www.cs.helsinki.fi/home/
    // saatava vastaus
    while (lukija.hasNextLine()) {
        rivit.add(lukija.nextLine());
    }
} catch (Exception e) {
    System.out.println("Virhe: " + e.getMessage());
}

// tehdään jotain vastauksella
<% end %>

<p>
  Web-selain on oikeastaan ohjelma siinä missä muutkin ohjelmat. Toisin kuin yllä toteutettu sivun sisällön lataaja, web-selaimeen on toteutettu toiminnallisuus vastauksena tulevan HTML-muotoisen lähdekoodin tulkisemiseen ja graafisessa käyttöliittymässä näyttämiseen.
</p>


<% partial 'partials/exercise', locals: { name: 'Chuck Norris -vitsit' } do %>

  <p>
    Osoitteessa <a href="http://www.icndb.com/api/" target="_blank" rel="noopener">http://www.icndb.com/api/</a> sijaitsee web-sovellus, joka tarjoaa Chuck Norris -vitsejä kaikkien vapaaseen käyttöön.
  </p>

  <p>
    Sovellus tarjoaa muunmuassa mahdollisuuden satunnaisten vitsien hakemiseen (osoite <code>http://api.icndb.com/jokes/random</code>) sekä vitsien hakemiseen niihin liittyvillä numeerisilla tunnuksilla (osoite <code>http://api.icndb.com/jokes/<em>tunnus</em></code>, missä <em>tunnus</em> on kokonaisluku).
  </p>

  <p>
    Toteuta sovellus, joka tarjoaa kolme toimintoa. Jos käyttäjä kirjoittaa "lopeta", ohjelman suoritus lopetetaan. Jos käyttäjä kirjoittaa "satunnainen", ohjelma tulostaa icndb-palvelusta noudetun satunnaisen chuck norris vitsin. Jos käyttäjä kirjoittaa "vitsi <em>numero</em>", missä numero on kokonaisluku, ohjelma tulostaa icndb-palvelusta noudetun tietyn vitsin.
  </p>

  <p>
    Huom! Tässä tehtävässä riittää tulostaa palvelun palauttama merkkijono kokonaisuudessaan. Merkkijono voi olla esimerkiksi muotoa <code>{ "type": "success", "value": { "id": 341, "joke": "Chuck Norris sleeps with a pillow under his gun.", "categories": [] } }</code>.
  </p>

  <p>
    Ohjelmassa ei ole testejä, eli testit eivät ota kantaa sovelluksen rakenteeseen tai tulostuksen ulkoasuun. Palauta sovellus kun se toimii koneellasi toivotulla tavalla.
  </p>

<% end %>



<% partial 'partials/exercise', locals: { name: 'Arvosanatilastot (4 osaa)' } do %>

  <p>
    Tässä tehtävässä toteutetaan ohjelma kurssipistetilastojen tulostamiseen. Ohjelmalle syötetään pisteitä (kokonaislukuja nollasta sataan), ja ohjelma tulostaa niiden perusteella arvosanoihin liittyviä tilastoja. Syötteiden lukeminen lopetetaan kun käyttäjä syöttää luvun -1. Lukuja, jotka eivät ole välillä [0-100] ei tule ottaa huomioon tilastojen laskemisessa.
  </p>

  <p>
    Muistathan, että käyttäjältä luetun merkkijonon saa muunnettua kokonaisluvuksi Integer-luokan metodilla parseInt. Tämä toimii seuraavasti:
  </p>

  <% partial 'partials/code_highlight' do %>
    String lukuMerkkijonona = "3";
    int luku = Integer.parseInt(lukuMerkkijonona);

    System.out.println(lukuMerkkijonona + 7);
    System.out.println(luku + 7);
  <% end %>

  <% partial 'partials/sample_output' do %>
    37
    10
  <% end %>

  <h2>Pisteiden keskiarvot</h2>

  <p>
    Kirjoita ohjelma, joka lukee käyttäjältä kurssin yhteispisteitä kuvaavia kokonaislukuja. Luvut väliltä [0-100] ovat hyväksyttäviä ja luku -1 lopettaa syötteen. Muut luvut ovat virhesyötteitä, jotka tulee jättää huomiotta. Kun käyttäjä syöttää luvun -1, tulostetaan syötettyjen yhteispisteiden keskiarvo.
  </p>

  <% partial 'partials/sample_output' do %>
    Syötä yhteispisteet, -1 lopettaa:
    <font color="red">-42</font>
    <font color="red">24</font>
    <font color="red">42</font>
    <font color="red">72</font>
    <font color="red">80</font>
    <font color="red">52</font>
    <font color="red">-1</font>
    Pisteiden keskiarvo (kaikki): 54.0
  <% end %>

  <% partial 'partials/sample_output' do %>
    Syötä yhteispisteet, -1 lopettaa:
    <font color="red">50</font>
    <font color="red">51</font>
    <font color="red">52</font>
    <font color="red">-1</font>
    Pisteiden keskiarvo (kaikki): 51.0
  <% end %>


  <h2>Hyväksyttyyn arvosanaan liittyvien pisteiden keskiarvot</h2>

  <p>
    Täydennä ohjelmaa siten, että se laskee kaikkien pisteiden keskiarvon lisäksi myös hyväksyttyyn arvosanaan liittyvien pisteiden keskiarvot.
  </p>

  <p>
    Hyväksytyn arvosanan saa vähintään 70 kurssipisteellä. Voit olettaa, että käyttäjä kirjoittaa aina vähintään yhden välillä [0-100] olevan kokonaisluvun. Jos hyväksyttyyn arvosanaan osuvia lukuja ei ole lainkaan, tulostetaan viiva hyväksyttyjen keskiarvon kohdalle "-".
  </p>

  <% partial 'partials/sample_output' do %>
    Syötä yhteispisteet, -1 lopettaa:
    <font color="red">-42</font>
    <font color="red">24</font>
    <font color="red">42</font>
    <font color="red">72</font>
    <font color="red">80</font>
    <font color="red">52</font>
    <font color="red">-1</font>
    Pisteiden keskiarvo (kaikki): 54.0
    Pisteiden keskiarvo (hyväksytyt): 76.0
  <% end %>

  <% partial 'partials/sample_output' do %>
    Syötä yhteispisteet, -1 lopettaa:
    <font color="red">50</font>
    <font color="red">51</font>
    <font color="red">52</font>
    <font color="red">-1</font>
    Pisteiden keskiarvo (kaikki): 51.0
    Pisteiden keskiarvo (hyväksytyt): -
  <% end %>


  <h2>Hyväksyttyjen prosenttiosuus</h2>

  <p>
    Täydennä edellisessä osassa toteuttamaasi ohjelmaa siten, että ohjelma tulostaa myös hyväksymisprosentin. Hyväksymisprosentti lasketaan kaavalla <em>100 * hyväksytyt / osallistujat</em>.
  </p>

  <% partial 'partials/sample_output' do %>
    Syötä yhteispisteet, -1 lopettaa:
    <font color="red">50</font>
    <font color="red">51</font>
    <font color="red">52</font>
    <font color="red">-1</font>
    Pisteiden keskiarvo (kaikki): 51.0
    Pisteiden keskiarvo (hyväksytyt): -
    Hyväksymisprosentti: 0.0
  <% end %>

  <% partial 'partials/sample_output' do %>
    Syötä yhteispisteet, -1 lopettaa:
    <font color="red">102</font>
    <font color="red">-4</font>
    <font color="red">33</font>
    <font color="red">77</font>
    <font color="red">99</font>
    <font color="red">1</font>
    <font color="red">-1</font>
    Pisteiden keskiarvo (kaikki): 52.5
    Pisteiden keskiarvo (hyväksytyt): 88.0
    Hyväksymisprosentti: 50.0
  <% end %>


  <h2>Arvosanajakauma</h2>

  <p>
    Täydennä ohjelmaa siten, että ohjelma tulostaa myös arvosanajakauman. Arvosananajakauma muodostetaan seuraavasti.
  </p>

  <table class="table">

    <tr>
      <th>pistemäärä</th>
      <th>arvosana</th>
    </tr>

    <tr>
      <td>&lt; 70</td>
      <td>hylätty eli 0</td>
    </tr>

    <tr>
      <td>&lt; 76</td>
      <td>1</td>
    </tr>

    <tr>
      <td>&lt; 81</td>
      <td>2</td>
    </tr>

    <tr>
      <td>&lt; 86</td>
      <td>3</td>
    </tr>

    <tr>
      <td>&lt; 91</td>
      <td>4</td>
    </tr>

    <tr>
      <td>&gt;= 91</td>
      <td>5</td>
    </tr>

  </table>


  <p>
    Jokainen koepistemäärä muutetaan arvosanaksi yllä olevan taulukon perusteella. Jos syötetty pistemäärä ei ole välillä [0-100], jätetään se huomiotta.
  </p>

  <p>
    Arvosanajakauma tulostetaan tähtinä. Esim jos arvosanaan 5 oikeuttavia koepistemääriä on 1 kappale, tulostuu rivi <em>5: *</em>. Jos johonkin arvosanaan oikeuttavia pistemääriä ei ole, ei yhtään tähteä tulostu, alla olevassa esimerkissä näin on mm. nelosten kohdalla.</em>
  </p>

  <% partial 'partials/sample_output' do %>
    Syötä yhteispisteet, -1 lopettaa:
    <font color="red">102</font>
    <font color="red">-2</font>
    <font color="red">1</font>
    <font color="red">33</font>
    <font color="red">77</font>
    <font color="red">99</font>
    <font color="red">-1</font>
    Pisteiden keskiarvo (kaikki): 52.5
    Pisteiden keskiarvo (hyväksytyt): 88.0
    Hyväksymisprosentti: 50.0
    Arvosanajakauma:
    5: *
    4:
    3:
    2: *
    1:
    0: **
  <% end %>

<% end %>




<% partial 'partials/material_heading' do %>
  Algoritmiikkaa: Järjestäminen ja hakeminen
<% end %>

<p>
esimerkki algoritmista, luvun jakajien tunnistaminen
</p>

<p>
Järjestäminen
</p>

<p>
hakeminen
</p>

<p>
</p>


<% partial 'partials/exercise', locals: { name: 'Round-robin' } do %>

  <p>
    Tietokoneella voi olla samaan aikaan käynnissä useita ohjelmia, mutta todellisuudessa kaikkien käynnissä olevien ohjelmien lähdekoodia ei suoriteta samaan aikaan. Tietokoneen käyttöjärjestelmä vaihtaa suoritettavaa ohjelmaa jatkuvasti, minkä kautta käyttäjälle tulee illuusio siitä, että ohjelmat olisivat samaan aikaan käynnissä.
  </p>

  <p>
    <a href="https://en.wikipedia.org/wiki/Round-robin_scheduling" target="_blank" rel="noopener">Round-robin -algoritmia</a> käytetään tietokoneen ohjelmien aikatauluttamiseen.
  </p>

  <p>
    Algoritmin toimintaperiaate on yksinkertainen. Ohjelmista luodaan jono, ja ensimmäisenä jonossa olevaa ohjelmaa suoritetaan hetki, jonka jälkeen suoritettavana ollut ohjelma siirretään jonon perälle. Tämän jälkeen seuraava jonossa ollut ohjelma -- nyt jonon ensimmäinen -- päätyy suoritettavaksi, jonka jälkeen se siirretään jonon perälle jne.
  </p>

  <p>
    Tehtäväpohjassa on viisi lukua sisältävä taulukko sekä ohjelmarunko niiden käsittelyyn. Ohjelmarunko tuntee tällä hetkellä kaksi komentoa: "lopeta" lopettaa ohjelman suorituksen ja "tulosta" tulostaa taulukon arvot.
  </p>

  <p>
    Lisää ohjelmaan komento "siirra", joka siirtää ensimmäisenä taulukossa olevan arvon taulukon perälle sekä kaikkia muita taulukon arvoja yhden paikan eteenpäin.
  </p>

  <% partial 'partials/sample_output' do %>
    <font color="red">tulosta</font>
    1 3 5 7 9
    <font color="red">siirra</font>
    <font color="red">tulosta</font>
    3 5 7 9 1
    <font color="red">siirra</font>
    <font color="red">siirra</font>
    <font color="red">tulosta</font>
    7 9 1 3 5
    <font color="red">lopeta</font>
  <% end %>

<% end %>



<% partial 'partials/hint', locals: { name: 'Mikä ihmeen al-Khwarizmi -- tai algoritmi?' } do %>

  <p>
    Ensimmäiset korkeakulttuurit syntyivät (laajemman) lähi-idän alueelle, mikä nopeutti siellä myös henkistä kasvua. Lähi-idässä oltiin merkittävästi muuta maailmaa edellä muunmuassa matematiikassa ja tähtitieteessä -- esimerkiksi Euroopassa 1500-luvulla tapahtunut murros tähtitieteessä (maa kiertääkin aurinkoa eikä toisin päin), tapahtui laajemman lähi-idän vaikutuspiirissä olleessa kreikassa jo noin 300 vuotta ennen ajanlaskumme alkua.
  </p>

  <p>
    Nimi al-Khwarizmi viittaa oikeastaan alueeseen, tai hieman laajemmin, etuosa al- viittaa usein henkilön synty- tai kotipaikkaan. <a href="https://en.wikipedia.org/wiki/Muhammad_ibn_Musa_al-Khwarizmi" target="_blank" rel="noopener">Muhammad ibn Musa al-Khwarizmi</a> -- tai hänen isänsä tai esi-isänsä -- tulivat keskiaasiasta alueelta, joka tunnetaan nykyään suomen kielessä nimellä Harezm. Nykyään käytetty termi <strong>algoritmi</strong> onkin hatunnosto sekä Muhammad ibn Musa al-Khwarizmille että hänen syntyperälleen.
  </p>

  <p>
    Merkittävä osa al-Khwarizmin työstä tapahtui Baghdadissa sijaitsevassa Viisauden talossa, joka paikallisen hallinnon tukemana keräsi tiedemiehiä eri puolilta maailmaa yhteen. Tavoitteena oli "pienimuotoisesti" kerätä kaikki maailman tieto yhteen paikkaan ja kääntää se arabian kielelle, jota sitten jaettiin eteenpäin. Tätä kautta tietoa valui myös eurooppaan: esimerkiksi al-Khwarizmin kirja intialaisilla numeroilla laskemisesta (latinaksi "Algoritmi de numero Indorum") toi arabialaisten numeroiden käytön eurooppaan.
  </p>

  <p>
    Tämä terminologia näkyy yhä esimerkikiksi espanjan kielessä. Espanjankielinen sana guarismo -- eli suomeksi luku -- tulee ilmeisesti juurikin al-Khwarizmin nimestä.
  </p>

  <p>
    Vaikka Muhammad ibn Musa al-Khwarizmi kytketään nykyään -- ainakin tietojenkäsittelytieteilijöiden parissa -- ensisijaisesti algoritmeihin, on hän ennen kaikkea vaikuttanut merkittävästi algebran kehitykseen. Hänen työnsä tuolla alueella kontribuoi mm. ensimmäisen ja toisen asteen yhtälöiden ratkaisemiseen. Työn keskiössä olivat konkreettiset esimerkit sekä selkokieliset askeleittaiset ratkaisut  -- numeroita tuossa työssä ei esiintynyt.
  </p>


<% end %>



<% partial 'partials/material_heading' do %>
  Tiedon hakeminen ja järjestäminen
<% end %>

<p>
  Tiedon nopea hakeminen ja näyttäminen on oleellinen osa ohjelmistojen käytettävyyttä. Jos ohjelman käyttäjä joutuu odottamaan kymmeniä sekunteja kun ohjelma etsii käyttäjän haluamaa tietoa, saattaa ohjelman käyttäjä lopettaa ohjelman käyttämisen kokonaan. Vastaavasti televisio-ohjelmistoja selaava käyttäjä ei hyödy televisio-ohjelman tiedoista mitään jos tiedot latautuvat vasta ohjelman katsomisen jälkeen.
</p>

<p>
  Laajemmin voidaan ajatella, että nopeasti tapahtuva tiedon hakeminen ja näyttäminen on oleellista oikeastaan lähes missä tahansa sovelluksessa. Tutustutaan seuraavaksi tiedon hakemiseen ja järjestämiseen liittyviin algoritmeihin. Vaikka esimerkit käyttävät taulukoita, algoritmit toimivat myös muilla tiedon tallentamiseen tarkoitetuilla tietorakenteilla kuten listoilla.
</p>

<% partial 'partials/material_sub_heading' do %>
  Peräkkäishaku
<% end %>

<p>
  Peräkkäishaku on hakualgoritmi, joka etsii tietoa taulukosta käymällä taulukkoa läpi alkio alkiolta. Heti kun haettu alkio löytyy, sen indeksi palautetaan. Jos alkiota ei löydy, palautetaan tieto siitä ettei haettavaa alkiota löytynyt -- tämä kerrotaan tyypillisesti palauttamalla indeksin sijaan arvo <code>-1</code>.
</p>

<% partial 'partials/code_highlight' do %>
  public class Algoritmit {

  public int perakkaishaku(int[] taulukko, int haettava) {
  for (int i = 0; i &lt; taulukko.length; i++) {
  if (taulukko[i] == haettava) {
  return i;
  }
  }

  return -1;
  }
  }
<% end %>

<p>
  Pahimmassa tapauksessa, eli tilanteessa missä alkiota ei lödy, algoritmi tekee taulukon koon verran vertailuja. Vaikkapa 10 miljoonaa arvoa sisältävässä taulukossa tämä tarkoittaa kymmentä miljoonaa vertailua. Jos tietoa haetaan useampia kertoja, kannattaa tehokkuutta yrittää parantaa.
</p>


<% partial 'partials/material_sub_heading' do %>
  Valintajärjestäminen
<% end %>

<p>
  Jos tieto ei noudata minkäänlaista järjestystä tai sääntöä, on tiedon hakeminen tyypillisesti työlästä. Tarvitsemme siis järjestystä!
</p>

<p>
  Ohjelmoijan yleissivistykseen kuuluu ainakin yhden järjestämisalgoritmin (eli tavan järjestää taulukko) tuntemus. Tutustutaan erääseen "klassiseen" järjestämisalgoritmiin, valintajärjestämiseen. Tutustuminen tapahtuu harjoitustehtävien avulla.
</p>


<% partial 'partials/exercise', locals: { name: 'Järjestäminen (5 osaa)' } do %>

  
  <h2>Pienimmän arvon etsiminen</h2>

  <p>
    Tee luokkaan <code>Valintajarjestaminen</code> metodi <code>pienin</code>, joka palauttaa metodille parametrina annetun kokonaislukutaulukon pienimmän luvun.
  </p>

  <p>
    Metodin runko on seuraava:
  </p>

  <% partial 'partials/code_highlight' do %>
    public int pienin(int[] taulukko) {
    // kirjoita koodia tähän
    }
  <% end %>

  <p>Seuraava esimerkki esittelee metodin toimintaa:</p>

  <% partial 'partials/code_highlight' do %>
    int[] luvut = {6, 5, 8, 7, 11};
    System.out.println("Pienin: " + new Valintajarjestaminen().pienin(luvut));
  <% end %>

  <% partial 'partials/sample_output' do %>
    Pienin: 5
  <% end %>

  
  <h2>Pienimmän arvon indeksi</h2>

  <p>
    Tee luokkaan Valintajarjestaminen metodi <code>pienimmanIndeksi</code>, joka palauttaa sille parametrina annetun taulukon pienimmän luvun indeksin.
  </p>

  <p>
    Metodin runko on seuraava:
  </p>

  <% partial 'partials/code_highlight' do %>
    public int pienimmanIndeksi(int[] taulukko) {
    // kirjoita koodia tähän
    }
  <% end %>

  <p>
    Seuraava koodi esittelee metodin toimintaa:
  </p>

  <% partial 'partials/code_highlight' do %>
    // indeksit:   0  1  2  3  4
    int[] luvut = {6, 5, 8, 7, 11};
    System.out.println("Pienimmän indeksi: " + new Valintajarjestaminen().pienimmanIndeksi(luvut));
  <% end %>

  <% partial 'partials/sample_output' do %>
    Pienimmän indeksi: 1
  <% end %>

  <p>
    Taulukon pienin luku on 5, ja sen indeksi eli sijaintipaikka taulukossa on 1. Muistathan, että taulukon numerointi alkaa 0:sta.
  </p>

  
  <h2>Pienimmän arvon indeksi taulukon loppuosassa</h2>

  <p>
    Tee luokkaan Valintajarjestaminen metodi <code>pienimmanIndeksiAlkaen</code>, joka toimii samalla tavalla kuin edellisen tehtävän metodi, mutta ottaa huomioon vain taulukon loppuosan jostain indeksistä alkaen. Metodille annetaan parametrina taulukon lisäksi aloitusindeksi, josta lähtien pienintä lukua etsitään.
  </p>

  <p>
    Metodin runko on seuraava:
  </p>

  <% partial 'partials/code_highlight' do %>
    public int pienimmanIndeksiAlkaen(int[] taulukko, int aloitusIndeksi) {
    // kirjoita koodia tähän
    }
  <% end %>

  <p>
    Seuraava koodi esittelee metodin toimintaa:
  </p>

  <% partial 'partials/code_highlight' do %>
    Valintajarjestaminen algoritmi = new Valintajarjestaminen();

    // indeksit:    0  1  2  3   4
    int[] luvut = {-1, 6, 9, 8, 12};
    System.out.println(algoritmi.pienimmanIndeksiAlkaen(luvut, 0));
    System.out.println(algoritmi.pienimmanIndeksiAlkaen(luvut, 1));
    System.out.println(algoritmi.pienimmanIndeksiAlkaen(luvut, 2));
  <% end %>

  <% partial 'partials/sample_output' do %>
    0
    1
    3
  <% end %>

  <p>
    Esimerkissä ensimmäinen metodikutsu etsii pienimmän luvun indeksin aloittaen indeksistä 0. Indeksistä 0 alkaen pienin luku on -1, ja sen indeksi on 0. Toinen metodikutsu etsii pienimmän luvun indeksiä indeksistä 1 aloittaen. Tällöin pienin luku on 6, ja sen indeksi on 1. Kolmas kutsu etsii pienimmän luvun indeksiä aloittaen indeksistä 2. Indeksistä 2 alkaen pienin luku on 8, ja sen indeksi on 3.
  </p>

  
  <h2>Lukujen vaihtaminen</h2>

  <p>Tee luokkaan Valintajarjestaminen metodi <code>vaihda</code>, jolle annetaan taulukko ja kaksi sen indeksiä. Metodi vaihtaa indekseissä olevat luvut keskenään.</p>

  <p>Metodin runko on seuraava:</p>

  <% partial 'partials/code_highlight' do %>
    public void vaihda(int[] taulukko, int indeksi1, int indeksi2) {
    // kirjoita koodia tähän
    }
  <% end %>

  <p>
    Seuraavassa estellään metodin toimintaa. Taulukon tulostamisessa käytetään apuna taulukon merkkijonoksi muotoilevaa Arrays.toString-metodia:
  </p>

  <% partial 'partials/code_highlight' do %>
    int[] luvut = {3, 2, 5, 4, 8};

    System.out.println(Arrays.toString(luvut));

    vaihda(luvut, 1, 0);
    System.out.println(Arrays.toString(luvut));

    vaihda(luvut, 0, 3);
    System.out.println(Arrays.toString(luvut));
  <% end %>

  <% partial 'partials/sample_output' do %>
    [3, 2, 5, 4, 8]
    [2, 3, 5, 4, 8]
    [4, 3, 5, 2, 8]
  <% end %>

  
  <h2>Järjestäminen</h2>

  <p>
    Nyt koossa on joukko hyödyllisiä metodeja, joiden avulla voimme toteuttaa järjestämisalgoritmin nimeltä valintajärjestäminen.
  </p>

  <p>
    Valintajärjestämisen idea on seuraava:
  </p>

  <ul>
    <li>
      Siirretään taulukon pienin luku indeksiin 0.
    </li>
    <li>
      Siirretään taulukon toiseksi pienin luku indeksiin 1.
    </li>
    <li>
      Siirretään taulukon kolmanneksi pienin luku indeksiin 2.
    </li>
    <li>
      Jne.
    </li>
  </ul>

  <p>
    Toisin sanoen:
  </p>

  <ul>
    <li>
      Tarkastellaan taulukkoa indeksistä 0 alkaen. Vaihdetaan keskenään indeksissä 0 oleva luku sekä taulukon pienin luku indeksistä 0 alkaen.
    </li>
    <li>
      Tarkastellaan taulukkoa indeksistä 1 alkaen. Vaihdetaan keskenään indeksissä 1 oleva luku sekä taulukon pienin luku indeksistä 1 alkaen.
    </li>
    <li>
      Tarkastellaan taulukkoa indeksistä 2 alkaen. Vaihdetaan keskenään indeksissä 2 oleva luku sekä taulukon pienin luku indeksistä 2 alkaen.
    </li>
    <li>
      Jne.
    </li>
  </ul>

  <p>
    Toteuta metodi <code>jarjesta</code>, joka perustuu yllä olevaan ideaan. Metodissa on syytä olla silmukka, joka käy läpi taulukon indeksejä. Metodeista <code>pieninIndeksiAlkaen</code> ja <code>vaihda</code> on varmasti hyötyä. Tulosta myös taulukon sisältö ennen järjestämistä ja jokaisen kierroksen jälkeen, jotta voit varmistaa algoritmin toimivan oikein.
  </p>

  <p>
    Metodin runko on seuraava:
  </p>

  <% partial 'partials/code_highlight' do %>
    public void jarjesta(int[] taulukko) {
    
    }
  <% end %>

  <p>
    Testaa metodin toimintaa ainakin seuraavalla esimerkillä:
  </p>

  <% partial 'partials/code_highlight' do %>
    int[] luvut = {8, 3, 7, 9, 1, 2, 4};
    new Valintajarjestaminen().jarjesta(luvut);
  <% end %>

  <p>
    Ohjelman tulosteen tulisi olla seuraavanlainen. Huomaa että sinun tulee tulostaa taulukon sisältö jokaisen vaihtamisen jälkeen!
  </p>

  <% partial 'partials/sample_output' do %>
    [8, 3, 7, 9, 1, 2, 4]
    [1, 3, 7, 9, 8, 2, 4]
    [1, 2, 7, 9, 8, 3, 4]
    [1, 2, 3, 9, 8, 7, 4]
    [1, 2, 3, 4, 8, 7, 9]
    [1, 2, 3, 4, 7, 8, 9]
    [1, 2, 3, 4, 7, 8, 9]
  <% end %>

  <p>
    Huomaat, miten taulukko tulee pikkuhiljaa järjestykseen alkaen alusta ja edeten loppua kohti.
  </p>

<% end %>



<% partial 'partials/material_sub_heading' do %>
  Valmiiden järjestämisalgoritmien hyödyntäminen
<% end %>


<p>
  Java tarjoaa merkittävän määrän valmiita järjestysalgoritmeja. Taulukot voi järjestää (luonnolliseen järjestykseen) luokan Arrays tarjoamalla metodilla sort, ja listat voi järjestää (luonnolliseen järjestykseen) luokan Collections tarjoamalla metodilla sort.
</p>

<% partial 'partials/code_highlight' do %>
  int[] luvut = {8, 3, 7, 9, 1, 2, 4};
  System.out.println(Arrays.toString(luvut));
  Arrays.sort(luvut);
  System.out.println(Arrays.toString(luvut));
<% end %>

<% partial 'partials/sample_output' do %>
  [8, 3, 7, 9, 1, 2, 4]
  [1, 2, 3, 4, 7, 8, 9]
<% end %>


<% partial 'partials/code_highlight' do %>
  ArrayList&lt;Integer&gt; luvut = new ArrayList&lt;&gt;();
  luvut.add(8);
  luvut.add(3);
  luvut.add(7);
  System.out.println(luvut);
  Collections.sort(luvut);
  System.out.println(luvut);
<% end %>

<% partial 'partials/sample_output' do %>
  [8, 3, 7]
  [3, 7, 8]
<% end %>

<p>
  Valmiit järjestämisalgoritmit toimivat sekä alkeistyyppisille muuttujille, että joillekin viittaustyyppisille muuttujille kuten String. Omien luokkiemme järjestämistä varten joudumme antamaan Javalle hieman lisävinkkejä, sillä luokat eivät sisällä tietoa siitä, miten niistä luodut oliot pitäisi järjestää.
</p>


<p>
  TODO: entä oliot, joilla on monta arvoa? --  palaamme olioiden järjestämiseen ohjelmoinnin jatkokurssilla.
</p>

<p>
  TODO: ehkä joku helppo järjestämisalgo myös olioilla?
</p>




<% partial 'partials/material_sub_heading' do %>
  Binäärihaku (puolitushaku)
<% end %>

<p>
  Kun tieto on järjestyksessä, hakeminen voidaan toteuttaa paljon peräkkäishakua tehokkaammin.
</p>

<p>
  Tutkitaan binäärihaun ideaa seuraavan järjestyksessä olevan taulukon avulla.
</p>

<% partial 'partials/sample_output' do %>
  // indeksit   0   1   2   3    4   5    6   7   8   9  10
  // luvut     -7  -3   3   7   11  15   17  21  24  28  30
<% end %>

<p>
  Oletetaan että haluamme löytää luvun 17 indeksin. Hyödynnetään tietoa siitä että taulukon arvot ovat järjestyksessä. Sen sijaan, että kävisimme taulukon lukuja läpi taulukon alusta lähtien, tarkastelemme arvoa taulukon puolivälissä. Taulukon puolivälissä olevan alkion indeksi on isoin indeksi 10 jaettuna kahdella eli 5. Keskimmäinen alkio on merkattu seuraavaan tähdillä:
</p>

<% partial 'partials/sample_output' do %>
  // indeksit   0   1   2   3    4  *5*   6   7   8   9  10
  // luvut     -7  -3   3   7   11  15   17  21  24  28  30
<% end %>

<p>
  Puolessa välissä on luku 15, joka ei ollut hakemamme luku (eli luku 17). Koska taulukko on järjestyksessä (tässä suuruusjärjestyksessä), ei etsitty luku voi missään tapauksessa olla luvun 15 vasemmalla puolella. Voimme siis päätellä että kaikki indeksit, jotka ovat pienempiä tai yhtäsuuria kuin 5, eivät missään nimessä sisällä hakemaamme arvoa.
</p>

<p>
  Alue, jolta etsimme haettavaa lukua voidaan nyt rajata lukuihin, jotka sijaitsevat indeksin 5 oikealla puolella, eli indekseihin välillä [6, 10] (6, 7, 8, 9, 10). Seuraavassa on merkitty harmaalla se osa taulukkoa jossa etsitty ei voi olla:
</p>

<% partial 'partials/sample_output' do %>
  // indeksit   <font color="lightgrey"> 0   1   2   3   4    5</font>    6   7   8   9  10
  // luvut      <font color="lightgrey">-7  -3   3   7  11   15</font>   17  21  24  28  30
<% end %>

<p>
  Tutkitaan seuraavaksi jäljellä olevan etsintäalueen, eli indeksien 6-10 keskimmäistä indeksiä. Keskimmäinen indeksi löytyy laskemalla etsintäalueen pienimmän ja suurimman indeksin summan ja jakamalla se kahdella, eli (6+10)/2 = 16/2 = 8. Indeksi 8 on merkitty alle tähdillä.
</p>

<% partial 'partials/sample_output' do %>
  // indeksit   <font color="lightgrey"> 0   1   2   3   4    5</font>    6   7  *8*  9  10
  // luvut      <font color="lightgrey">-7  -3   3   7  11   15</font>   17  21  24  28  30
<% end %>

<p>
  Indeksissä 8 oleva luku on 24, joka ei ollut hakemamme luku. Koska luvut taulukossa ovat suuruusjärjestyksessä, ei etsittävä luku voi missään nimessä olla luvun 24 oikealla puolella. Voimme siis päätellä että kaikki indeksit, jotka ovat suurempia tai yhtäsuuria kuin 8, eivät missään nimessä sisällä hakemaamme arvoa. Etsintäalue rajautuu taas, harmaat alueet on käsitelty:
</p>

<% partial 'partials/sample_output' do %>
  // indeksit   <font color="lightgrey"> 0   1   2   3   4    5</font>    6   7  <font color="lightgrey"> 8   9  10</font>
  // luvut      <font color="lightgrey">-7  -3   3   7  11   15</font>   17  21  <font color="lightgrey">24  28  30</font>
<% end %>

<p>
  Etsintä jatkuu. Tutkitaan jäljellä olevan etsintäalueen, eli indeksien 6-7, keskimmäistä indeksiä. Keskimmäinen indeksi löytyy taas ottamalla etsintäalueen pienimmän ja suurimman indeksin summa ja jakamalla se kahdella, eli (6+7)/2 = 6,5, joka pyöristyy alaspäin luvuksi 6. Kohta on merkitty alle tähdillä.
</p>

<% partial 'partials/sample_output' do %>
  // indeksit   <font color="lightgrey"> 0   1   2   3   4    5</font>   *6*  7  <font color="lightgrey"> 8   9  10</font>
  // luvut      <font color="lightgrey">-7  -3   3   7  11   15</font>   17  21  <font color="lightgrey">24  28  30</font>
<% end %>

<p>
  Indeksissä 6 on luku 17, joka on sama kuin hakemamme luku. Voimme lopettaa haun ja ilmoittaa että etsitty luku on taulukossa. Jos luku ei olisi ollut taulukossa -- esimerkiksi jos haettava luku olisi ollut 16, etsintäalue olisi jäänyt lopulta tyhjäksi.
</p>

<% partial 'partials/sample_output' do %>
  // indeksit   <font color="lightgrey"> 0   1   2   3   4    5</font>   *<font color="red">6</font>*  7  <font color="lightgrey"> 8   9  10</font>
  // luvut      <font color="lightgrey">-7  -3   3   7  11   15</font>   <font color="red">17</font>  21  <font color="lightgrey">24  28  30</font>
<% end %>

<p>
  Jotta binäärihaun idea tulee sinulle tutuksi, simuloi kynällä ja paperilla miten binäärihaku toimii kun taulukkona on alla oleva taulukko ja haet lukua 33. Kokeile tämän jälkeen binäärihakua vielä siten, että etsit lukua 1. 
</p>

<% partial 'partials/sample_output' do %>
  // indeksit   0   1   2   3   4   5   6   7   8   9  10  11  12  13
  // luvut     -5  -2   3   5   8  11  14  20  22  26  29  33  38  41
<% end %>


<% partial 'partials/hint', locals: { name: 'Binäärihaku vs. Peräkkäishaku' } do %>
  <p>
    Peräkkäishaun pahimmassa tapauksessa -- eli kun haettavaa ei löydy -- käydään kaikki taulukon arvot läpi. Miljoona alkiota sisältävässä taulukossa tämä tarkoittaa miljoonan alkion tarkastelua.
  </p>

  <p>
    Binäärihaun pahimmassa tapauksessa tutkittava alue jaetaan kahteen osaan kunnes osan koko on yksi. Alkioita tarkastellaan huomattavasti vähemmän kuin peräkkäishaussa. Tarkastellaan tätä hieman tarkemmin.
  </p>

  <p>
    Taulukko, jossa on 16 alkiota, voidaan jakaa kahteen osaan korkeintaan 4 kertaa, eli 16 -&gt; 8 -&gt; 4 -&gt; 2 -&gt; 1.
  </p>

  <p>
    Toisaalta, taulukko, jossa on miljoona alkiota voidaan jakaa kahteen osaan korkeintaa 20 kertaa, eli 1000000 -&gt; 500000 -&gt; 250000 -&gt; 125000 -&gt; 62500 -&gt; 31250 -&gt; 15625 -&gt; ~7813 -&gt; ~3907 -&gt; 1954 -&gt; ~977 -&gt; ~489 -&gt; ~245 -&gt; ~123 -&gt; ~62 -&gt; ~31 -&gt; ~16 -&gt; ~8 -&gt; ~4 -&gt; ~2 -&gt; ~1.
  </p>

  <p>
    Mitä tämä tarkoittaa? Binäärihakua käyttäen miljoona alkiota sisältävästä taulukosta tulee pahimmassa tapauksessa tarkastella noin kahtakymmentä alkiota, kun peräkkäishaussa tarkasteltavia alkioita on miljoona.
  </p>

  <p>
    Koska haettavien alkioiden määrä puolittuu binäärihaussa jokaisen tarkastelun yhteydessä, voi binäärihaun tehokkuutta tarkastella kaksikantaisen logaritmin avulla. Kaksikantainen logaritmi (<code>log<sub>2</sub></code>) annetusta luvusta kertoo kuinka monta kertaa luku voidaan puolittaa. Esimerkiksi kaksikantainen logaritmi luvusta 16777216 (<code>log<sub>2</sub> 16777216</code>) on 24, ja luvun 4294967296 kaksikantainen logaritmi, (<code>log<sub>2</sub> 4294967296</code>) on 32. Tämä tarkoittaa että 4294967296 eri arvoa sisältävästä järjestyksessä olevasta taulukosta hakeminen vaatisi binäärihaulta korkeintaan 32 eri alkion tarkastamista.
  </p>

<% end %>

<p>
  TODO: muutama esimerkki / tehtävä hakemisesta
</p>


<p>
  TODO: tehtävä, missä tulee selväksi että järjestää tarttee vain kerran, jonka jälkeen hakeminen todella nopeaa
</p>

<%= partial 'partials/quiz', locals: { id: '5a987a0f7863c4000454a044' } %>





<% partial 'partials/material_heading' do %>
  Ohjelmien testaaminen
<% end %>



<% partial 'partials/material_heading' do %>
  Ensiaskeleet automaattiseen testaamiseen
<% end %>

<p>
  Otetaan seuraavaksi ensiaskeleet ohjelmien testaamiseen.
</p>


<% partial 'partials/material_sub_heading' do %>
  Virhetilanteet ja ongelman ratkaiseminen askel kerrallaan
<% end %>

<p>
  Ohjelmia luodessa niihin päätyy virheitä. Joskus virheet eivät ole niin vakavia, ja aiheuttavat päänvaivaa lähinnä ohjelman käyttäjälle. Joskus toisaalta virheet voivat johtaa hyvinkin vakaviin seurauksiin. Varmaa on joka tapauksessa se, että ohjelmoimaan opetteleva ihminen tekee paljon virheitä.
</p>

<p>
  Virheitä ei kannata missään nimessä pelätä tai välttää, sillä virheitä tekemällä oppii parhaiten. Pyri siis myös välillä rikkomaan työstämääsi ohjelmaa, jolloin pääset tutkimaan virheilmoitusta ja tarkastelemaan kertooko virheilmoitus jotain tekemästäsi virheestä.
</p>

<% partial 'partials/hint', locals: { name: 'Ohjelmistovirhe' } do %>

  <p>
    Osoitteessa <a href="http://sunnyday.mit.edu/accidents/MCO_report.pdf" target="_blank">http://sunnyday.mit.edu/accidents/MCO_report.pdf</a> oleva raportti kuvaa erään hieman vakavamman ohjelmistovirheestä johtuneen tapaturman sekä ohjelmistovirheen.
  </p>

  <p>
    Ohjelmistovirhe liittyi siihen, että käytetty ohjelma odotti, että ohjelmoija käyttäisi <a href="https://fi.wikipedia.org/wiki/Kansainv%C3%A4linen_yksikk%C3%B6j%C3%A4rjestelm%C3%A4" target="_blank">kansainvälistä yksikköjärjestelmää</a> laskuissa (metrit, kilogrammat, ...). Ohjelmoija oli kuitenkin käyttänyt <a href="https://en.wikipedia.org/wiki/English_Engineering_units" target="_blank">amerikkalaista mittajärjestelmää</a> erään järjestelmän osan laskuissa, jolloin satelliitin navigointiin liittynyt automaattinen korjausjärjestelmä ei toiminut oikein.
  </p>

  <p>
    Satelliitti tuhoutui.
  </p>

<% end %>


<p>
  Ohjelmien muuttuessa monimutkaisemmiksi, tulee virheiden löytämisestäkin haastavampaa. NetBeansiin integroitu debuggeri voi olla avuksi virheiden löytämisessä. Debuggerin käyttöä on esitelty kurssimateriaaliin upotetuilla videoilla; alla oleva video esittelee myös miten projekteja voidaan luoda, avata ja sulkea sekä miten ohjelmia voidaan suorittaa NetBeansin ulkopuolella. Screencastissa on myös asioita, joita kurssilla ei vielä ole tullut -- älä huoli, nämä tulevat vastaan opintojen edetessä.
</p>

<a href="http://www.youtube.com/watch?feature=player_embedded&v=2QlbAvDPmk8" class="youtube" height="300" target="_blank"><img src=" https://www.cs.helsinki.fi/group/java/k13/ohpe/img/youtube.jpg"/></a>

<% partial 'partials/material_sub_heading' do %>
  Stack trace
<% end %>

<p>
  Kun ohjelmassa tapahtuu virhe, ohjelma tyypillisesti tulostaa ns. stack tracen, eli niiden metodikutsujen listan, joiden seurauksena virhetilanne syntyi. Stack trace voi näyttää esimerkiksi seuraavalta:
</p>

<% partial 'partials/sample_output' do %>
  Exception in thread "main" ...
      at Ohjelma.main(Ohjelma.java:15)
<% end %>

<p>
  Listan alussa kerrotaan minkälainen virhe tapahtui (tässä ...), ja seuraavalla rivillä kerrotaan missä virhe tapahtui. Rivi "at Ohjelma.main(Ohjelma.java:15)" sanoo, että virhe tapahtui Ohjelma.java-tiedoston rivillä 15.
</p>

<% partial 'partials/sample_output' do %>
  at Ohjelma.main(Ohjelma.java:15)
<% end %>


<% partial 'partials/material_sub_heading' do %>
  Muistilista virheenselvitykseen
<% end %>

<p>
  Jos koodisi ei toimi etkä tiedä missä on virhe, näillä askeleilla pääset alkuun.
</p>

<ol>
  <li>Sisennä koodisi oikein ja selvitä, puuttuuko sulkuja.</li>
  <li>Tarkista ovatko käytetyt muuttujat oikean nimisiä.</li>
  <li>Testaa ohjelman kulkua erilaisilla syötteillä, ja selvitä minkälaisella syötteellä ohjelma ei toimi halutusti. Jos sait virheen testeistä, testit saattavat myös kertoa käytetyn syötteen.</li>
  <li>Lisää ohjelmaan tulostuskomentoja, joissa tulostat käytettävien muuttujien arvoja ohjelman suorituksen eri vaiheissa.</li>
  <li>Tarkista, että kaikki käyttämäsi muuttujat on alustettu. Jos tätä ei ole tehty, seuraa virhe NullPointerException.</li>
  <li>Jos ohjelmasi aiheuttaa poikkeuksen, kannattaa ehdottomasti kiinnittää huomiota poikkeuksen yhteydessä olevaan <em>stack traceen</em>, eli niiden metodikutsujen listaan, minkä seurauksena poikkeuksen aiheuttanut tilanne syntyi.</li>
  <li>Opettele käyttämään debuggeria, aiemmin nähdyllä videolla pääsee alkuun.</li>
</ol>


<% partial 'partials/material_sub_heading' do %>
  Testisyötteen antaminen Scannerille
<% end %>

<p>
  Ohjelman testaaminen käsin on usein työlästä. Syötteen antaminen on mahdollista automatisoida esimerkiksi syöttämällä Scanner-oliolle luettava merkkijono. Alla on annettu esimerkki siitä, miten ohjelmaa voi testata automaattisesti. Ohjelmassa syötetään ensin viisi merkkijonoa, jonka jälkeen syötetään aiemmin nähty merkkijono. Tämän jälkeen yritetään syöttää vielä uusi merkkijono. Merkkijonoa "kuusi" ei pitäisi esiintyä sanajoukossa.
</p>

<p>
  Testisyötteen voi antaa merkkijonona Scanner-oliolle konstruktorissa. Jokainen testisyötteessä annettava rivinvaihto merkitään merkkijonoon kenoviivan ja n-merkin yhdistelmänä "\n".
</p>

<% partial 'partials/code_highlight' do %>
  String syote = "yksi\n" + "kaksi\n"  +
                 "kolme\n" + "nelja\n" +
                 "viisi\n" + "yksi\n"  +
                 "kuusi\n";

  Scanner lukija = new Scanner(syote);

  ArrayList&lt;String&gt; luetut = new ArrayList&lt;&gt;();

  while (true) {
      System.out.println("Anna syote: ");
      String rivi = lukija.nextLine();
      if (luetut.contains(rivi)) {
          break;
      }

      luettu.add(rivi);
  }

  System.out.println("Kiitos!");

  if (luetut.sisaltaa("kuusi")) {
      System.out.println("Joukkoon lisättiin arvo, jota sinne ei olisi pitänyt lisätä.");
  }
<% end %>

<p>
  Ohjelma tulostus näyttää vain ohjelman antaman tulostuksen, ei käyttäjän tekemiä komentoja.
</p>

<% partial 'partials/sample_output' do %>
  Anna syote:
  Anna syote:
  Anna syote:
  Anna syote:
  Anna syote:
  Anna syote:
  Kiitos!
<% end %>

<p>
  Merkkijonon antaminen Scanner-luokan konstruktorille korvaa näppäimistöltä luettavan syötteen. Merkkijonomuuttujan <code>syote</code> sisältö siis "simuloi" käyttäjän antamaa syötettä. Rivinvaihto syötteeseen merkitään <code>\n</code>:llä. Jokainen yksittäinen rivinvaihtomerkkiin loppuva osa syote-merkkijonossa siis vastaa yhtä nextLine()-komentoon annettua syötettä.
</p>

<p>
  Kun haluat testata ohjelmasi toimintaa jälleen käsin, vaihda Scanner-olion konstruktorin parametriksi <code>System.in</code>, eli järjestelmän syötevirta. Voit toisaalta halutessasi myös vaihtaa testisyötettä, sillä kyse on merkkijonosta.
</p>

<p>
  Ohjelman toiminnan oikeellisuus tulee edelleen tarkastaa ruudulta. Tulostus voi olla aluksi hieman hämmentävää, sillä automatisoitu syöte ei näy ruudulla ollenkaan. Lopullinen tavoite on automatisoida myös ohjelman tulostuksen oikeellisuden tarkastaminen niin hyvin, että ohjelman testaus ja testituloksen analysointi onnistuu "nappia painamalla". Palaamme aiheeseen myöhemmissä osissa.
</p>

<% partial 'partials/material_sub_heading' do %>
  Yksikkötestaus
<% end %>

<p>
  Edellä esitetty menetelmä automaattiseen testaamiseen missä ohjelmalle syötetyt syötteet muutetaan on varsin kätevä, mutta kuitenkin melko rajoittunut. Isompien ohjelmien testaaminen edellä kuvatulla tavalla on haastavaa. Eräs ratkaisu tähän on yksikkötestaus, missä ohjelman pieniä osia testataan erikseen.
</p>

<p>
  Yksikkötestauksella tarkoitetaan lähdekoodiin kuuluvien yksittäisten osien kuten luokkien ja niiden tarjoamien metodien testaamista.  Luokkien ja metodien rakenteen suunnittelussa käytettävän ohjesäännön -- jokaisella metodilla ja luokalla tulee olla yksi selkeä vastuu -- noudattamisen tai siitä poikkeamisen huomaa testejä kirjoittaessa. Mitä useampi vastuu metodilla on, sitä monimutkaisempi testi on. Jos laaja sovellus on kirjoitettu yksittäiseen metodiin, on testien kirjoittaminen sitä varten erittäin haastavaa ellei jopa mahdotonta. Vastaavasti, jos sovellus on pilkottu selkeisiin luokkiin ja metodeihin, on testienkin kirjoittaminen suoraviivaista.
</p>

<p>
  Testien kirjoittamisessa hyödynnetään tyypillisesti valmiita yksikkötestauskirjastoja, jotka tarjoavat metodeja ja apuluokkia testien kirjoittamiseen. Javassa käytetyin yksikkötestauskirjasto on <a href="http://junit.org/" target="_blank" rel="noopener">JUnit</a>, johon löytyy myös tuki lähes kaikista ohjelmointiympäristöistä. Esimerkiksi NetBeans osaa automaattisesti etsiä JUnit-testejä projektista -- jos testejä löytyy, ne näytetään projektin alla Test Packages -kansiossa.
</p>

<p>
  Tarkastellaan yksikkötestien kirjoittamista esimerkin kautta. Oletetaan, että käytössämme on seuraava luokka Laskin, ja haluamme kirjoittaa sitä varten automaattisia testejä.
</p>


<% partial 'partials/code_highlight' do %>
  public class Laskin {

      private int arvo;
 
      public Laskin() {
          this.arvo = 0;
      }

      public void summa(int luku) {
          this.arvo += luku;
      }

      public void erotus(int luku) {
          this.arvo += luku;
      }

      public int getArvo() {
          return this.arvo;
      }
  }
<% end %>

<p>
  Laskimen toiminta perustuu siihen, että se muistaa aina edellisen laskuoperaation tuottaman tuloksen. Seuraavat laskuoperaatiot lisätään aina edelliseen lopputulokseen. Yllä olevaan laskimeen on jäänyt myös pieni copy-paste -ohjelmoinnista johtuva virhe. Metodin erotus pitäisi vähentää arvosta, mutta nyt se lisää arvoon.
</p>

<p>
  Yksikkötestien kirjoittaminen aloitetaan testiluokan luomisella. Testiluokka luodaan Test Packages -kansion alle. Kun testaamme luokkaa <code>Laskin</code>, testiluokan nimeksi tulee <code>LaskinTest</code>. Nimen lopussa oleva merkkijono <code>Test</code> kertoo ohjelmointiympäristölle, että kyseessä on testiluokka. Ilman merkkijonoa Test luokassa olevia testejä ei suoriteta. (Huom! Testit luodaan NetBeansissa Test Packages -kansion alle.)
</p>

<p>
  Testiluokka LaskinTest on aluksi tyhjä.
</p>


<% partial 'partials/code_highlight' do %>
  public class LaskinTest {

  }
<% end %>

<p>
  Testit ovat testiluokassa olevia metodeja ja jokainen testi testaa yksittäistä asiaa. Aloitetaan luokan Laskin testaaminen -- luodaan ensin testimetodi, jossa varmistetaan, että juuri luodun laskimen sisältämä arvo on 0.
</p>

<% partial 'partials/code_highlight' do %>
  import static org.junit.Assert.assertEquals;
  import org.junit.Test;

  public class LaskinTest {

      @Test
      public void laskimenArvoAlussaNolla() {
          Laskin laskin = new Laskin();
          assertEquals(0, laskin.getArvo());
      }
  }
<% end %>

<p>
  Yllä olevassa metodissa laskimenArvoAlussaNolla luodaan ensin laskinolio. Tämän jälkeen käytetään JUnit-testikehyksen tarjoamaa assertEquals-metodia arvon tarkistamiseen. Metodi tuodaan luokasta Assert komennolla import static, ja sille annetaan parametrina odotettu arvo -- tässä 0 -- sekä laskimen palauttama arvo. Jos metodin assertEquals arvot poikkeavat toisistaan, testin suoritus ei pääty hyväksytysti. Jokaisella testimetodilla tulee olla <em>annotaatio</em> @Test -- tämä kertoo JUnit-testikehykselle, että kyseessä on suoritettava testimetodi.
</p>

<p>
  Testien suorittaminen onnistuu valitsemalla projekti oikealla hiirennapilla ja klikkaamalla vaihtoehtoa Test.
</p>

<p>
  Testien suorittaminen luo output-välilehdelle (tyypillisesti NetBeansin alalaidassa) tulosteen, jossa on testiluokkakohtaiset tilastot. Alla olevassa esimerkissä on suoritettu pakkauksessa laskin olevan testiluokan LaskinTest testit. Testejä suoritettiin 1, joista yksikään ei epäonnistunut -- epäonnistuminen tarkoittaa tässä sitä, että testin testaama toiminnallisuus ei toiminut oletetusti.
</p>

<% partial 'partials/sample_output' do %>
  Testsuite: LaskinTest
  Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.054 sec

  test-report:
  test:
  BUILD SUCCESSFUL (total time: 0 seconds)
<% end %>

<p>
  Lisätään testiluokkaan summaa ja erotusta lisäävää toiminnallisuutta.
</p>

<% partial 'partials/code_highlight' do %>
  import static org.junit.Assert.assertEquals;
  import org.junit.Test;

  public class LaskinTest {

      @Test
      public void laskimenArvoAlussaNolla() {
          Laskin laskin = new Laskin();
          assertEquals(0, laskin.getArvo());
      }

      @Test
      public void arvoViisiKunSummataanViisi() {
          Laskin laskin = new Laskin();
          laskin.summa(5);
          assertEquals(5, laskin.getArvo());
      }

      @Test
      public void arvoMiinusKaksiKunErotetaanKaksi() {
          Laskin laskin = new Laskin();
          laskin.erotus(2);
          assertEquals(-2, laskin.getArvo());
      }
  }
<% end %>

<p>
  Testien suorittaminen antaa seuraavanlaisen tulostuksen.
</p>

<% partial 'partials/sample_output' do %>
  Testsuite: LaskinTest
  Tests run: 3, Failures: 1, Errors: 0, Skipped: 0, Time elapsed: 0.059 sec

  Testcase: arvoMiinusKaksiKunErotetaanKaksi(LaskinTest):	FAILED
  expected:<-2> but was:<2>
  junit.framework.AssertionFailedError: expected:<-2> but was:<2>
      at LaskinTest.arvoMiinusKaksiKunErotetaanKaksi(LaskinTest.java:25)


  Test LaskinTest FAILED
  test-report:
  test:
  BUILD SUCCESSFUL (total time: 0 seconds)
<% end %>

<p>
  Tulostus kertoo, että kolme testiä suoritettiin. Yksi niistä päätyi virheeseen. Testitulostuksessa on tieto myös testin rivistä, jossa virhe tapahtui (25) sekä tieto odotetusta (-2) ja saadusta arvosta (2). Kun testien suoritus päättyy virheeseen, NetBeans näyttää testien suoritukseen liitttyvän virhetilanteen myös visuaalisena.
</p>

<p>
  Edellisillä testeillä kaksi testeistä menee läpi, mutta yhdessä on tapahtunut virhe. Korjataan luokkaan Laskin jäänyt virhe.
</p>

<% partial 'partials/code_highlight' do %>
  // ...
  public void erotus(int luku) {
      this.arvo -= luku;
  }
  // ...
<% end %>

<p>
  Kun testit suoritetaan uudestaan, testit menevät läpi.
</p>

<% partial 'partials/sample_output' do %>
  Testsuite: LaskinTest
  Tests run: 3, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.056 sec

  test-report:
  test:
  BUILD SUCCESSFUL (total time: 0 seconds)
<% end %>


<% partial 'partials/material_heading' do %>
  Testivetoinen ohjelmistokehitys
<% end %>

<p>
  Testivetoinen ohjelmistokehitys (<a href="https://en.wikipedia.org/wiki/Test-driven_development" target="_blank" rel="noopener">Test-driven development</a>) on ohjelmistokehitysprosessi, joka perustuu ohjelman rakentamiseen pienissä osissa. Testivetoisessa ohjelmistokehityksessä ohjelmoija kirjoittaa aina ensin automaattisesti suoritettavan yksittäistä tietokoneohjelman osaa tarkastelevan testin.
</p>

<p>
  Testi ei mene läpi, sillä testin täyttävä toiminnallisuus eli tarkasteltava tietokoneohjelman osa puuttuu. Kun testi on kirjoitettu, ohjelmaan lisätään toiminnallisuus, joka täyttää testin vaatimukset. Testit suoritetaan uudestaan, jonka jälkeen -- jos kaikki testit menevät läpi -- lisätään uusi testi tai vaihtoehtoisesti -- jos testit eivät mene läpi -- korjataan aiemmin kirjoitettua ohjelmaa. Ohjelman sisäistä rakennetta korjataan eli refaktoroidaan tarvittaessa siten, että ohjelman toiminnallisuus pysyy samana mutta rakenne selkiytyy.
</p>

<p>
  Testivetoinen ohjelmistokehitys koostuu viidestä askeleesta, joita toistetaan kunnes ohjelman toiminnallisuus on valmis.
</p>

<ul>
  <li>
    Kirjoita testi. Ohjelmoija päättää, mitä ohjelman toiminnallisuutta testataan, ja kirjoittaa toiminnallisuutta varten testin.
  </li>
  <li>
    Suorita testit ja tarkista menevätkö testit läpi. Kun uusi testi on kirjoitettu, testit suoritetaan. Jos testin suoritus päättyy hyväksyttyyn tilaan, testissä on todennäköisesti virhe ja se tulee korjata -- testin pitäisi testata vain toiminnallisuutta, jota ei ole vielä toteutettu.
  </li>
  <li>
    Kirjoita toiminnallisuus, joka täyttää testin vaatimukset. Ohjelmoija toteuttaa toiminnallisuuden, joka täyttää vain testin vaatimukset. Huomaa, että tässä ei toteuteta asioita, joita testi ei vaadi -- toiminnallisuutta lisätään vain vähän kerrallaan.
  </li>
  <li>
    Suorita testit. Jos testit eivät pääty hyväksyttyyn tilaan, kirjoitetussa toiminnallisuudessa on todennäköisesti virhe. Korjaa toiminnallisuus -- tai, jos toiminnallisuudessa ei ole virhettä -- korjaa viimeksi toteutettu testi.
  </li>
  <li>
    Korjaa ohjelman sisäistä rakennetta. Kun ohjelman koko kasvaa, sen sisäistä rakennetta korjataan tarvittaessa. Liian pitkät metodit pilkotaan useampaan osaan ja ohjelmasta eriytetään käsitteisiin liittyviä luokkia. Testejä ei muuteta, vaan niitä hyödynnetään ohjelman sisäiseen rakenteeseen tehtyjen muutosten oikeellisuuden varmistamisessa -- jos ohjelman rakenteeseen tehty muutos muuttaa ohjelman toiminnallisuutta, testit varoittavat siitä, ja ohjelmoija voi korjata tilanteen.
  </li>
</ul>


<% partial 'partials/material_sub_heading' do %>
  Testiluokka ja ensimmäinen testi
<% end %>

<p>
  Tarkastellaan tätä prosessia tehtävien hallintaan tarkoitetun sovelluksen kannalta. Tehtävien hallintasovellukseen halutaan mahdollisuus tehtävien listaamiseen, lisäämiseen, tehdyksi merkkaamiseen sekä poistamiseen. Aloitetaan sovelluksen kehitys luomalla tyhjä testiluokka. Asetetaan testiluokan nimeksi TehtavienHallintaTest, ja lisätään se pakkaukseen tehtavat. Tällä hetkellä sovelluksessa ei ole vielä lainkaan toiminnallisuutta.
</p>

<img src="/img/material/tehtavienhallinta-testiluokka.png"/>

<p>&nbsp;</p>

<p>
  Luodaan ensimmäinen testi. Testissä määritellään luokka Tehtavienhallinta, ja oletetaan, että luokalla on metodi tehtavalista, joka palauttaa tehtävälistan. Testimetodi <code>assertEquals</code> saa parametrinaan kaksi arvoa -- ensimmäinen on odotettu arvo ja toinen on ohjelman palauttama arvo. Tässä metodia käytetään tehtävälistan koon tarkastamiseen uuden tehtävälistan luomisen yhteydessä: uuden listan tulee olla tyhjä.
</p>


<% partial 'partials/code_highlight' do %>

  import static org.junit.Assert.assertEquals;
  import org.junit.Test;

  public class TehtavienhallintaTest {

      @Test
      public void tehtavalistaAlussaTyhja() {
          Tehtavienhallinta hallinta = new Tehtavienhallinta();
          assertEquals(0, hallinta.tehtavalista().size());
      }
  }
<% end %>

<p>
  Luokkaa Tehtavienhallinta ei ole määritelty joten testien suoritus epäonnistuu.
</p>


<% partial 'partials/material_sub_heading' do %>
  Ensimmäisen testin vaatimusten täyttäminen
<% end %>

<p>
  Toteutetaan seuraavaksi toiminnallisuus, joka täyttää testin. Luodaan luokka Tehtavienhallinta ja lisätään luokalle toiminnallisuus, joka täyttää testin vaatimukset. Luokka luodaan NetBeansissa kansioon Source Packages. Nyt projekti näyttää seuraavalta.
</p>


<img src="/img/material/tehtavienhallinta-luokat.png"/>

<p>&nbsp;</p>

<p>
  Toiminnallisuus on yksinkertainen. Luokalla Tehtavienhallinta on metodi tehtavalista, joka palauttaa tyhjän listan.
</p>

<% partial 'partials/code_highlight' do %>

  import java.util.ArrayList;

  public class Tehtavienhallinta {

      public ArrayList&lt;String&gt; tehtavalista() {
          return new ArrayList&lt;&gt;();
      }
  }
<% end %>

<p>
  Testit menevät läpi. Luokan Tehtavienhallinta sisäinen rakenne on vielä niin pieni, ettei siinä ole juurikaan korjattavaa.
</p>


<% partial 'partials/material_sub_heading' do %>
  Toinen testi
<% end %>

<p>
  Aloitamme testivetoiseen kehitykseen liittyvän syklin uudestaan. Seuraavaksi luomme uuden testin, jossa tarkastellaan tehtävien lisäämiseen liittyvää toiminnallisuutta. Testissä määritellään luokalle Tehtavienhallinta metodi lisää, joka lisää tehtävälistalle uuden tehtävän. Tehtävän lisäämisen onnistuminen tarkastetaan tehtavalista-metodin koon kasvamisen kautta.
</p>

<% partial 'partials/code_highlight' do %>

  import static org.junit.Assert.assertEquals;
  import org.junit.Test;

  public class TehtavienhallintaTest {

      @Test
      public void tehtavalistaAlussaTyhja() {
          Tehtavienhallinta hallinta = new Tehtavienhallinta();
          assertEquals(0, hallinta.tehtavalista().size());
      }

      @Test
      public void tehtavanLisaaminenKasvattaaListanKokoaYhdella() {
          Tehtavienhallinta hallinta = new Tehtavienhallinta();
          hallinta.lisaa("Kirjoita testi");
          assertEquals(1, hallinta.tehtavalista().size());
      }
  }
<% end %>

<p>
  Testi ei toimi lainkaan, sillä luokasta Tehtavienhallinta puuttuu lisaa-metodi.
</p>

<% partial 'partials/material_sub_heading' do %>
  Toisen testin vaatimusten täyttäminen
<% end %>

<p>
  Lisätään luokkaan Tehtavienhallinta metodi <code>lisaa</code>, ja suoritetaan testit.
</p>

<% partial 'partials/code_highlight' do %>

  import java.util.ArrayList;

  public class Tehtavienhallinta {

      public ArrayList&lt;String&gt; tehtavalista() {
          return new ArrayList&lt;&gt;();
      }

      public void lisaa(String tehtava) {

      }
  }
<% end %>

<p>
  Nyt testien ajamisesta saadaan seuraava ilmoitus.
</p>

<% partial 'partials/sample_output' do %>
  Testsuite: TehtavienhallintaTest
  Tests run: 2, Failures: 1, Errors: 0, Skipped: 0, Time elapsed: 0.053 sec

  Testcase: tehtavanLisaaminenKasvattaaListanKokoaYhdella(TehtavienhallintaTest):	FAILED
      expected:<1> but was:<0>
      junit.framework.AssertionFailedError: expected:<1> but was:<0>
      at TehtavienhallintaTest.tehtavanLisaaminenKasvattaa...(TehtavienhallintaTest.java:18)
<% end %>

<p>
  Testit eivät siis mene vieläkään läpi. Muokataan luokan tehtävänhallinta toiminnallisuutta siten, että luokalle luodaan oliomuuttujaksi tehtävät sisältävä lista. Muokataan metodin lisaa-toiminnallisuutta vain niin, että se läpäisee testin, mutta ei tee todellisuudessa haluttua asiaa.
</p>

<% partial 'partials/code_highlight' do %>

  import java.util.ArrayList;

  public class Tehtavienhallinta {

      private ArrayList&lt;String&gt; tehtavat;

      public Tehtavienhallinta() {
          this.tehtavat = new ArrayList&lt;&gt;();
      }

      public ArrayList&lt;String&gt; tehtavalista() {
          return this.tehtavat;
      }

      public void lisaa(String tehtava) {
          this.tehtavat.add("Uusi");
      }
  }
<% end %>

<p>
  Testit menevät läpi, joten olemme tyytyväisiä ja voimme siirtyä seuraavaan askeleeseen.
</p>

<% partial 'partials/sample_output' do %>
  Testsuite: TehtavienhallintaTest
  Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.056 sec

  test-report:
  test:
  BUILD SUCCESSFUL (total time: 0 seconds)
<% end %>


<% partial 'partials/material_sub_heading' do %>
  Kolmas testi
<% end %>

<p>
  Täydennetään testejä siten, että ne vaativat, että lisätyn tehtävän tulee olla listalla. JUnit-kirjaston tarjoama metodi <code>assertTrue</code> vaatii, että sille parametrina annettu lauseke saa lopulta arvon <code>true</code>.
</p>

<% partial 'partials/code_highlight' do %>

  import static org.junit.Assert.assertEquals;
  import static org.junit.Assert.assertTrue;
  import org.junit.Test;

  public class TehtavienhallintaTest {

      @Test
      public void tehtavalistaAlussaTyhja() {
          Tehtavienhallinta hallinta = new Tehtavienhallinta();
          assertEquals(0, hallinta.tehtavalista().size());
      }

      @Test
      public void tehtavanLisaaminenKasvattaaListanKokoaYhdella() {
          Tehtavienhallinta hallinta = new Tehtavienhallinta();
          hallinta.lisaa("Kirjoita testi");
          assertEquals(1, hallinta.tehtavalista().size());
      }

      @Test
      public void lisattyTehtavaLoytyyTehtavalistalta() {
          Tehtavienhallinta hallinta = new Tehtavienhallinta();
          hallinta.lisaa("Kirjoita testi");
          assertTrue(hallinta.tehtavalista().contains("Kirjoita testi"));
      }
  }
<% end %>

<p>
  Testit eivät mene taaskaan läpi ja ohjelman toiminnallisuutta tulee muokata.
</p>


<% partial 'partials/material_sub_heading' do %>
  Kolmannen testin vaatimusten täyttäminen
<% end %>

<p>
  Noheva ohjelmoija muokkaisi luokan Tehtavienhallinta toimintaa siten, että metodissa lisaa lisättäisiin listalle aina merkkijono "Kirjoita testi". Tämä johtaisi tilanteeseen, missä testit menisivät läpi, mutta toiminnallisuus sovellus ei vieläkään tarjoaisi toimivaa tehtävien lisäämistoiminnallisuutta. Muokataan luokkaa Tehtavienhallinta siten, että lisättävä tehtävä lisätään tehtävälistalle.
</p>

<% partial 'partials/code_highlight' do %>

  import java.util.ArrayList;

  public class Tehtavienhallinta {

      private ArrayList&lt;String&gt; tehtavat;

      public Tehtavienhallinta() {
          this.tehtavat = new ArrayList&lt;&gt;();
      }

      public List&lt;String&gt; tehtavalista() {
          return this.tehtavat;
      }

      public void lisaa(String tehtava) {
          this.tehtavat.add(tehtava);
      }
  }
<% end %>

<p>
  Nyt testit menevät taas läpi.
</p>


<% partial 'partials/material_sub_heading' do %>
  Testien refaktorointi
<% end %>

<p>
  Huomaamme, että testiluokassa on taas jonkinverran toistoa -- siirretään Tehtavienhallinta testiluokan oliomuuttujaksi, ja alustetaan se jokaisen testin alussa. Metodi <code>alusta</code> suoritetaan ennen jokaisen testimetodin suoritusta. Tämä tapahtuu koska metodille on määritelty ohjeiden antamiseen tarkoitettu <em>annotaatio</em> <code>@Before</code>.
</p>

<% partial 'partials/code_highlight' do %>

  import static org.junit.Assert.assertEquals;
  import static org.junit.Assert.assertTrue;
  import org.junit.Before;
  import org.junit.Test;

  public class TehtavienhallintaTest {

      private Tehtavienhallinta hallinta;

      @Before
      public void alusta() {
          hallinta = new Tehtavienhallinta();
      }

      @Test
      public void tehtavalistaAlussaTyhja() {
          assertEquals(0, hallinta.tehtavalista().size());
      }

      @Test
      public void tehtavanLisaaminenKasvattaaListanKokoaYhdella() {
          hallinta.lisaa("Kirjoita testi");
          assertEquals(1, hallinta.tehtavalista().size());
      }

      @Test
      public void lisattyTehtavaLoytyyTehtavalistalta() {
          hallinta.lisaa("Kirjoita testi");
          assertTrue(hallinta.tehtavalista().contains("Kirjoita testi"));
      }
  }
<% end %>


<% partial 'partials/material_sub_heading' do %>
  Neljäs testi
<% end %>

<p>
  Lisätään seuraavaksi mahdollisuus tehtävän tehdyksi merkkaamiseen. Mutta! Mitä tarkoittaa tehdyksi merkkaaminen? Alunperin tavoitteena oli luoda ohjelma, joka mahdollistaa tehtävien listaamisen, listaamisen, tehdyksi merkkaamisen sekä poistamisen. Miten tarkastamme onko tehtävä tehty? Jos emme voi tietää onko tehtävä tehty vai ei, voisimme periaatteessa jättää koko toiminnallisuuden huomiotta. Voimme toisaalta päättää miten tehtän tehdyksi määrittely tapahtuu.
</p>

<p>
  Määritellään ensin testi, joka mahdollistaa tehtävän tehdyksi merkkaamiseen.
</p>

<% partial 'partials/code_highlight' do %>
  // ...
  @Test
  public void tehtavanVoiMerkataTehdyksi() {
      hallinta.lisaa("Satunnainen tehtava");
      hallinta.merkkaaTehdyksi("Satunnainen tehtava");
  }
  // ..
<% end %>

<% partial 'partials/material_sub_heading' do %>
  Neljännen testin vaatimusten täyttäminen
<% end %>

<p>
  Tehtavienhallintaan lisätään seuraavaksi metodi merkkaaTehdyksi. Metodin toiminnallisuus voi olla aluksi tyhjä, sillä testi vaatii vain kyseisen metodin olemassaolon.
</p>

<% partial 'partials/material_sub_heading' do %>
  Viides testi
<% end %>

<p>
  Lisätään tämän jälkeen testi, jonka tehtävänä on tarkistaa onko parametrina annettu tehtävä tehty.
</p>

<% partial 'partials/code_highlight' do %>
  // ...
  @Test
  public void tehdyksiMerkattuOnTehty() {
      hallinta.lisaa("Uusi tehtava");
      hallinta.merkkaaTehdyksi("Uusi tehtava");
      assertTrue(hallinta.onTehty("Uusi tehtava"));
  }
  // ..
<% end %>


<% partial 'partials/material_sub_heading' do %>
  Viidennen testin vaatimusten täyttäminen
<% end %>

<p>
  Nyt toiminnallisuutta varten tulee toteuttaa uusi metodi onTehty. Metodi voi aluksi palauttaa aina arvon true. Kokko luokan Tehtavienhallinta sisältö on nyt seuraava.
</p>

<% partial 'partials/code_highlight' do %>

  import java.util.ArrayList;

  public class Tehtavienhallinta {

      private ArrayList&lt;String&gt; tehtavat;

      public Tehtavienhallinta() {
          this.tehtavat = new ArrayList&lt;&gt;();
      }

      public ArrayList&lt;String&gt; tehtavalista() {
          return this.tehtavat;
      }

      public void lisaa(String tehtava) {
          this.tehtavat.add(tehtava);
      }

      public void merkkaaTehdyksi(String tehtava) {

      }

      public boolean onTehty(String tehtava) {
          return true;
      }
  }
<% end %>

<p>
  Testit menevät taas läpi.
</p>


<% partial 'partials/material_sub_heading' do %>
  Kuudes testi
<% end %>

<p>
  Seuraavaksi toteutettava testi on oleellinen tehtävän toiminnan kannalta. Olemme tähän mennessä tarkistaneet, että haluttu toiminnallisuus on olemassa, mutta emme ole juurikaan tarkastaneet epätoivotun toiminnan poissaoloa. Jos testejä kirjoitettaessa keskitytään halutun toiminnallisuuden olemassaoloon, testit saattavat jäädä ohjelman toiminnallisuutta hyvin vähän tarkastelevaksi.
</p>

<p>
  Kirjoitetaan seuraavaksi testi, joka tarkastaa, että tekemättömäksi merkkaamaton testi ei ole tehty.
</p>


<% partial 'partials/code_highlight' do %>
  // ...
  @Test
  public void tehdyksiMerkkaamatonEiOleTehty() {
      hallinta.lisaa("Uusi tehtava");
      hallinta.merkkaaTehdyksi("Uusi tehtava");
      assertFalse(hallinta.onTehty("Joku tehtava"));
  }
  // ..
<% end %>


<% partial 'partials/material_sub_heading' do %>
  Kuudennen testin vaatimusten täyttäminen
<% end %>

<p>
  Joudumme nyt muokkaamaan luokan Tehtavienhallinta toiminnallisuutta hieman enemmän. Lisätään luokkaan erillinen lista tehtäville, jotka on merkattu tehdyiksi.
</p>

<% partial 'partials/code_highlight' do %>

  import java.util.ArrayList;

  public class Tehtavienhallinta {

      private ArrayList&lt;String&gt; tehtavat;
      private ArrayList&lt;String&gt; tehdytTehtavat;

      public Tehtavienhallinta() {
          this.tehtavat = new ArrayList&lt;&gt;();
          this.tehdytTehtavat = new ArrayList&lt;&gt;();
      }

      public List&lt;String&gt; tehtavalista() {
          return this.tehtavat;
      }

      public void lisaa(String tehtava) {
          this.tehtavat.add(tehtava);
      }

      public void merkkaaTehdyksi(String tehtava) {
          this.tehdytTehtavat.add(tehtava);
      }

      public boolean onTehty(String tehtava) {
          return this.tehdytTehtavat.contains(tehtava);
      }
  }
<% end %>

<p>
  Testit menevät taas läpi. Sovelluksessa on muutamia muitakin kysymysmerkkejä. Pitäisikö tehtavalistauksessa palautetut tehtävät merkitä jollain tavalla tehdyksi? Voiko tehtävän, joka ei ole tehtävälistalla tosiaankin merkata tehdyksi?
</p>


<% partial 'partials/material_sub_heading' do %>
  Refaktorointi ja käsite "Tehtävä"
<% end %>

<p>
  Tehdään ensimmäinen hieman laajempi ohjelman sisäisen rakenteen korjaus. Tehtävä on selkeästi käsite, joten sille kannattanee luoda oma erillinen luokka. Luodaan luokka Tehtava. Luokalla Tehtava on nimi sekä tieto siitä, onko tehtävä tehty.
</p>

<% partial 'partials/code_highlight' do %>

  public class Tehtava {

      private String nimi;
      private boolean tehty;

      public Tehtava(String nimi) {
          this.nimi = nimi;
          this.tehty = false;
      }

      public String getNimi() {
          return nimi;
      }

      public void setTehty(boolean tehty) {
          this.tehty = tehty;
      }

      public boolean onTehty() {
          return tehty;
      }
  }
<% end %>

<p>
  Muokataan tämän jälkeen luokan Tehtavienhallinta <em>sisäistä</em> rakennetta siten, että luokka tallentaa tehtävät merkkijonojen sijaan Tehtava-olioina. Huomaa, että luokan metodien määrittelyt eivät muutu, mutta niiden sisäinen toteutus muuttuu.
</p>

<% partial 'partials/code_highlight' do %>

  import java.util.ArrayList;

  public class Tehtavienhallinta {

      private ArrayList&lt;Tehtava&gt; tehtavat;

      public Tehtavienhallinta() {
          this.tehtavat = new ArrayList&lt;&gt;();
      }

      public ArrayList&lt;String&gt; tehtavalista() {
          ArrayList&lt;String&gt; palautettavat = new ArrayList&lt;&gt;();
          for (Tehtava tehtava: tehtavat) {
              palautettavat.add(tehtava.getNimi());
          }

          return palautettavat;
      }

      public void lisaa(String tehtava) {
          this.tehtavat.add(new Tehtava(tehtava));
      }

      public void merkkaaTehdyksi(String tehdyksiMerkattavaTehtava) {
          for (Tehtava tehtava: tehtavat) {
              if (tehtava.getNimi().equals(tehdyksiMerkattavaTehtava)) {
                  tehtava.setTehty(true);
              }
          }
      }

      public boolean onTehty(String tarkistettavaTehtava) {
          for (Tehtava tehtava: tehtavat) {
              if (tehtava.getNimi().equals(tarkistettavaTehtava) && tehtava.onTehty()) {
                  return true;
              }
          }

          return false;
      }
  }
<% end %>

<p>
  Vaikka tehty muutos muutti luokan Tehtavienhallinta sisäistä toimintaa merkittävästi, testit toimivat yhä. Sykli jatkuisi samalla tavalla kunnes toivottu perustoiminnallisuus olisi paikallaan.
</p>


<% partial 'partials/exercise', locals: { name: 'Tehtavat (3 osaa)' } do %>

  <p>
    Tehtäväpohjassa tulee edellisen esimerkin alkutilanne. Seuraa edellistä esimerkkiä, ja luo Tehtavienhallinnalta haluttu toiminnallisuus testivetoista ohjelmistokehitystä noudattaen. Kun olet saanut edellisen esimerkin loppuun asti, lisää sovellukseen vielä testit tehtävien poistamiseen sekä testien vaatima toiminnallisuus.
  </p>

  <p>
    Kohdat on pisteytetty askeleittain, jotka ovat seuraavat:
  </p>

  <ol>
    <li>
      Testiluokka ja ensimmäinen testi, ensimmäisen testin vaatimusten täyttäminen. Toinen testi, toisen testin vaatimusten täyttäminen.
    </li>
    <li>
      Kolmas testi, kolmannen testin vaatimusten täyttäminen, testien refaktorointi. Neljäs testi, neljännen testin vaatimusten täyttäminen, viides testi, viidennen testin vaatimusten täyttäminen.
    </li>
    <li>
      Kuudes testi, kuudennen testin vaatimusten täyttäminen. Refaktorointi ja käsitteen tehtävä eristäminen. Tehtävien poistamiseen liittyvät testit sekä toiminnallisuus -- toteuta poistaminen Tehtavienhallinta-luokkaan metodina <code>public void poista(String tehtava)</code>
    </li>
  </ol>

  <p>
    Sitä mukaa kun kehität toiminnallisuutta, päivitä luokan Ohjelma metodia <code>osiaToteutettu</code> palauttamaan valmiiksi saamasi osan numero. Voit palauttaa tehtävän vaikket tekisikään kaikkia osia, jolloin saat pisteitä tehtävän niistä osista, jotka olet tehnyt.
  </p>

  <p>
    Esimerkiksi, kun olet saanut ensimmäiset kaksi testiä sekä niihin liittyvän toiminnallisuuden toimimaan olet vaiheessa 1, jolloin metodin <code>osiaToteutettu</code> tulisi palautta arvo <code>1</code>.
  </p>

<% end %>


<% partial 'partials/hint', locals: { name: 'Lisää ohjelmistojen testaamisesta' } do %>

  <p>
    Yksikkötestaus on vain osa ohjelmiston testaamista. Yksikkötestaamisen lisäksi ohjelmiston toteuttaja toteuttaa myös integraatiotestejä, joissa tarkastellaan komponenttien kuten luokkien yhteistoiminnallisuutta, sekä käyttöliittymätestejä, joissa testataan sovelluksen käyttöliittymää käyttöliittymän tarjoamien elementtien kuten nappien kautta.
  </p>

  <p>
    Näitä testaamiseen liittyviä menetelmiä tarkastellaan tarkemmin muunmuassa kursseilla ohjelmistotekniikan menetelmät sekä ohjelmistotuotanto.
  </p>

<% end %>




<% partial 'partials/material_heading' do %>
  Crowdsorcerer: Arvioi tehtäviä
<% end %>

<p>
  Otetaan hetkeksi askel taaksepäin ja muistellaan hajautustaulujen käyttöä. Tämän jälkeen tutustumme listojen ja hajautustaulujen käyttöä hajautustaulun arvona.
</p>

<p>
  Ohjelmointikurssin kuudennessa osassa loimme taas omia tehtäviä Crowdsorcererin avulla. Nyt on hetki vertaisarviointiin -- arvioimme Crowdsorcereriin lähetettyjä tehtäviä! Anna vertaispalautetta kahdesta jonkun toisen kurssilaisen lähettämästä tehtävästä ja arvioi lopuksi itse tekemääsi tehtävää. Itse tekemäsi tehtävä näkyy vain jos olet tehnyt sen -- jos et tehnyt tehtävää, pääset arvioimaan yhden ylimääräisen tehtävän.
</p>

<% partial 'partials/hint', locals: { name: 'Vertaisarviointi' } do %>

  <p>
    Alla on kolme Crowdsorcereriin tehtyä tehtävää: kaksi jonkun kurssitoverisi lähettämää ja yksi itsearviointia varten. Niiden yhteydessä on muistin virkistykseksi ohjeistus, jonka pohjalta kyseiset tehtävänannot on tehty.
  </p>

  <p>
    Tarkastele jokaisen tehtävän eri osia: tehtävänantoa, tehtäväpohjaa ja malliratkaisua sekä testaukseen käytettäviä syötteitä ja tulosteita. Arvioi niiden selkeyttä, vaikeutta ja sitä, kuinka hyvin ne vastaavat ohjeistukseensa.
  </p>

  <p>
    Voit vaihtaa näkymää tehtäväpohjan ja mallivastauksen välillä painamalla lähdekoodin yläpalkin painikkeita. Palautteenannon avuksi on annettu väittämiä. Voit valita kuinka samaa mieltä niiden kanssa olet painamalla hymiöitä. Annathan myös sanallista palautetta sille varattuun kenttään! Lisää vielä tehtävää mielestäsi kuvaavia tageja ja paina Lähetä.
  </p>

  <p>
    Anna arvio kummallekin vertaispalautetehtävälle ja lopuksi vielä omallesi.
  </p>

  <p>
    Muista olla reilu ja ystävällinen. Hyvä palaute on rehellistä, mutta kannustavaa!
  </p>

  <p>
    Voit halutessasi ladata arvioitavan tehtävän tehtäväpohjan ja malliratkaisun koneellesi, ja testata niiden käyttöä. Molemmat tulevat ZIP-paketeissa, jolloin sinun täytyy purkaa ne, ennen kuin voit avata ne NetBeansissä.
  </p>

<% end %>


<% partial 'partials/general_callout', locals: { name: 'Suunnittele oma tehtävä: hajautustaulu' } do %>

  <p>
    Keksi tehtävä, jossa käytetään HashMappia. Tehtäväpohjassa on valmiina komennon kysyminen ja toistolause, joka jatkuu kunnes ohjelman käyttäjä kirjoittaa komennon "lopeta".
  </p>

  <p>
    <b>Huom!</b> Tässä sinun täytyy syöttää jokaiselle testitapaukselle useampi syöte. Useamman syötteen saat annettua, kun laitat rivinvaihdon <code>\n</code> jokaisen syötteen väliin. Lisäksi lopeta jokainen testisyöte tekstillä <code>lopeta</code>, jotta testissä silmukan suoritus lakkaa.
  </p>

  <p>
    Esimerkiksi jos haluat antaa testisyötteeksi "kissa", "koira", "lopeta", syötä input-kenttään teksti <code>kissa\nkoira\nlopeta</code>.
  </p>

  <p>
    Muista merkitä malliratkaisurivit ohjelmaan -- näin ratkaisu ei tule suoraan käyttäjälle näkyvään.
  </p>

<% end %>


<div class='crowdsorcerer-widget' data-assignment='8' peer-review data-exercises='3'></div>



<br/>
crowdsorcerer, koodin generointi